{"version":3,"file":"170.bundle.101a7759228261bd6c62.js","mappings":"gOAEMA,E,4DAAKC,GAELC,EAAsB,WACtBC,EAAqB,GAAEH,2BAA4BE,I,2DCLzD,SACEE,MAAO,QACPC,WAAY,aACZC,SAAU,WACVC,OAAQ,SACRC,QAAS,WCMI,MAAMC,UAA2BC,EAAAA,eAG9CC,WAAAA,GAMEC,MALSC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,CAAC,EACGA,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,CACjBG,cAAe,CAAC,IAqBpB,KACAC,gBAAkB,IAAM,KAAI,KAC5BC,wBAA0B,IAAM,KAAI,KAEpCC,iBAAmB,CACjBC,EACAC,KAEA,MAAM,SAAEC,GAAaF,GACf,QAAEG,GAAYD,EAEpB,IAAIE,EAAcC,EAAAA,WAAAA,MAAAA,eAChBC,KAAKC,cACLJ,GAIF,IAAKC,GAAaV,OAChB,OAQF,GALAU,EAAcE,KAAKE,wCACjBL,EACAC,IAGGA,GAAaV,OAChB,OAGF,MAAMe,GAAsCC,EAAAA,EAAAA,IAC1CP,IAGI,YACJQ,EAAW,0BACXC,GACEH,EAEEI,EACJD,EAA0BD,GAGtBG,EAAsBV,EAAYW,QAAOV,GAC7CO,EAA0BI,SACxBX,EAAWY,MAAMC,aAAaC,4BAIlC,IAAKjB,EAASkB,SAASC,KACrB,OAGF,MAAMC,EAAgE,CACpEC,YAAajB,KAAKiB,YAClBC,SAAUlB,KAAKC,cACfkB,WAAYzB,EAAeE,SAAStB,IAGtC,IAAK,IAAI8C,EAAI,EAAGA,EAAIZ,EAAoBpB,OAAQgC,IAAK,CACnD,MAAMrB,EAAaS,EAAoBY,GACjCC,EAAgBtB,EAAWsB,eAC3B,eAAEC,GAAmBvB,EAAWY,KAAKC,aACrC,YAAEA,GAAgBb,EAAWY,MAC7B,kBAAEY,GAAsBxB,EAAWyB,SAEzCR,EAAeK,cAAgBA,EAE/B,MAAMI,EAAYzB,KAAK0B,SAAS,YAAaV,EAAgBjB,GACvD4B,EAAW3B,KAAK0B,SAAS,WAAYV,EAAgBjB,GAMrD6B,EAAU,CACdC,MALAjB,EAAYC,2BAA6BN,EACrC,iBACAP,KAAK0B,SAAS,QAASV,EAAgBjB,GAI3C4B,WACAF,aAGFK,OAAOC,KAAKT,GAAgBU,SAAQC,IAClC,MAAMC,EAA+BZ,EAAeW,GAEpD,IAAIE,EACAC,EAEJ,OAAQH,GACN,KAAKI,EAAa3D,MAChByD,EAAenC,KAAKsC,YACpB,MACF,KAAKD,EAAa1D,WAChBwD,EAAenC,KAAKuC,iBACpB,MACF,KAAKF,EAAazD,SAChBuD,EAAenC,KAAKwC,eACpB,MACF,KAAKH,EAAaxD,OAChBsD,EAAenC,KAAKyC,cACpB,MACF,KAAKJ,EAAavD,QAChBqD,EAAenC,KAAKyC,cACpBL,EACEM,EAAAA,UAAAA,KAAAA,QAAAA,wBACF,MACF,QACE,MAAM,IAAIC,MAAO,4BAA2BV,KAGhD,MAAMW,EAAoBT,EACxBxC,EACAC,EACAsC,EACAb,EACAE,EACAK,GAGF5B,KAAK6C,cACHlD,EACAC,EACAgD,EACAR,EACArC,EACAiB,EACAY,EACD,GAEL,EAjJF,CAEAkB,0BAAAA,CAA2BC,GAGzB,MAAMC,EAAcC,KAAKC,IAAIH,EAAO3D,OAAQ,GACtC+D,EAAQ,GAEd,IAAK,IAAI/B,EAAI,EAAGA,EAAI4B,EAAa5B,IAAK,CACpC,MAAMgC,EAAaL,EAAO3B,GAC1B+B,EAAME,KAAM,GAAEC,EAAkBF,EAAWG,SAASH,EAAWI,QACjE,CAEA,OAAOL,CACT,CAsIAX,cAAAA,CACE7C,EACAC,EACA0B,EACAD,EACAE,EACAK,GAEA,MAAM6B,EAAiB,CACrB5B,MAAOD,EAAQC,MACf6B,MAAO9B,EAAQH,WAEjB,IAAIkC,EAAuB,GA2B3B,OA1BArC,EAAesC,KAAI,CAACjD,EAAMkD,KACxB,MAAMjB,EAAoBjC,EAAKiD,KAAIE,GAAKlE,EAASmE,cAAcD,KACzDE,EAAW,GAAEH,IAEc,IAA7BjB,EAAkBxD,OACpB6E,EAAAA,QAAAA,SACEtE,EACA0B,EACA2C,EACApB,EAAkB,GAClBA,EAAkB,GAClBa,GAGFQ,EAAAA,QAAAA,aACEtE,EACA0B,EACA2C,EACApB,EACAa,GAIJE,EAAuBA,EAAqBO,OAAOtB,EAAkB,IAGhEe,CACT,CAEApB,gBAAAA,CACE5C,EACAC,EACA0B,EACAD,EACAE,EACAK,GAEA,IAAIgB,EACJtB,EAAesC,KAAI,CAACjD,EAAMkD,KACxBjB,EAAoBjC,EAAKiD,KAAIE,GAAKlE,EAASmE,cAAcD,KAEzDG,EAAAA,QAAAA,YACEtE,EACA0B,EAHqB,IAKrBuB,EACA,CACEf,MAAOD,EAAQC,OAElB,GAEL,CAEAS,WAAAA,CACE3C,EACAC,EACA0B,EACAD,EACAE,EACAK,GAEA,MAAMgB,EAAoB,GA6C1B,OA5CAtB,EAAesC,KAAI,CAACjD,EAAMkD,KACxB,MAAMM,EAAQxD,EAAK,GAEnBiC,EAAkBS,KAAKzD,EAASmE,cAAcI,IAG9C,MAAMC,EAAmBC,EAAAA,SAAAA,IACvB,mBACA9C,GAGF,IAAI+C,EAAU,GACVC,EAAU,GAEd,GAAIH,EAAkB,CACpB,MAAM,QAAEI,EAAO,KAAEC,GAASL,EAC1BE,EAAUE,EAAU,GACpBD,EAAUE,EAAO,EACnB,CAEA,MAAMC,EAAaC,EAAAA,UAAAA,mBAA2BpD,EAAmB4C,GAC3DS,EAAWD,EAAAA,UAAAA,mBAA2BpD,EAAmB,CAC7DmD,EAAW,GAAKJ,EAChBI,EAAW,GAAKH,IAGlB3B,EAAkBS,KAAKzD,EAASmE,cAAca,IAE9C,MAAMC,EAAY,GAAEhB,IAGpBI,EAAAA,QAAAA,UACEtE,EACA0B,EACAwD,EACAjC,EAAkB,GAClBA,EAAkB,GAClB,CACEf,MAAOD,EAAQC,MACf6B,MAAO9B,EAAQH,WAElB,IAGImB,CACT,CAEAH,aAAAA,CACE9C,EACAC,EACA0B,EACAD,EACAE,EACAK,GAEA,IAAIgB,EA6CJ,OA5CAtB,EAAesC,KAAI,CAACjD,EAAMkD,KACxB,GAAoB,IAAhBlD,EAAKvB,OAGP,OAGF,MAAM0F,EAAqBnE,EAErBoE,EAAWnF,EAASoF,cAK1B,IAAIC,EAHJrC,EAAoBkC,EAAmBlB,KAAIE,GACzClE,EAASmE,cAAcD,KAIvBmB,EADc,IAAZF,GAA8B,KAAZA,EAElBrC,EAAAA,UAAAA,KAAAA,QAAAA,wBAA+C,CAC7CE,EAAkB,GAClBA,EAAkB,GAClBA,EAAkB,GAClBA,EAAkB,KAKpBF,EAAAA,UAAAA,KAAAA,QAAAA,wBAA+CE,GAInD,MAAMoB,EAAW,GAAEH,IACnBI,EAAAA,QAAAA,YACEtE,EACA0B,EACA2C,EACAiB,EAAc,GACdA,EAAc,GACd,CACEpD,MAAOD,EAAQC,MACf6B,MAAO9B,EAAQH,WAElB,IAGImB,CACT,CAEAC,aAAAA,CACElD,EACAC,EACAgD,EACAR,EACArC,EACAiB,GAEA,IADAY,EAAOzC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,CAAC,EAEX,IAAKyD,IAAsB7C,EACzB,OAGF,MAAM,cAAEsB,EAAa,KAAEV,EAAO,CAAC,GAAMZ,GAC/B,MAAEwD,GAAU5C,GACZ,MAAEkB,GAAUD,EAElB,IAAIsD,EAA2BtC,EAES,mBAA7BR,IACT8C,EAA2B9C,EAAyBQ,IAEtD,MAAMuC,EAAYnF,KAAK8C,2BAA2BS,GAC5C6B,EAAsB1C,EAAAA,UAAAA,QAAAA,uBAC1BwC,GAGFnF,EAAWY,KAAK0E,QAAQC,QAAQC,cAAgB3F,EAAS4F,cACvDJ,GAGF,MAAMK,EAAkB7F,EAASmE,cAC/BhE,EAAWY,KAAK0E,QAAQC,QAAQC,eAI5BG,EAAiB1F,KAAK2F,sBAC1B3E,EACAjB,GAGI6F,EAAc3B,EAAAA,QAAAA,kBAClBtE,EACA0B,EARiB,IAUjB8D,EACAM,EACA7C,EACA,CAAC,EACD,IACK8C,EACH7D,WAIIgE,EAAGC,EAAMC,EAAGC,EAAG,MAAEtC,EAAK,OAAEuC,GAAWL,EAE3C7F,EAAWY,KAAK0E,QAAQC,QAAQY,iBAAmB,CACjDC,QAASvG,EAAS4F,cAAc,CAACM,EAAME,IACvCI,SAAUxG,EAAS4F,cAAc,CAACM,EAAOpC,EAAOsC,IAChDK,WAAYzG,EAAS4F,cAAc,CAACM,EAAME,EAAMC,IAChDK,YAAa1G,EAAS4F,cAAc,CAACM,EAAOpC,EAAOsC,EAAMC,IAE7D,EA/YmBlH,EACZmC,SAAW,iBAiZpB,MAAMqF,EAAiB,CACrB,aAAc,MACd,YAAa,MACbC,KAAM,SACNC,OAAQ,GACRC,oBAAqB,IAGvB,SAASpD,EAAkBC,GACzB,MAAMoD,EAAYJ,EAAehD,GAEjC,YAAkBlE,IAAdsH,EACKA,EAGFpD,CACT,CC3aA,MAaA,EAbkB,CAChBqD,eAAgB7H,EAAmBmC,SACnC2F,SAAU,WACVC,gBAAiB,kBACjBC,gBAAiB,kBACjBC,YAAa,cACbC,gBAAiB,kBACjBC,QAAS,UACTC,YAAa,cACbC,eAAgB,iBAChBC,oBAAqB,uBCNjBC,EAAU,KAID,SAASC,EACtBC,EACAC,EACAC,GAGA,MAAMxG,EAAWyG,EAAUf,eAErBgB,EAAkB,CACtB/G,yBAA0B2G,EAAY3G,yBACtCS,eAAgB,CAAC,EACjByB,OAAQyE,EAAYzE,OACpB0E,WAGFD,EAAYK,OAAO7F,SAAQ8F,IACzB,MAAM,YAAE7F,EAAW,YAAE8F,GAAgBD,OAEezI,IAAhDuI,EAAgBtG,eAAeW,KACjC2F,EAAgBtG,eAAeW,GAAe,IAGhD2F,EAAgBtG,eAAeW,GAAaoB,KAwDhD,SACEpB,EACA8F,EACAN,EACAO,GAEA,MAAOC,EAAgB/G,GAAY8G,EAAmBE,MAAM,KAE5D,IAAI5G,EAEJ,OAAQW,GACN,KAAKI,EAAa3D,MAClB,KAAK2D,EAAa1D,WAClB,KAAK0D,EAAazD,SAChB0C,EAAiB,GAEjB,IAAK,IAAIF,EAAI,EAAGA,EAAI2G,EAAY3I,OAAQgC,GAAK,EAAG,CAC9C,MAAM+G,EAAWzF,EAAAA,UAAAA,mBAA6B+E,EAAS,CACrDM,EAAY3G,GACZ2G,EAAY3G,EAAI,KAGlBE,EAAe+B,KAAK8E,EACtB,CAEA,MACF,KAAK9F,EAAaxD,OAAQ,CACxB,MAAMuJ,EAAc,GACpB,IAAK,IAAIhH,EAAI,EAAGA,EAAI2G,EAAY3I,OAAQgC,GAAK,EAAG,CAC9C,MAAM+G,EAAWzF,EAAAA,UAAAA,mBAA6B+E,EAAS,CACrDM,EAAY3G,GACZ2G,EAAY3G,EAAI,KAGlBgH,EAAY/E,KAAK8E,EACnB,CAKA,MAAME,EAASD,EAAY,GACrBE,EAAcF,EAAY,GAE1BG,EAASC,EAAAA,GAAAA,SAAcH,EAAQC,GAE/BG,EAAmBpE,EAAAA,SAAAA,IAAa,mBAAoBoD,GAE1D,IAAKgB,EACH,MAAM,IAAI9F,MAAM,6BAGlB,MAAM,cACJ+F,EAAa,WACbC,GAIEF,EAKEG,EAAiBJ,EAAAA,GAAAA,SACvBA,EAAAA,GAAAA,YAAiBI,EAAgBP,EAAQK,EAAeH,GAExD,MAAMM,EAAeL,EAAAA,GAAAA,SACrBA,EAAAA,GAAAA,YAAiBK,EAAcR,EAAQK,GAAgBH,GAGvD,MAAMO,EAAkBN,EAAAA,GAAAA,SACxBA,EAAAA,GAAAA,YAAiBM,EAAiBT,EAAQM,EAAYJ,GAEtD,MAAMQ,EAAgBP,EAAAA,GAAAA,SACtBA,EAAAA,GAAAA,YAAiBO,EAAeV,EAAQM,GAAaJ,GAErDjH,EAAiB,CACfsH,EACAC,EACAC,EACAC,GAGF,KACF,CACA,KAAK1G,EAAavD,QAAS,CAMzB,MAAMsJ,EAAgC,GACtC,IAAK,IAAIhH,EAAI,EAAGA,EAAI2G,EAAY3I,OAAQgC,GAAK,EAAG,CAC9C,MAAM+G,EAAWzF,EAAAA,UAAAA,mBAA6B+E,EAAS,CACrDM,EAAY3G,GACZ2G,EAAY3G,EAAI,KAGlBgH,EAAY/E,KAAK8E,EACnB,CAEA,MAAMa,EAAiBR,EAAAA,GAAAA,cAAmBJ,EAAY,IAChDa,EAAeT,EAAAA,GAAAA,cAAmBJ,EAAY,IAC9Cc,EAAiBV,EAAAA,GAAAA,cAAmBJ,EAAY,IAChDe,EAAeX,EAAAA,GAAAA,cAAmBJ,EAAY,IAE9CgB,EAAeZ,EAAAA,GAAAA,SACrBA,EAAAA,GAAAA,IAASY,EAAcH,EAAcD,GAGrCR,EAAAA,GAAAA,UAAeY,EAAcA,GAE7B,MAAMC,EAAeb,EAAAA,GAAAA,SACrBA,EAAAA,GAAAA,IAASa,EAAcF,EAAcD,GACrCV,EAAAA,GAAAA,UAAea,EAAcA,GAE7B,MAAMZ,EAAmBpE,EAAAA,SAAAA,IAAa,mBAAoBoD,GAE1D,IAAKgB,EACH,MAAM,IAAI9F,MAAM,mDAGlB,MAAM,cACJ+F,GACqCD,EAGjCa,EAAmBd,EAAAA,GAAAA,cAAmBE,GAEtCa,EAA6BtG,KAAKuG,IACtChB,EAAAA,GAAAA,IAASc,EAAkBF,IAEvBK,EAA6BxG,KAAKuG,IACtChB,EAAAA,GAAAA,IAASc,EAAkBD,IAGvBK,EAA4BzG,KAAKuG,IAAID,GACrCI,EAA4B1G,KAAKuG,IAAIC,GAE3CnI,EAAiB,GACb2B,KAAKuG,IAAIE,EAA4B,GAAKpC,EAC5ChG,EAAiB,CACf8G,EAAY,GACZA,EAAY,GACZA,EAAY,GACZA,EAAY,IAELnF,KAAKuG,IAAIG,EAA4B,GAAKrC,EACnDhG,EAAiB,CACf8G,EAAY,GACZA,EAAY,GACZA,EAAY,GACZA,EAAY,IAGdwB,QAAQC,KAAK,qCAEf,KACF,CACA,QACED,QAAQC,KAAK,2BAA4B5H,GAG7C,OAAOX,CACT,CA1NMwI,CACE7H,EACA8F,EACAN,EACAD,EAAYQ,oBAEf,IAIH,MAAMS,EAAmBpE,EAAAA,SAAAA,IAAa,mBAAoBoD,GAEpDsC,EAAoBhK,EAAAA,WAAAA,MAAAA,uBAGpBiK,EACHxC,EAAYK,OAAO,GAAGoC,uBACrBzC,EAAYK,OAAO,GAAGoC,sBAAsB,IAAIC,uBAClD,EAEIC,EAAiC,CACrC9I,cAAemG,EAAY3G,yBAC3BW,SAAU,CACR4I,oBAAqB3B,EAAiB4B,oBACtCnJ,SAAUA,EACVK,kBAAmBkG,GAErB9G,KAAM,CACJ4C,MAAOiE,EAAYzE,OACnBsC,QAAS,CACPC,QAAS,CAAC,GAEZ1E,YAAa,CACXC,yBAA0B+G,EAAgB/G,yBAC1CS,eAAgBsG,EAAgBtG,gBAElC0I,YAAaA,IAIjBD,EAAkBO,cAAcH,GAEhC3C,EAAY+C,QAAS,EACrB/C,EAAYC,QAAUA,EACtBD,EAAYE,sBAAwBA,EAKpCF,EAAYgD,yBACVhD,EAAYK,OAAO,GAAGoC,sBAAsBO,yBAC9ChD,EAAYwC,YAAcA,SACnBxC,EAAYK,MACrB,C,cCpFA,MAAM4C,EACJC,EAAAA,WAAWC,cAAcC,kBACtBC,yCAECC,EAAiC,CAAC,2BAClCC,EAAqBN,EAAoBM,mBCC/C,MAAQC,WAAYC,GAA4BP,EAAAA,WAAWC,eAErD,SAAEO,EAAUC,iBAAkBC,GAAqBC,EAAAA,QAOnDC,EAAe,CACnB,gCACA,gCACA,gCACA,iCAGIC,EAAmC,qBACnCC,EAAsC,MAEtCC,EAAuBA,CAACC,EAAaC,KACzCA,EAAU3J,SAAQ4J,IAChB,GAAIA,EAAGC,mBAAqBH,EAE1B,MADA9B,QAAQC,KAAK,sCAAuC6B,EAAKE,GACnD,IAAIjJ,MACP,aAAYiJ,EAAGE,qCAAqCJ,IAEzD,GACA,EAGEK,EAA6B,CACjCC,yBAA0B,SAC1BC,aAAc,SACdC,oBAAqB,SACrBC,iBAAkB,SAClBC,kBAAmB,SACnBvL,yBAA0B,SAC1BmH,mBAAoB,SACpBqE,QAAS,SACTC,YAAa,SACbC,oBAAqBtB,EAAwBuB,WAAW9F,qBAGpD+F,EAA0B,CAC9BC,IAAK,MACLC,uBAAwB,CACtB1B,EAAwB2B,uBACxB,SAIEC,EAAoB,CACxBC,cAAe,gBACfC,SAAU,YAGNC,EAAkC,sBASxC,SAASC,EACPtB,EACAuB,GASA,OAPAlN,KAAK2L,UAAUtI,QAAQsI,GACvBwB,EAAAA,MAAMC,mBAAmBpN,KAAK2L,WAI9B3L,KAAKqN,SAAWrN,KAAK2L,UAAU3L,KAAK2L,UAAUvM,OAAS,GACvDY,KAAKsN,UAAW,EACTtN,IACT,CAUA,SAASuN,EACP5B,EACA6B,EACAC,GAGA,IAAK9B,IAAcA,EAAUvM,OAC3B,MAAM,IAAIuD,MAAM,8BAGlBwK,EAAAA,MAAMC,mBAAmBzB,GAIzB,MAAM0B,EAAW1B,EAAUA,EAAUvM,OAAS,IAExC,iBACJyM,EAAgB,kBAChB6B,EAAiB,eACjB5B,EAAc,kBACd6B,EAAiB,aACjBC,EAAY,WACZC,EAAU,wBACVC,EAAuB,YACvBC,GACEV,EAGJ,GAFA5B,EAAqB4B,EAASxB,iBAAkBF,IAG7CmC,GACDA,EAAwBE,YACtBjC,EAA2BC,yBAS7B,OAPAwB,EAAgBS,SAASC,sBAAsBC,KAAK,CAClDC,MAAO,WACPC,QACE,2HACFC,KAAM,UACNC,SAAU,MAEL,GAGT,MAAMC,EAAa,CAEjBC,SAAU,KACV/G,sBAAuByF,EAAAA,MAAMuB,OAC7Bf,oBACAC,eACAC,aACA/B,iBACA4B,oBACA7B,mBACApN,kBAAiB,EACjBsP,cACApC,YACAgD,iBAAkB,KAClBC,aAAc,KACdC,qBAAqB,EACrBvB,UAAU,EACVhC,eACA+B,WACAJ,gBAKF,OAFAuB,EAAWM,KAAO,IAKpB,SAAeN,EAAYhB,EAAiBC,GAC1C,MAAM,kBAAEP,EAAiB,mBAAE6B,GAAuBvB,EAAgBS,SAC5De,EAAcvB,EAAiBwB,iBAC/BC,EAAaF,EAAY,IAEzB,gBAAEG,GAAoBX,EAAWnB,SAEvCmB,EAAWG,iBAieb,SAAkCS,GAChC,MAMMhD,EAAoBiD,EANLD,EAAwCE,MAC3DC,GACEA,EAAKzB,wBAAwBE,YAC7BjC,EAA2BE,eAIhBkD,iBACbG,MACAC,GACEA,EAAKzB,wBAAwBE,YAC7BjC,EAA2BK,oBAGzBuC,EAAmB,GAiBzB,OAfAU,EAAoBjD,EAAkB+C,iBAAiBnN,SAAQuN,IAC7D,MAAM,sBAAEtF,GAA0BsF,EAClC,GAAKtF,EACL,IAAK,MAAMuF,KAAOH,EAAoBpF,GACpC,GAAIuF,EAAIC,sBAAuB,CAC7B,MAAM,sBAAEA,EAAqB,yBAAEjF,GAA6BgF,EAE5Db,EAAiBtL,KAAK,CACpBoM,wBACAjF,4BAEJ,CACF,IAGKmE,CACT,CAlgBgCe,CAAyBP,GACvDX,EAAWI,aAwKb,SAA0BQ,GACxB,MAAMlD,EAAsBkD,EAAwCE,MAClEC,GACEA,EAAKzB,wBAAwBE,YAC7BjC,EAA2BG,sBAWzByD,EAwBR,SACEC,GAEA,MAAMD,EAAoD,CAAC,EA8C3D,OA5CAC,EAAkB5N,SAAQmK,IACxB,MAAMgD,EAAkBE,EACtBlD,EAAiBgD,iBAGbU,EAA+BV,EAAgBG,MACnDC,GACEA,EAAKzB,wBAAwBE,YAC7BjC,EAA2BlL,2BAG1BgP,GACHjG,QAAQC,KACN,kEAIJ,MAAMiG,EAA2BD,EAA6BE,SAKtD1Q,IAFNsQ,EACEG,GAIFH,EACEG,GACE,IAAIX,GAIRA,EAAgBnN,SAAQuN,IAEpBA,EAAKzB,wBAAwBE,YAC7BjC,EAA2BlL,0BAE3B8O,EACEG,GACAzM,KAAKkM,EACT,GAEJ,IAGKI,CACT,CA1E4DK,CARhCX,EACxBnD,EAAoBiD,iBACpB1O,QACA8O,GACEA,EAAKzB,wBAAwBE,YAC7BjC,EAA2BI,oBAOzByC,EAAe,GAiBrB,OAfA9M,OAAOC,KAAK4N,GAAmD3N,SAC7D8N,IACE,MAKMtI,EA+DZ,SAA6ByI,GAC3B,GACEA,EAAsBC,MACpBC,GAA6B,WAApBA,EAAMC,WAA8C,aAApBD,EAAMC,YAGjD,OAMJ,SAAoCH,GAIlC,MAAMI,EAAcJ,EAAsBX,MACxCa,GAA6B,WAApBA,EAAMC,YAGXE,EAAoBL,EAAsBX,MAC9Ca,GAA6B,WAApBA,EAAMC,YAGXG,EAAgCN,EAAsBX,MAC1DC,GACEA,EAAKzB,wBAAwBE,YAC7BjC,EAA2B/D,qBAG/B,IAAKqI,EAIH,YAHAzG,QAAQC,KACL,qBAAoBwG,EAAYD,2DAKrC,MAAMI,EAAkBP,EAAsBxP,QAC5C0P,GAA6B,QAApBA,EAAMC,YAGX5I,EAAc,CAClB+C,QAAQ,EACRxH,OAAQ,GACR8E,OAAQ,CAAC4I,EAA+BJ,IACxCxP,yBAA0ByP,EAAkBP,IAC5C/H,mBAAoBuI,EAA8BG,WAgBpD,OAbAF,EAAgBxO,SAAQuN,IACtB,MAAM,wBAAEzB,EAAuB,sBAAE6C,GAA0BpB,EAEvDoB,GACFnJ,EAAYzE,OAAOM,KACjBuN,EACE9C,EACA6C,GAGN,IAGKnJ,CACT,CAzDWqJ,CAA2BZ,GAGpC,OAwDF,SAAoDA,GAClD,MAAMO,EAAkBP,EAAsBxP,QAC5C0P,GAA6B,QAApBA,EAAMC,YAGXE,EAAoBL,EAAsBX,MAC9Ca,GAA6B,WAApBA,EAAMC,YAGXG,EAAgCN,EAAsBX,MAC1DC,GACEA,EAAKzB,wBAAwBE,YAC7BjC,EAA2B/D,qBAGzB8I,EAAUb,EAAsBX,MACpCC,GACEA,EAAKzB,wBAAwBE,YAC7BjC,EAA2BM,UAGzB0E,EAAed,EAAsBxP,QACzC8O,GACEA,EAAKzB,wBAAwBlB,yBAC3BH,EAAwBC,KAC1B6C,EAAKzB,wBAAwBE,YAC3BjC,EAA2BO,cAG3B9E,EAAc,CAClB+C,QAAQ,EACRxH,OAAQ,GACR8E,OAAQ,GACRhH,yBAA0ByP,EAAkBP,IAC5C/H,mBAAoBuI,EAA8BG,WAIlDI,GACArE,EAAwBE,uBAAuBjM,SAC7CoQ,EAAQE,oBAAoBpE,yBAE9BkE,EAAQE,oBAAoBhD,YAC1BjC,EAA2BQ,qBAE7B/E,EAAYzE,OAAOM,KAAK,CACtBE,MAAOyJ,EACPxJ,MAAOsN,EAAQE,oBAAoBC,cAKvC,GAAIF,EAAa3R,OAAQ,CACvB,MAAM8R,EAAiCH,EAAazB,MAClDhD,GACEG,EAAwBE,uBAAuBjM,SAC7C4L,EAAY0E,oBAAoBpE,yBAElCN,EAAY0E,oBAAoBhD,YAC9BjC,EAA2BQ,sBAG7B2E,GACF1J,EAAYzE,OAAOM,KAAK,CACtBE,MAAOyJ,EACPxJ,MAAO0N,EAA+BF,oBAAoBC,aAGhE,CAmCA,OAjCAT,EAAgBxO,SAAQuN,IACtB,MAAM,wBACJzB,EAAuB,gBACvBqB,EAAe,sBACfwB,GACEpB,GAEE,UAAEa,GAAcjB,EAEtB,GAAmB,YAAdiB,EAKH,YAJAxG,QAAQC,KACL,WAAUuG,mDAMf,MAAMvI,EAAS4I,EAA+BtB,GAE1CtH,GACFL,EAAYK,OAAOxE,KAAKwE,GAGtB8I,GACFnJ,EAAYzE,OAAOM,KACjBuN,EACE9C,EACA6C,GAGN,IAGKnJ,CACT,CAhKS2J,CAA2ClB,EACpD,CAzE0BmB,CAJlBzB,EACEG,IAKAtI,GACFoH,EAAavL,KAAKmE,EACpB,IAIGoH,CACT,CA7M4ByC,CAAiBlC,GAE3C,MAAMmC,EAAWvC,EAAmBwC,kBAClChG,EACAC,GAGFgD,EAAWgD,YAAa,EACxBhD,EAAWiD,eDrKE,SAAwBjD,EAAY8C,GACjD,IAAKA,IAAaA,EAASlS,OACzB,OAAO,EAGT,MAAMsS,EAAqBJ,EAAS1N,KAAI+N,GAAKA,EAAEC,kBACzC,aAAEhD,GAAiBJ,EAEnBqD,EAAc/P,OAAOC,KAAK0I,GAAqBhK,QACnDqR,GAE8C,mBADrCrH,EAAoBqH,GACxBC,uCAGDC,EAAW,GAEjBH,EAAY7P,SAAQiQ,IACdP,EAAmBhR,SAASuR,IAG9BD,EAAS3O,KAAKoH,EAAoBwH,GACpC,IAGF,IAAK,IAAI7Q,EAAI,EAAGA,EAAIwN,EAAaxP,OAAQgC,IAAK,CAC5C,MAAM,mBAAE4G,GAAuB4G,EAAaxN,IAAM,CAAC,EAcnD,GAbmB4Q,EAAS9B,MAAKgC,IAC/B,IAAKjK,EAAgB/G,GAAY8G,EAAmBE,MAAM,KACtD4C,EAA+BpK,SAASuH,KAC1CA,EAAiB8C,GAGnB,MAAMoH,EAA4B,GAAElK,KAAkB/G,IAEtD,OAAOgR,EAAQH,qCACbI,EACD,IAID,OAAO,EAETvI,QAAQwI,IACN,kCACApK,EACA4G,EAAaxN,GAEjB,CAGA,OADAwI,QAAQwI,IAAI,kDACL,CACT,CCkH8BX,CAAejD,EAAY8C,GACvD9C,EAAWlB,UAAW,EAGtBJ,EAAkBmF,kBAAkBrQ,SAAQsQ,IAC1CC,EACE/D,EACA8D,EACApD,EACD,IAIHhC,EAAkBsF,UAChBtF,EAAkBuF,OAAOC,oBACzB/R,IACE,MAAM,iBAAEgS,GAAqBhS,EAG7BgS,EAAiB3Q,SAAQ4Q,IACvBL,EACE/D,EACAoE,EACA1D,EACD,GACD,GAGR,CAjD0B2D,CAAMrE,EAAYhB,EAAiBC,GAEpD,CAACe,EACV,CAgDA,SAAS+D,EACPO,EACAF,EACA1D,GAEA,IAAI6D,EAAuBD,EAAalE,aAAanO,QACnD+G,IAAsC,IAAvBA,EAAY+C,SAG7B,GAAoC,IAAhCwI,EAAqB3T,OAEvB,OAGF,IAAKwT,aAAyB1H,EAE5B,OAGF,MAAM,aAAEI,EAAY,OAAE0H,GAAWJ,EASjC,GANAG,EAAuBA,EAAqBtS,QAAO+G,GACjDA,EAAYK,OAAOqI,MAAKpI,GACtBwD,EAAa5K,SAASoH,EAAMmC,sBAAsBwF,2BAIlB,IAAhCsD,EAAqB3T,OAEvB,OAGF,MAAM6T,EAAkB,GAExBF,EAAqB/Q,SAAQwF,IAC3B,MAAM,OAAEK,GAAWL,EAEnBK,EAAO7F,SAAQ8F,IACb,MAAMgE,EACJhE,EAAMmC,sBAAsBO,yBAEzByI,EAAgBvS,SAASoL,IAC5BmH,EAAgB5P,KAAKyI,EACvB,GACA,IAGJ,MAAMoH,EAAwBhE,EAAWiE,yBACvCP,GAGF,IAAK,MAAMnL,KAAWyL,EAAuB,CAC3C,IAAKH,EAAqB3T,OAExB,OAGF,MAAM,eAAE0M,EAAc,YAAE9B,GAAgBoB,EAAiBgI,mBACvD3L,GAGF,GAAIwL,EAAgBvS,SAASoL,GAC3B,IAAK,IAAIuH,EAAIN,EAAqB3T,OAAS,EAAGiU,GAAK,EAAGA,IAAK,CACzD,MAAM7L,EAAcuL,EAAqBM,GAEvCC,EACE9L,EACAsE,EACA9B,KAGFzC,EACEC,EACAC,EACAmL,EAAclL,uBAGhBqL,EAAqBQ,OAAOF,EAAG,GAEnC,CAEJ,CACF,CAEA,SAASC,EACP9L,EACAsE,EACA9B,GAEA,MAAM,OAAEnC,GAAWL,EAIb0C,EACH1C,EAAYK,OAAO,GAAGoC,uBACrBzC,EAAYK,OAAO,GAAGoC,sBAAsB,IAAIC,uBAClD,EAEF,GAAIF,GAAewJ,OAAOxJ,KAAiBwJ,OAAOtJ,GAChD,OAAO,EAET,IAAK,IAAImJ,EAAI,EAAGA,EAAIxL,EAAOzI,OAAQiU,IAAK,CACtC,MAAMvL,EAAQD,EAAOwL,IACf,yBAAE7I,GAA6B1C,EAAMmC,sBAE3C,GAAIO,IAA6BsB,EAC/B,OAAO,CAEX,CACF,CA0RA,SAAS2E,EAA+BlB,GACtC,MAAM,UAAEa,EAAS,iBAAEqD,EAAgB,YAAExR,EAAW,YAAE8F,GAAgBwH,EAElE,GAEIkE,GAAoB5G,EAAkBC,eACtC2G,GAAoB5G,EAAkBE,SAOxC,YAJAnD,QAAQC,KACL,wBAAuB4J,yGAM5B,MAAM5L,EAAS,CAAEuI,YAAWnO,cAAa8F,eAGzC,GAAkB,WAAdqI,EAAwB,CAC1B,MAAM,sBAAEnG,GAA0BsF,EAAKJ,gBAEvCtH,EAAOoC,sBAAwBA,CACjC,MAAO,GAAkB,aAAdmG,EAA0B,CACnC,MAAM,mCAAEsD,GAAuCnE,EAAKJ,gBAEpDtH,EAAO6L,mCAAqCA,CAC9C,CAEA,OAAO7L,CACT,CAEA,SAAS+I,EACP9C,EACA6C,GAEA,MAAM,YAAEM,GAAgBnD,GAClB,aAAE6F,EAAY,6BAAEC,GAAiCjD,GACjD,UAAE3C,GAAc4F,EAMtB,MAAO,CACLrQ,MAAO0N,EACPzN,MAAQ,GANmBmQ,EACzBH,OAAOG,GAAcE,QAAQ,GAC7B,MAIgC7F,IAEtC,CAqCA,SAASqB,EAAoByE,GAC3B,OAAKA,EACEC,MAAMC,QAAQF,GAAYA,EAAW,CAACA,GADvB,EAExB,CAEA,QAlXA,SAAiCG,GAAwC,IAAvC,gBAAEzG,EAAe,iBAAEC,GAAkBwG,EASrE,MAAO,CACL,CACEC,KAAM1V,EACN8M,eACA6I,yBAZ6BxI,GACxB4B,EACL5B,EACA6B,EACAC,IAWN,ECjVM2G,EAA6C,CACjD9V,GAAI,WAIJ+V,6BAA6B,EAC7BH,KAAM,gBAENI,sBAAuB,GACvBC,aAAc,CAAC,WAIfC,yBAA0B,EAG1BC,gBAAiB,CACfC,gBAAiB,CACfC,aAAc,QACd1T,YAAa,UACb2T,oBAAoB,GAEtBC,YAAa,CACX,CACEvW,GAAI,iBACJwW,yBAA0B,KAIhCC,oBAAqB,CACnBC,eAAgB,CACdC,oBAAqB,CACnB,CACEC,UAAW,WACXC,WAAY,CACVC,OAAQ,UAMlBC,OAAQ,CACN,CACEnB,KAAM,gBACNoB,kBAAmB,CACjBC,WAAY,OACZC,WAAY,CACV/Q,KAAM,EACND,QAAS,IAGbiR,UAAW,CACT,CACEf,gBAAiB,CAAEE,oBAAoB,GACvCC,YAAa,CACX,CACEvW,GAAI,wB,eCxDlB,MAAM,IAAE8T,GAAQsD,EAAAA,QA+GhB,QA7GA,SACE9N,EACA+N,GAEA,MAAMC,EAAoB,CAAC,EAE3B,SAASC,EAAuB9V,EAAY+V,GAC1C,IAAK/V,EAAWyB,UAAUD,kBAIxB,YAHA6Q,EAAIvI,KACD,4CAA2CiM,KAAY/V,EAAWzB,MAKvE,MAAMmJ,EAAU1H,EAAWyB,SAASD,kBAE/BqU,EAAkBnO,KACrBmO,EAAkBnO,GAAW,CAAC,GAGhC,MAAMsO,EAA2BH,EAAkBnO,GAE9CsO,EAAyBD,KAC5BC,EAAyBD,GAAY,CACnCnV,KAAM,KAIV,MAAMqV,EAAmBpO,EAAgB0H,MACvC2G,GAAMA,EAAGvK,MAAQ3L,EAAWsB,gBAExB6U,EAAWH,EAAyBD,GAAUnV,KAEpD,IAAI,QAAEmQ,GAAYkF,EAClB,MAAMjF,EAAe,GAIjBiF,EAAiBzS,QACfoS,EAAuBjV,SAASoV,GAClChF,EAAU,CACR9C,UAAW,sBACXpB,uBAAwB,gBACxBqE,YAAa+E,EAAiBzS,OAGhCwN,EAAa1N,KAAK,CAChB2K,UAAW,sBACXpB,uBAAwB,gBACxBqE,YAAa+E,EAAiBzS,SAKhCyS,EAAiBjF,cACnBA,EAAa1N,QAAQ2S,EAAiBjF,cAGxC,MAAMvJ,EAAc1F,OAAOqU,OAAO,CAAC,EAAGpW,EAAY,CAChD+Q,UACAC,iBAGFmF,EAAS7S,KAAKmE,EAChB,CAEA,MACM4O,EADYxO,EAAgBhE,KAAIqS,GAAMA,EAAGvK,MACxB2K,QAEjBtM,EAAoBhK,EAAAA,WAAAA,MAAAA,uBACpBuW,EAAoBvM,EAAkBwM,uBAE5C,IAAK,IAAInV,EAAI,EAAGA,EAAIkV,EAAkBlX,OAAQgC,IAAK,CACjD,MAAMoV,EAAmBF,EAAkBlV,GAErCqV,EAA8B1M,EAAkB2M,eACpDF,GAGIG,EAAY7U,OAAOC,KAAK0U,GAE9B,IAAK,IAAIpD,EAAI,EAAGA,EAAIsD,EAAUvX,OAAQiU,IAAK,CACzC,MAAMyC,EAAWa,EAAUtD,GAErBvT,EAAc2W,EAA4BX,GAEhD,GAAIhW,EACF,IAAK,IAAI8W,EAAI,EAAGA,EAAI9W,EAAYV,OAAQwX,IAAK,CAC3C,MAAM7W,EAAaD,EAAY8W,GACzBC,EAAWT,EAAKU,WACpBpL,GAAOA,IAAQ3L,EAAWsB,gBAG5B,IAAkB,IAAdwV,IACFhB,EAAuB9V,EAAY+V,GACnCM,EAAK7C,OAAOsD,EAAU,IAEjBT,EAAKhX,QACR,OAAOwW,CAGb,CAEJ,CACF,CAEA,OAAOA,CACT,GCvGM,kBAAEhL,GAAsBF,EAAAA,WAAWC,eACjCyH,IAAGA,GAAKsD,EAAAA,QAyJhB,EApHuBzB,IAAQ,MAALA,EACxB,MAAM8C,EAAU,CASdC,eAAgBC,IAIV,IAJW,gBACfrP,EAAe,uBACf+N,EAAsB,QACtB/T,EAAU,CAAC,GACZqV,EACC,MAAMC,EAAYH,EAAQI,eACxBvP,EACA+N,EACA/T,GAEIwV,EAAaC,EAAAA,QAAAA,KAAWC,cAAcJ,GAG5C,IAAIK,EAAYC,IAAIC,gBAAgBL,GACpCM,OAAOC,SAASxB,OAAOoB,EAAU,EAYnCK,kBAAmBC,UAKb,IALoB,gBACxBjQ,EAAe,WACfsH,EAAU,uBACVyG,EAAsB,QACtB/T,EAAU,CAAC,GACZkW,EAKC,GAFA1F,EAAI2F,KAAK,gCAEJ7I,IAAeA,EAAW8I,QAAU9I,EAAW8I,MAAMC,MAIxD,OAHA7F,EAAI8F,MACF,gEAEKC,QAAQC,OAAO,CAAC,GAGzB,IACE,MAAMC,EAjFU,SACtBzQ,EACA+N,GAEG,IADH/T,EAAOzC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,CAAC,EAEX,MAAMyW,EAAoB0C,EACxB1Q,EACA+N,GAGI4C,EAAS3N,EAAkBuM,eAC/BvB,EACAvR,EAAAA,SACA3B,EAAAA,UAAAA,mBACAd,IAGI,QAAE4W,GAAYD,EAOpB,YAH4C,IAAjCC,EAAQC,uBACjBD,EAAQC,qBAAuB,cAE1BD,CACT,CAwDkCE,CACxB9Q,EACA+N,EACA/T,IAGI,iBAAEiK,EAAgB,gBAAEsD,GAAoBkJ,EAI9C,IAAKlJ,IAAkB,GAAGA,iBAAiB/P,OAKzC,MAJAwK,QAAQwI,IACN,4CACAiG,GAEI,IAAI1V,MAAM,8BAclB,aAXMuM,EAAW8I,MAAMC,MAAMI,GAEzBxM,GACFqD,EAAWyJ,2BAA2B9M,GAMxC+M,EAAAA,mBAAmB3L,aAAa,CAACoL,IAAoB,GAE9CA,CACT,CAAE,MAAOH,GAKP,MAJAtO,QAAQC,KAAKqO,GACb9F,EAAI8F,MACD,kDAAiDA,EAAM7J,WAEpD,IAAI1L,MACRuV,EAAM7J,SAAW,uCAErB,IAIEwK,EAAc,CAClB7B,eAAgB,CACd8B,UAAW/B,EAAQC,eACnB+B,cAAe,GACfnX,QAAS,CAAC,GAEZgW,kBAAmB,CACjBkB,UAAW/B,EAAQa,kBACnBmB,cAAe,GACfnX,QAAS,CAAC,IAId,MAAO,CACLmV,UACA8B,cACAG,eAAgB,gCACjB,EC7JY,SAASC,EACtB/E,EACAgF,EACA5Z,GAEA,MAAM6Z,UAAsBD,GAAtBC,EACGjY,SAAWgT,GAEpBkF,EAAAA,EAAAA,SAAQD,EACV,C,eCTA,MAAMjO,EAAWG,EAAAA,QAAQH,SAEnBmO,EAAeA,CAAC7R,EAAa0F,KACjC,MAAM,sBAAExF,EAAuB8C,yBAA0B8O,GACvD9R,EACI+R,EAAuBrM,EAAkBsM,mBAC7C9R,GAEF,GAAK6R,EAAqBvG,OAC1B,OAAOuG,EAAqBvG,OAAO1D,MAAK1D,GAAMA,EAAGE,iBAAmBwN,GAAO,EAOvEG,EAA0BA,CAC9BvM,EACAsB,KAEA,MAAM7C,EAAY,GACZ+N,EAAe,CAAC,EACtB,IAAK,MAAMlS,KAAegH,EAAWI,aAAc,CACjD,MAAM,QAAEnH,GAAYD,EACpB,IAAKC,EAAS,SACd,GAAIiS,EAAajS,GAAU,SAE3B,MAAM4F,EAAWgM,EAAa7R,EAAa0F,GACtCG,GAKLqM,EAAajS,GAAW4F,EACxB1B,EAAUtI,KAAKgK,IALbzD,QAAQwI,IAAI,cAAe5K,EAAa,yBAM5C,CACA,OAAOmE,CAAS,EAmDlB,GAxCwCgO,CAACzM,EAAmBsB,KAC1D,MAAM7C,EAAY8N,EAAwBvM,EAAmBsB,GAWvDoL,EAAW,IAAI1O,EAASS,GACxB0B,EAAW1B,EAAU,GAwB3B,OAvBAiO,EAASC,cAAc,CACrBnS,sBAAuBkS,EAASlO,IAChCmC,WAAYR,EAASQ,WACrBiM,WAAYzM,EAASyM,WACrBpM,kBAAmBkM,EAASlO,IAC5BG,iBAAkBwB,EAASxB,iBAC3B+B,aAAcP,EAASO,cAAgB,EACvCG,YAAaV,EAASU,YACtBJ,kBAAoB,GAAEa,EAAWb,wBAAwBa,EAAWnB,SAASO,eAC7Ea,SAAU,KACVsL,cAAc,EACdC,eAAgBrO,EAAUvM,OAC1BX,kBAAoB,sDACpBwb,mBAAmB,EAEnBC,kBAAkB,EAClBC,cAAc,EACdC,6BAA6B,EAC7BC,gBA7BsB,WACtBra,KAAKgT,OAAOO,OACV,EACAvT,KAAKgT,OAAO5T,UACTqa,EAAwBvM,EAAmBsB,IAEhDxO,KAAKga,eAAiBha,KAAKgT,OAAO5T,MACpC,IAyBA8N,EAAkBoN,eAAeV,GAE1BA,CAAQ,E,uOCzEjB,MAAMW,GAAYC,EAAAA,MAAW,IACpB,iCAKHC,GAA4BC,GAE9BF,EAAAA,cAACA,EAAAA,SAAc,CAACG,SAAUH,EAAAA,cAAA,WAAK,eAC7BA,EAAAA,cAACD,GAAcG,IAmDrB,GA3CyB,CAIvBpc,GAAE,EACFsc,YCjCa,SAAoB3G,GAAsB,IAArB,gBAAEzG,GAAiByG,EACrD,MAAM,kBAAE/G,GAAsBM,EAAgBS,SAGxB,IAFEf,EAAkB2N,qBAEAC,UAAUra,QAClDsa,GAAMA,EAAGtc,oBAAsBA,IAGnBuD,SAAQ+Y,IAEpBA,EAAGvJ,YAAa,CAAK,GAEzB,EDuBEwJ,gBEjBa,SAAa/G,GAEe,IAFd,cAC3B3U,EAAgB,CAAC,GACgB2U,GACjCmF,EAAAA,EAAAA,SAAQra,GACRka,EAAgBtR,EAAUd,SAAUoU,EAAAA,YACpChC,EAAgBtR,EAAUb,gBAAiBoU,EAAAA,mBAC3CjC,EAAgBtR,EAAUZ,gBAAiBoU,EAAAA,mBAC3ClC,EAAgBtR,EAAUX,YAAaoU,EAAAA,eACvCnC,EAAgBtR,EAAUV,gBAAiBoU,EAAAA,mBAC3CpC,EAAgBtR,EAAUT,QAASoU,EAAAA,WAEnCrC,EAAgBtR,EAAUR,YAAaoU,EAAAA,eAGvCtC,EAAgBtR,EAAUN,oBAAqBmU,EAAAA,uBAG/C,MAAMC,EAAa,CACjB9Z,SAAU,OAEZ5B,EAAAA,WAAAA,OAAAA,MAAwB2b,uBAAuB,cAAe,CAC5D7U,SAAU4U,EACV3U,gBAAiB2U,EACjB1U,gBAAiB0U,EACjBzU,YAAayU,EACbxU,gBAAiBwU,EACjBtU,YAAasU,EACbvU,QAASuU,EACTpU,oBAAqBoU,EACrBE,OAAQ,CAAC,GAEb,EFNEC,iBAAAA,CAAiB3H,GAAwC,IAAvC,gBAAEzG,EAAe,iBAAEC,GAAkBwG,EAWrD,MAAO,CAAC,CAAEC,KAAM,WAAY2H,UAVcnB,GAEtCF,EAAAA,cAACC,GAAyBqB,GAAA,CACxBtO,gBAAiBA,EACjBC,iBAAkBA,GACdiN,KAMZ,EACAqB,kBAAiB,EACjBC,yBAAwB,EAExBC,gBAAAA,CAAgBhF,GAAsB,IAArB,gBAAEzJ,GAAiByJ,EAClC,MAAO,CACL,CACE/C,KAAM,QACNgI,QAAS,CACPvU,UAASA,IAIjB,E,4DGpEF,MAAMwU,EAAQ,CACZtb,yBAA0B,KAC1Bub,gCAAiC,CAAC,GAWpC,SAASC,EACPxc,EACAS,GAEA,IADAD,EAAWlB,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,EAEd,MAAMO,GAAiB4c,EAAAA,EAAAA,mBAAkBzc,IACnC,SAAED,GAAaF,EAErByc,EAAMC,gCAAgCxc,EAAStB,IAAM,CACnDgC,4BACAD,cAEJ,CAqBA,SAASD,EAAuCP,GAC9C,MAAMH,GAAiB4c,EAAAA,EAAAA,mBAAkBzc,IACnC,SAAED,GAAaF,EAErB,OAAIyc,EAAMC,gCAAgCxc,EAAStB,IAC1C6d,EAAMC,gCAAgCxc,EAAStB,IAGjD,CAAEgC,0BAA2B,GACtC,C,2ECpDA,MAAM,KAAEoO,GAASgH,EAAAA,QAAAA,OACX,kBAAE9K,EAAiB,mBAAEG,GAAuBL,EAAAA,WAAWC,cAEvDY,EAAmC,qBACnCC,EAAsC,MAEtCV,EAAiC,CAAC,2BAElCyR,EAAcA,CAACC,EAAcC,KACjC,IAAKA,GAAwC,kBAAhCA,EAAK7P,uBAA4C,OAC9D,MAAM4C,EAAO,GAAEiN,EAAK7P,0BAA0B6P,EAAKzO,YAEnD,MADY,IAAKwO,EAAahN,GAAMA,SAAQiN,EAAMC,KAAMD,EAAKxL,YACnD,EAGN0L,EAAeA,CAACH,EAAcI,KAClC,IAAKA,IAAUA,EAAMxd,OAAQ,OAC7B,MAAMyd,EAAM,GAEZ,IAAK,IAAIzb,EAAI,EAAGA,EAAIwb,EAAMxd,OAAQgC,IAAK,CAErC,MAAM0b,EAAOP,EAAYC,EAAcI,EAAMxb,GAAG,IAAMwb,EAAMxb,IACxD0b,GAAMD,EAAIxZ,KAAKyZ,EACrB,CACA,OAAQD,EAAIzd,QAAUyd,QAAQxd,CAAS,EAO1B,SAAS0d,EAAuB9I,EAE7CvM,GACA,IAFA,gBAAE8F,EAAe,iBAAEC,GAAkBwG,EAGrC,MAAM/E,EAAazB,EAAiBuP,sBAAsB,IACpD,mBACJjO,EAAkB,kBAClB7B,EAAiB,qBACjB+P,GACEzP,EAAgBS,SAEduO,EAAeS,EAAqBC,iBACxC,eACA,CAAC,GAEG1O,EAAatB,EAAkBsM,mBACnC9R,GAII4J,EAAWvC,EAAmBwC,kBAClChG,EACAC,GAGF,IAAK8F,IAAaA,EAASlS,OACzB,MAAM,IAAIuD,MACP,mGAIL,MAAM0K,EAAWuL,EAAAA,mBAAmBuE,YAClC3O,EAAW3C,iBACX2C,EAAWd,kBACXc,EAAW1C,gBAGPsR,EAA0B,CAAC,EAC3BC,EAAuB,CAAC,EAE9B7O,EAAWI,aAAa5M,SAAQwF,IAC9B,MAAM,yBAAEgD,EAAwB,QAAE/C,EAAO,YAAEuC,GAAgBxC,EAEtD4V,EAAwB5S,KAC3B4S,EAAwB5S,GAA4B/C,EACpD4V,EAAqB7S,GAA4B,IAE9C6S,EAAqB7S,GAA0BR,KAClDqT,EAAqB7S,GAA0BR,GAAevC,EAChE,IAGF,MAAM6V,EAoJR,SAA2B9E,GACzB,MAAM+E,EAAS,uBACTC,EAAQ,oBACRC,EAAsB,sBAGtBC,EAA4BC,EAAQnF,EAAQrJ,iBAAiBG,KACjEsO,EAAkBL,IAIdM,EAAoBF,EACxBD,EAA0BvO,iBAC1B1O,OAAOmd,EAAkBJ,IAGrB5V,EAAkB,CAAC,EAEnBkW,EACJlT,EAAkBC,yCAEdkT,EAAwB,GA6B9B,OA3BAjc,OAAOC,KAAK+b,GAAwB9b,SAAQiQ,IAC1C8L,EAAsB1a,KAAKya,EAAuB7L,IAClDrK,EAAgBqK,GAAO,EAAE,IAG3B4L,EAAkB7b,SAAQ,CAACgc,EAAkBna,KAC3C,MAIMoa,EAJkCN,EACtCK,EAAiB7O,iBAG6CG,MAC9D4O,GACEA,EAAYpQ,wBAAwBmD,cAAgBwM,IAGlDzV,EAAqBiW,EAAwBvN,UAEnD,IAAKzI,EAAgB/G,GAAY8G,EAAmBE,MAAM,KACtD4C,EAA+BpK,SAASuH,KAC1CA,EAAiB8C,GAGnB,MAAMoH,EAA4B,GAAElK,KAAkB/G,IAEtD+c,EAAwBvN,UAAYyB,CAAwB,IAGvDqG,CACT,CAvMuB2F,CAAkB9Q,GAGjC+Q,EAAoCxT,EAAkByT,kBAC1Df,EAKAF,EACA1a,EAAAA,UAAAA,mBACA2B,EAAAA,UAIIqN,EAAqBJ,EAAS1N,KAAI+N,GAAKA,EAAEC,iBACzC0M,EAA6B,CAAC,EAEpCxc,OAAOC,KAAKqc,GAAmCpc,SAAQiQ,IACjDP,EAAmBhR,SAASuR,KAC9BqM,EAA2BrM,GAAOmM,EAAkCnM,GACtE,IAIF,MAAMsM,EAAW,GAwBjB,IAAIC,EArBJ1c,OAAOC,KAAKuc,GAA4Btc,SAAQ4P,IAE5C0M,EAA2B1M,GAEH5P,SAAQkU,IAKhC,MAAMlM,EACHkM,EAASnW,WAAWY,MAAQuV,EAASnW,WAAWY,KAAKqJ,aAAgB,EAClEvC,EACJ4V,EAAqBnH,EAASuI,gBAAgBzU,IAC9CoT,EAAwBlH,EAASuI,gBAE9BF,EAAS7d,SAAS+G,IACrB8W,EAASlb,KAAKoE,EAChB,GACA,IAIJ,MAAMiX,EAAqB,GAE3B,IAAK,IAAItd,EAAI,EAAGA,EAAImd,EAASnf,OAAQgC,IAAK,CACxC,MAAMqG,EAAU8W,EAASnd,IACnB,kBAAEsM,EAAiB,iBAAE7B,GAAqBxH,EAAAA,SAAAA,IAC9C,WACAoD,GAGGiX,EAAmBhe,SAASgN,IAC/BgR,EAAmBrb,KAAKqK,GAGrB8Q,EAEMA,IAA2B3S,GACpCjC,QAAQC,KACN,oEAHF2U,EAAyB3S,CAM7B,CAwEA,OAtEA/J,OAAOC,KAAKuc,GAA4Btc,SAAQ4P,IAE5C0M,EAA2B1M,GAEH5P,SAAQkU,IAKhC,MAAMlM,EACHkM,EAASnW,WAAWY,MAAQuV,EAASnW,WAAWY,KAAKqJ,aAAgB,EAClEvC,EACJ4V,EAAqBnH,EAASuI,gBAAgBzU,IAC9CoT,EAAwBlH,EAASuI,gBAEnCvI,EAASxK,IAAMgD,IAEf,MAAMrB,EAAWhJ,EAAAA,SAAAA,IAAa,WAAYoD,IACpC,oBACJ2C,GAIEiD,EAEEtN,EAAa,CACjBsB,cAAe6U,EAASnW,WAAWsB,cACnCV,KAAMuV,EAASnW,WAAWY,KAC1Ba,SAAU,CACRN,SAAU0Q,EACVrQ,kBAAmBkG,EACnB2C,wBAIEuU,EAAS5P,EAAmB6P,UAChCrT,EACAC,GAEFzL,EAAWY,KAAK4C,MC/LP,SAA2C2S,GACxD,MAAM,aAAEnF,EAAe,GAAE,QAAED,GAAYoF,EAEvC,IAAI2I,EAAgB9N,EAAazB,MAC/BwP,GAAuB,wBAAjBA,EAAG9Q,YAGX,OAAI6Q,EACKA,EAAc5N,YAGnBH,GAAiC,wBAAtBA,EAAQ9C,UACd8C,EAAQG,iBADjB,CAGF,CDiL8B8N,CAAkC7I,GAC1DnW,EAAWY,KAAKmQ,QAAUyL,EACxBC,EACAtG,EAASpF,UAAU,IAErB/Q,EAAWY,KAAKoQ,aAAe4L,EAC7BH,EACAtG,EAASnF,cAEXhR,EAAWY,KAAKmc,KAAO/c,EAAWY,KAAKoQ,eAAe,GAEtD,MAAMiO,EAAkB1N,EAAShC,MAC/BqC,GAAKA,EAAEC,iBAAmBA,IAG5B7C,EAAmBkQ,kBACjBN,EACA/M,EACA,CAAE7R,cACFif,EAAgBE,oBAChBhQ,GAGGqP,EAAS7d,SAAS+G,IACrB8W,EAASlb,KAAKoE,EAChB,GACA,IAGJ+G,EAAWgD,YAAa,EAEjB,CACL3F,iBAAkB2S,EAClBE,qBAEJ,CAuDA,MAAMf,EAAU,SAAU9X,GACxB,OAAOkO,MAAMC,QAAQnO,GAAKA,EAAI,CAACA,EACjC,EAEM+X,EAAoBuB,GACjBjB,GACEA,EAAYpQ,wBAAwBmD,cAAgBkO,C,wiUEvS/D,IAAMxB,EAAU,SAAA9X,GAAK,OAACkO,MAAMC,QAAQnO,GAAKA,EAAI,CAACA,EAAzB,ECOf+X,EAAoB,SAACuB,GACvB,OAAO,SAACjB,GACJ,OACIA,EAAYpQ,wBAAwBmD,cAAgBkO,CAE5D,CACJ,ECTQC,EAA0B1c,EAAAA,GAA1B2c,QAASC,EAAiB5c,EAAAA,GAAjB6c,aAETC,EAAqBC,EAAAA,GAArBC,iBAEAC,EAAeC,EAAAA,GAAfC,WAEAC,EAAsDV,EAAtDW,yBAA0BC,EAA4BZ,EAA5Ba,wBAE1BC,EAAwBvf,EAAAA,GAAxBwf,oBAEFC,EAAU,CAAExT,uBAAwB,MAAOoB,UAAW,UACtDqS,EAAe,CAAEzT,uBAAwB,MAAOoB,UAAW,aAC3DsS,EAAmB,CAAE1T,uBAAwB,MAAOoB,UAAW,UAE/DuS,EAAiB,SAACpQ,EAAOsM,EAAM+D,GACjC,IAAQ1S,EAA4BqC,EAA5BrC,wBACR,GAAKA,EAAL,CACA,IAAQlB,EAAsCkB,EAAtClB,uBAAwBoB,EAAcF,EAAdE,UAChC,OACKpB,GAA0B6P,EAAK7P,wBAC5BoB,GAAayO,EAAKzO,WACrBwS,GACG5T,GAA0B4T,EAAQ5T,wBAClCoB,GAAawS,EAAQxS,SAPO,CASxC,EAyCC,IAEoByS,EAAiB,oBAAA7V,IAAA8V,EAAA,KAAA9V,EAAA,CAkRjC,OAlRiC+V,EAAA/V,EAAA,OAAAqH,IAAA,0BAAAzO,MAClC,SAA+B2I,GAC3B,IAAQgD,EAAoBhD,EAApBgD,gBAEFyR,EAAqBjD,EAAQxO,GAC7B0R,EAAeD,EAAmBtR,MAAK,SAAAa,GAAK,OAC9CoQ,EAAepQ,EAAOiQ,EAAQ,IAE5BU,EACFF,EAAmBngB,QAAO,SAAA0P,GAAK,OAC3BoQ,EAAepQ,EAAOkQ,EAAcC,E,KACnC,GACHS,EAAWH,EAAmBtR,MAChC,SAAAa,GAAK,MAAwB,QAApBA,EAAMC,SAAmB,IAEhC4Q,EAAcrD,EAAQoD,EAAS5R,iBAAiBG,MAClD,SAAAa,GAAK,MAAwB,WAApBA,EAAMC,SAAsB,IAEjCnG,EAA0B+W,EAAY7R,gBAAtClF,sBACAO,EACJP,EADIO,yBAA0BN,EAC9BD,EAD8BC,sBAG5B+W,EAAe,CACjBxC,eAAgBjU,EAChB0W,WAAYhX,GAAyB,EACrCiX,UAAU,EACVrQ,QAAS+P,EACHvB,EAAauB,EAAa7P,0BAC1B3R,EACN0R,aAAc+P,EAAkBld,KAAI,SAAAwd,GAChC,OAAO9B,EAAa8B,EAAIpQ,oB,KAG5BiQ,EAAanQ,UACbmQ,EAAaI,YAAcJ,EAAanQ,QAAQG,aAEpD,IAAMqQ,EACFL,EAAalQ,cAAgBkQ,EAAalQ,aAAa,GAM3D,OALIuQ,IACAL,EAAatJ,SACR2J,EAAY,IAAMA,EAAY,GAAGrQ,aAClCqQ,EAAYrQ,aAEb,CACHgQ,aAAAA,EACAJ,aAAAA,EACAC,kBAAAA,EACAC,SAAAA,EACAC,YAAAA,EACA/W,sBAAAA,EACAO,yBAAAA,EACAN,sBAAAA,EAER,GAAC,CAAA+H,IAAA,iBAAAzO,MAED,SAAsB+d,EAAWnW,EAAkBxJ,GAI/C,IAAI4f,EAAuB,GACrBC,EAAe3f,OAAOC,KAAKwf,GAAW,GAC5C,IAAKE,EACD,MAAM,IAAI9e,MAAM,6BASpB,IAAM+e,EAAsBtW,EAAiBuW,IACzC,sBACAF,GAQIG,EAAwCF,EAAxCE,iBAAkBC,EAAsBH,EAAtBG,kBAG1B/f,OAAOC,KAAKwf,GAAWvf,SAAQ,SAAAyF,GAC3B,IAAMqa,EAAkB1W,EAAiBuW,IACrC,kBACAla,GAEEuC,EAAcoB,EAAiBuW,IAAI,cAAela,GAClDyO,EAAWqL,EAAU9Z,GACrBkP,EAAY7U,OAAOC,KAAKmU,GAExBjM,EAAwB,CAC1BwF,sBAAuBqS,EAAgBC,YACvCvX,yBAA0BsX,EAAgBE,gBAI1CrC,EAAWsC,wBAAwBH,EAAgBC,eAEnD9X,EAAsBC,sBAAwBF,GAIlD,IAAM6T,EAAoB,GAE1BlH,EAAU3U,SAAQ,SAAA8T,GACd,IAAM3F,EAvItB,SAA6B2F,EAAUI,EAAUjM,GAC7C,IAAMiY,EAAehM,EAASJ,GACxBoD,EACFuH,EAAkB0B,sCAAsCrM,GAC5D,GACKoM,GACAA,EAAavhB,MACbuhB,EAAavhB,KAAKvB,QAClB8Z,EAJL,CAWA,IAAMkJ,EAAeF,EAAavhB,KAAKiD,KAAI,SAAAye,GACvC,OA9BR,SACIA,EACAvM,EACA7L,EACAiP,GAEA,IAAMoJ,EAAOpJ,EAAUqJ,iCAAiCF,GAKxD,OAJAC,EAAKrY,sBAAwBA,EAEH,IAAIiP,EAAUsJ,qBAAqBF,EAGjE,CAkBeG,CACHJ,EACAvM,EACA7L,EACAiP,EAER,IAEA,OAAO,IAAI8G,EAAwBoC,EAbnC,CAcJ,CA8G8BM,CACV5M,EACAI,EACAjM,GAEAkG,GACA0N,EAAkBxa,KAAK8M,EAE/B,IAEAqR,EACIA,EAAqBtd,OAAO2Z,EACpC,IAEA,IAAM8E,EAAoB,IAAI7C,EAC1B,CAAE8C,yBAA0BpB,GAC5B5f,GAMEihB,EAAkC,IAAIC,WAAW,GACvDD,EAAgC,GAAK,EAErC,IAAME,EAA0B,CAC5BlX,iBAAkB+V,EAClBlU,kBAAmBmU,GAKjBmB,EAAQ,CACVC,2BAA4B,CACxBC,MAAO,CAACL,EAAgCM,QACxCC,GAAI,MAIRC,kBAAmB,CACfH,MAAO,CAAC,uBACRE,GAAI,MAERE,uBAAwB,CACpBJ,MAAO,CAAChD,EAAoBxU,OAC5B0X,GAAI,MAERG,0BAA2B,CACvBL,MAAO,CAAC,SACRE,GAAI,OAQZL,EAAwBC,MAAQA,EAChCD,EAAwBS,OALT,CACXC,UAAW,MAMf,IAAMlL,EAAS,IAAIiH,EAAiB,CAACuD,IAE/B7E,EAAcyE,EAAkBzE,YAClC6E,GAOJ,OAHAxK,EAAOC,QAAU1W,OAAOqU,OAAOoC,EAAOC,QAAS0F,GAC/C3F,EAAOC,QAAQwK,MAAQA,EAEhBzK,CACX,GAEA,CAAAtG,IAAA,oBAAAzO,MAOA,SAAyBgV,GAAqB,IAAZkL,EAAKvkB,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,CAAC,EAEvC,GAA2D,SAAvDqZ,EAAQmL,wBAAwBC,mBAChC,MAAM,IAAIjhB,MACN,+DAIR,IAKM+a,EAA4BC,EAAQnF,EAAQrJ,iBAAiBG,KAC/DsO,EANW,yBAUTC,EAAoBF,EACtBD,EAA0BvO,iBAC5B1O,OAAOmd,EAXK,sBAcRhW,EAAkB,CAAC,EAEnBkW,EACFlT,EAAkBC,yCAEhBkT,EAAwB,GA8C9B,OA5CAjc,OAAOC,KAAK+b,GAAwB9b,SAAQ,SAAAiQ,GACxC8L,EAAsB1a,KAAKya,EAAuB7L,IAClDrK,EAAgBqK,GAAO,EAC3B,IAEA4L,EAAkB7b,SAAQ,SAAAgc,GACtB,IAWM6F,EAXkClG,EACpCK,EAAiB7O,iBAIeG,MAC5B,SAAA4O,GAAW,MAhCK,wBAiCZA,EAAYpQ,wBAAwBmD,WACjB,IAGyBP,UAElDwI,EAAYwK,EAAMI,aAClBJ,EAAMI,aACF9F,EACAxF,EACAuF,GAEJA,EAAsBzO,MAAK,SAAAyU,GAAE,OACzBA,EAAGhS,qCACC8R,EACH,IAGX,GAAI3K,EAAW,CACX,IAAM1R,EACF0R,EAAU8K,mBAAmBhG,GAEjCpU,QAAQwI,IAAI,OAADlO,OAAQgV,EAAUpD,SAAQ,SACrClM,QAAQwI,IAAI5K,GAEZI,EAAgBsR,EAAUpD,UAAUzS,KAAKmE,EAC7C,CACJ,IAIOI,CACX,GAAC,CAAAqK,IAAA,eAAAzO,MAED,SAAoB0V,GAChBtO,EAAkBC,yCACdqO,EAAU+K,iBACV/K,EACJtO,EAAkBuX,sCACdjJ,EAAUpD,UACVoD,EACJtO,EAAkBsZ,wBAAwBhL,EAAUpD,UAChDoD,EAAU+K,eAClB,KAACrZ,CAAA,CAlRiC,GAqRtC6V,EAAkByD,wBAA0B,CAAC,EAC7CzD,EAAkB5V,yCAA2C,CAAC,EAC9D4V,EAAkB0B,sCAAwC,CAAC,EC/V3D,IAAAgC,EAAe,0BCICC,EAAiB1hB,EAAAA,GAAU2hB,OAAnC5d,OAEF6d,EAAS,SAETC,EAAM,oBAAA9d,IAAAia,EAAA,KAAAja,EAAA,CAiDP,OAjDOka,EAAAla,EAAA,OAAAwL,IAAA,qBAAAzO,MAER,SAA0B2I,GACtB,IAAAqY,EACI/D,EAAkBgE,wBAAwBtY,GADtC8U,EAAYuD,EAAZvD,aAAcF,EAAQyD,EAARzD,SAAUC,EAAWwD,EAAXxD,YAG1B7E,EAAKuI,EAAAA,EAAA,GACJzD,GAAY,IACf7hB,OAAQ2hB,EAASpQ,sBAAsBgD,aACvCmC,SAAUrP,EAAOqP,SACjBzQ,QAAS,CACLsf,MAAO,CAAC,EACRC,IAAK,CAAC,EACNtf,QAAS,CACLuf,UAAU,EACVC,oBAAoB,EACpBC,oBAAoB,EACpBC,qBAAqB,EACrBC,gBAAgB,MAG1BC,EAAAC,EAOEnE,EAAYjZ,YAAW,GAE3B,OANIoU,EAAM9W,QAAQsf,MAAM9e,EAACqf,EAAA,GACrB/I,EAAM9W,QAAQsf,MAAM5e,EAACmf,EAAA,GACrB/I,EAAM9W,QAAQuf,IAAI/e,EAACqf,EAAA,GACnB/I,EAAM9W,QAAQuf,IAAI7e,EAACmf,EAAA,GAGhB/I,CACX,GAAC,CAAAlK,IAAA,mCAAAzO,MAED,SAAwC6e,GACpC,IAAQhd,EAAmCgd,EAAnChd,QAASyL,EAA0BuR,EAA1BvR,QAASC,EAAiBsR,EAAjBtR,aAO1B,MAAO,CACHqU,OAPW/f,EAAQsf,MAQnBU,OAPWhgB,EAAQuf,IAQnBU,SAPajD,EAAKjjB,OAQlBmmB,4BANgC,iCAOhCzU,QAAAA,EACAC,aAAcA,GAAgB,GAEtC,KAACtK,CAAA,CAjDO,GAoDZ8d,EAAOzO,SAAWwO,EAClBC,EAAON,gBAAkBK,EACzBC,EAAO/B,qBAAuB4B,EAC9BG,EAAOxS,qCAAuC,SAAA/J,GAC1C,IAAKA,EAAmBtH,SAAS,KAC7B,OAAO,EAGX,IAAiE8kB,EAAAL,EAA7Bnd,EAAmBE,MAAM,KAAI,GAA1Dud,EAAeD,EAAA,GAAE1P,EAAQ0P,EAAA,GAEhC,OAAIC,IAAoBtB,GAIjBrO,IAAawO,CACxB,EAEA7D,EAAkBiF,aAAanB,GCxE/B,IAAkBoB,EAAmBjjB,EAAAA,GAAU2hB,OAAvCuB,SAEFC,EAAW,oBAAAA,IAAAnF,EAAA,KAAAmF,EAAA,CAoDZ,OApDYlF,EAAAkF,EAAA,OAAA5T,IAAA,qBAAAzO,MACb,SAA0B2I,GAyBtB,IAxBA,IAAAqY,EACI/D,EAAkBgE,wBAAwBtY,GADtC8U,EAAYuD,EAAZvD,aAAcD,EAAWwD,EAAXxD,YAAaD,EAAQyD,EAARzD,SAG7B5E,EAAKuI,EAAAA,EAAA,GACJzD,GAAY,IACfnL,SAAU+P,EAAY/P,SACtBzQ,QAAS,CACLygB,OAAQ,GACRxgB,QAAS,CACLygB,QAAQ,EACRlB,UAAU,EACVC,oBAAoB,EACpBC,oBAAoB,EACpBC,qBAAqB,EACrBC,gBAAgB,IAGxBrkB,YAAa,CACTolB,KAAMjF,EAAWA,EAASpQ,sBAAsBgD,aAAe,GAEnE9R,WAAOxC,EACP4mB,aAAa,IAETle,EAAgBiZ,EAAhBjZ,YACC3G,EAAI,EAAGA,EAAI2G,EAAY3I,OAAQgC,GAAK,EACzC+a,EAAM9W,QAAQygB,OAAOziB,KAAK,CACtBwC,EAAGkC,EAAY3G,GACf2E,EAAGgC,EAAY3G,EAAI,KAI3B,OAAO+a,CACX,GAAC,CAAAlK,IAAA,mCAAAzO,MAED,SAAwC6e,GACpC,IAAQhd,EAAqDgd,EAArDhd,QAASyL,EAA4CuR,EAA5CvR,QAASC,EAAmCsR,EAAnCtR,aAAYmV,EAAuB7D,EAArBzhB,YAAAA,OAAW,IAAAslB,EAAG,CAAC,EAACA,EAChDJ,EAAWzgB,EAAXygB,OACRK,EAAoCvlB,EAA5BolB,KAAAA,OAAO,IAAHG,EAAG,EAACA,EAAAC,EAAoBxlB,EAAlBylB,UAKlB,MAAO,CACHP,OAAAA,EACAE,KAAAA,EACAK,eAR0B,IAAHD,EAAG,EAACA,EAS3Bb,4BANA,sCAOAzU,QAAAA,EACAC,aAAcA,GAAgB,GAEtC,KAAC8U,CAAA,CApDY,GAuDjBA,EAAY/P,SAAW,cACvB+P,EAAY5B,gBAAkB,cAC9B4B,EAAYrD,qBAAuBmD,EACnCE,EAAY9T,qCAAuC,SAAA/J,GAC/C,IAAKA,EAAmBtH,SAAS,KAC7B,OAAO,EAGX,IAAiE8kB,EAAAL,EAA7Bnd,EAAmBE,MAAM,KAAI,GAA1Dud,EAAeD,EAAA,GAAE1P,EAAQ0P,EAAA,GAEhC,OAAIC,IAAoBtB,GAIjBrO,IAAa+P,EAAY/P,QACpC,EAEA2K,EAAkBiF,aAAaG,GC1E/B,IAAuBS,EAAwB5jB,EAAAA,GAAU2hB,OAAjDkC,cAEFC,EAAgB,gBAMhBC,EAAa,oBAAAF,IAAA7F,EAAA,KAAA6F,EAAA,CAuJd,OAvJc5F,EAAA4F,EAAA,OAAAtU,IAAA,qBAAAzO,MAEf,SAA0B2I,GACtB,IAAQgD,EAAoBhD,EAApBgD,gBAEF0R,EAAelD,EAAQxO,GAAiBG,MAC1C,SAAAa,GAAK,MATD,WASKA,EAAMrC,wBAAwBE,SAAqB,IAG1D8S,EAAoBnD,EAAQxO,GAAiB1O,QAC/C,SAAA0P,GAAK,MAZI,WAYAA,EAAMrC,wBAAwBE,SAA0B,IAG/D0Y,EAAmB/I,EAAQxO,GAAiBG,MAC9C,SAAAa,GAAK,MAnBC,cAmBGA,EAAMrC,wBAAwBmD,WAAyB,IAG9D0V,EAAsBhJ,EACxB+I,EAAiBvX,iBACnBG,MAAK,SAAAa,GAAK,MAAwB,WAApBA,EAAMC,S,IAEhBwW,EAAoBjJ,EAAQxO,GAAiBG,MAC/C,SAAAa,GAAK,MA1BE,eA0BEA,EAAMrC,wBAAwBmD,WAA0B,IAG/D4V,EAAuBlJ,EACzBiJ,EAAkBzX,iBACpBG,MAAK,SAAAa,GAAK,MAAwB,WAApBA,EAAMC,S,IAEdnG,EAA0B0c,EAAoBxX,gBAA9ClF,sBACAO,EACJP,EADIO,yBAA0BN,EAC9BD,EAD8BC,sBAK5B4c,EAAkBC,OACpBL,EAAiB/V,sBAAsBgD,cAGrCqT,EAAmBD,OACrBH,EAAkBjW,sBAAsBgD,cAGtCrN,EACCrD,KAAKgkB,IACJN,EAAoB5e,YAAY,GAChC4e,EAAoB5e,YAAY,GAChC8e,EAAqB9e,YAAY,GACjC8e,EAAqB9e,YAAY,IALnCzB,EAOCrD,KAAKgkB,IACJN,EAAoB5e,YAAY,GAChC4e,EAAoB5e,YAAY,GAChC8e,EAAqB9e,YAAY,GACjC8e,EAAqB9e,YAAY,IAsEzC,MAlEc,CACV0W,eAAgBjU,EAChB0W,WAAYhX,GAAyB,EACrC4L,SAAUyQ,EAAczQ,SACxBiQ,QAAQ,EACR1gB,QAAS,CACLsf,MAAO,CACH9e,EAAG8gB,EAAoB5e,YAAY,GACnChC,EAAG4gB,EAAoB5e,YAAY,GACnCgd,oBAAoB,EACpBC,qBAAqB,EACrBe,QAAQ,EACRmB,WAAW,EACXrjB,MAAO,GAEX+gB,IAAK,CACD/e,EAAG8gB,EAAoB5e,YAAY,GACnChC,EAAG4gB,EAAoB5e,YAAY,GACnCgd,oBAAoB,EACpBC,qBAAqB,EACrBe,QAAQ,EACRmB,WAAW,EACXrjB,MAAO,GAEXsjB,mBAAoB,CAChBthB,EAAGghB,EAAqB9e,YAAY,GACpChC,EAAG8gB,EAAqB9e,YAAY,GACpCgd,oBAAoB,EACpBC,qBAAqB,EACrBe,QAAQ,EACRmB,WAAW,EACXrjB,MAAO,GAEXujB,iBAAkB,CACdvhB,EAAGghB,EAAqB9e,YAAY,GACpChC,EAAG8gB,EAAqB9e,YAAY,GACpCgd,oBAAoB,EACpBC,qBAAqB,EACrBe,QAAQ,EACRmB,WAAW,EACXrjB,MAAO,GAEXyB,QAAS,CACL4hB,WAAW,EACXrC,UAAU,EACVkB,QAAQ,EACRjB,oBAAoB,EACpBC,oBAAoB,EACpBC,qBAAqB,EACrBC,gBAAgB,EAChBpf,EAAGS,EAAgB,GACnBP,EAAGO,EAAgB,KAG3B2f,aAAa,EACboB,YAAY,EACZP,gBAAAA,EACAE,iBAAAA,EACA9lB,SAAU,gBACVomB,SAAS,EACTxW,QAAS+P,EACHA,EAAa7P,yBACb3R,EACN0R,aAAc+P,EAAkBld,KAAI,SAAAwd,GAAG,OAAIA,EAAIpQ,mBAAmB,IAI1E,GAAC,CAAAiB,IAAA,mCAAAzO,MAED,SAAwC6e,GACpC,IAAAkF,EACIlF,EAAKhd,QADDsf,EAAK4C,EAAL5C,MAAOC,EAAG2C,EAAH3C,IAAKuC,EAAkBI,EAAlBJ,mBAAoBC,EAAgBG,EAAhBH,iBAEhCJ,EACJ3E,EADI2E,iBAMR,MAAO,CACHQ,SAAU,CACNpC,OAAQT,EACRU,OAAQT,GAEZ6C,UAAW,CACPrC,OAAQ+B,EACR9B,OAAQ+B,GAEZM,eAdArF,EADsByE,gBAgBtBa,gBAAiBX,EACjBzB,4BAbA,wCAcAzU,QAjBAuR,EADuCvR,QAmBvCC,aAlBAsR,EADgDtR,cAmBlB,GAEtC,KAACwV,CAAA,CAvJc,GA0JnBE,EAAc3Q,SAAW0Q,EACzBC,EAAcxC,gBAAkBuC,EAChCC,EAAcjE,qBAAuB8D,EACrCG,EAAc1U,qCAAuC,SAAA/J,GACjD,IAAKA,EAAmBtH,SAAS,KAC7B,OAAO,EAGX,IAAiE8kB,EAAAL,EAA7Bnd,EAAmBE,MAAM,KAAI,GAA1Dud,EAAeD,EAAA,GAAE1P,EAAQ0P,EAAA,GAEhC,OAAIC,IAAoBtB,GAIjBrO,IAAa0Q,CACxB,EAEA/F,EAAkBiF,aAAae,GCpL/B,IAAiBmB,EAAkBllB,EAAAA,GAAU2hB,OAArCwD,QAEFC,EAAgB,gBAEhBC,EAAa,oBAAAA,IAAArH,EAAA,KAAAqH,EAAA,CAsHd,OAtHcpH,EAAAoH,EAAA,OAAA9V,IAAA,qBAAAzO,MAEf,SAA0B2I,GACtB,IAAAqY,EACI/D,EAAkBgE,wBAAwBtY,GADtC8U,EAAYuD,EAAZvD,aAAcF,EAAQyD,EAARzD,SAGdhZ,EAHmCyc,EAAXxD,YAGxBjZ,YAEFigB,EAAY,CACd,CAAEniB,EAAGkC,EAAY,GAAIhC,EAAGgC,EAAY,IACpC,CAAElC,EAAGkC,EAAY,GAAIhC,EAAGgC,EAAY,KAElCkgB,EAAY,CACd,CAAEpiB,EAAGkC,EAAY,GAAIhC,EAAGgC,EAAY,IACpC,CAAElC,EAAGkC,EAAY,GAAIhC,EAAGgC,EAAY,KAKlCmgB,EAAkBjlB,KAAKklB,KACzBllB,KAAKmlB,IAAIH,EAAU,GAAGpiB,EAAIoiB,EAAU,GAAGpiB,EAAG,GACtC5C,KAAKmlB,IAAIH,EAAU,GAAGliB,EAAIkiB,EAAU,GAAGliB,EAAG,IAG5CsiB,GACEJ,EAAU,GAAGpiB,EAAIoiB,EAAU,GAAGpiB,GAAKqiB,EADrCG,GAEEJ,EAAU,GAAGliB,EAAIkiB,EAAU,GAAGliB,GAAKmiB,EAGrCI,EAAsBJ,EAAkB,EAGxCK,EAAU,CACZ1iB,EAAGmiB,EAAU,GAAGniB,EAAIwiB,EAAuBC,EAC3CviB,EAAGiiB,EAAU,GAAGjiB,EAAIsiB,EAAuBC,GAIzCE,EAAU,CACZ3iB,EAAGmiB,EAAU,GAAGniB,EAAIwiB,EAAuBC,EAC3CviB,EAAGiiB,EAAU,GAAGjiB,EAAIsiB,EAAuBC,GAmC/C,OAjCW5D,EAAAA,EAAA,GACJzD,GAAY,IACfnL,SAAUiS,EAAcjS,SACxBiQ,QAAQ,EACRnlB,YAAa,CACTolB,KAAMjF,EAAWA,EAASpQ,sBAAsBgD,aAAe,GAEnEtO,QAAS,CACLuf,IAAK,CACD/e,EAAG0iB,EAAQ1iB,EACXE,EAAGwiB,EAAQxiB,EACXmhB,WAAW,EACXnB,QAAQ,GAEZ0C,gBAAiB,EACjB9D,MAAO,CACH9e,EAAG2iB,EAAQ3iB,EACXE,EAAGyiB,EAAQziB,EACXmhB,WAAW,EACXnB,QAAQ,GAEZzgB,QAAS,CACLuf,UAAU,EACVC,oBAAoB,EACpBC,oBAAoB,EACpBC,qBAAqB,EACrBC,gBAAgB,IAGxBgB,aAAa,EACbqB,SAAS,GAIjB,GAAC,CAAArV,IAAA,mCAAAzO,MAED,SAAwC6e,GACpC,IAAA6D,EAA6D7D,EAArDzhB,YAAAA,OAAW,IAAAslB,EAAG,CAAC,EAACA,EAAE7gB,EAAmCgd,EAAnChd,QAASyL,EAA0BuR,EAA1BvR,QAASC,EAAiBsR,EAAjBtR,aACpC4T,EAAetf,EAAfsf,MAAOC,EAAQvf,EAARuf,IACPoB,EAASplB,EAATolB,KAEF0C,EAAczlB,KAAKuG,IAAImb,EAAM9e,EAAI+e,EAAI/e,GAAK,EAC1C8iB,EAAc1lB,KAAKuG,IAAImb,EAAM5e,EAAI6e,EAAI7e,GAAK,EAE1C+f,EAAS,GAETzd,EAAS,CAAExC,GAAI8e,EAAM9e,EAAI+e,EAAI/e,GAAK,EAAGE,GAAI4e,EAAM5e,EAAI6e,EAAI7e,GAAK,GAE9D2iB,EAAcC,GAGd7C,EAAOziB,KAAK,CAAEwC,EAAGwC,EAAOxC,EAAI6iB,EAAa3iB,EAAGsC,EAAOtC,IACnD+f,EAAOziB,KAAK,CAAEwC,EAAGwC,EAAOxC,EAAI6iB,EAAa3iB,EAAGsC,EAAOtC,IAEnD+f,EAAOziB,KAAK,CAAEwC,EAAGwC,EAAOxC,EAAGE,EAAGsC,EAAOtC,EAAI4iB,IACzC7C,EAAOziB,KAAK,CAAEwC,EAAGwC,EAAOxC,EAAGE,EAAGsC,EAAOtC,EAAI4iB,MAIzC7C,EAAOziB,KAAK,CAAEwC,EAAGwC,EAAOxC,EAAGE,EAAGsC,EAAOtC,EAAI4iB,IACzC7C,EAAOziB,KAAK,CAAEwC,EAAGwC,EAAOxC,EAAGE,EAAGsC,EAAOtC,EAAI4iB,IAEzC7C,EAAOziB,KAAK,CAAEwC,EAAGwC,EAAOxC,EAAI6iB,EAAa3iB,EAAGsC,EAAOtC,IACnD+f,EAAOziB,KAAK,CAAEwC,EAAGwC,EAAOxC,EAAI6iB,EAAa3iB,EAAGsC,EAAOtC,KAMvD,MAAO,CACHigB,KAAAA,EACAF,OAAAA,EACAP,4BALA,wCAMAzU,QAAAA,EACAC,aAAcA,GAAgB,GAEtC,KAACgX,CAAA,CAtHc,GAyHnBA,EAAcjS,SAAWgS,EACzBC,EAAc9D,gBAAkB6D,EAChCC,EAAcvF,qBAAuBoF,EACrCG,EAAchW,qCAAuC,SAAA/J,GACjD,IAAKA,EAAmBtH,SAAS,KAC7B,OAAO,EAGX,IAAiE8kB,EAAAL,EAA7Bnd,EAAmBE,MAAM,KAAI,GAA1Dud,EAAeD,EAAA,GAAE1P,EAAQ0P,EAAA,GAEhC,OAAIC,IAAoBtB,GAIjBrO,IAAagS,CACxB,EAEArH,EAAkBiF,aAAaqC,GC9I/B,IAAgBa,EAAiBlmB,EAAAA,GAAU2hB,OAAnCwE,OAEFC,EAAY,YAEZC,EAAS,oBAAAA,IAAArI,EAAA,KAAAqI,EAAA,CA8EV,OA9EUpI,EAAAoI,EAAA,OAAA9W,IAAA,qBAAAzO,MAEX,SAA0B2I,GACtB,IAAAqY,EACI/D,EAAkBgE,wBAAwBtY,GADtC8U,EAAYuD,EAAZvD,aAAcF,EAAQyD,EAARzD,SAGdhZ,EAHmCyc,EAAXxD,YAGxBjZ,YAEFM,EAAS,CAAExC,EAAGkC,EAAY,GAAIhC,EAAGgC,EAAY,IAC7C6c,EAAM,CAAE/e,EAAGkC,EAAY,GAAIhC,EAAGgC,EAAY,IAsChD,OApCW2c,EAAAA,EAAA,GACJzD,GAAY,IACfnL,SAAUiT,EAAUjT,SACpBiQ,QAAQ,EACRnlB,YAAa,CACTolB,KAAMjF,EACAA,EAASpQ,sBAAsBgD,aAC/B,EAENpL,OAAQ,EACR8d,UAAW,GAEfhhB,QAAS,CACLuf,IAAGF,EAAAA,EAAA,GACIE,GAAG,IACNsC,WAAW,EACXnB,QAAQ,IAEZ0C,gBAAiB,EACjB9D,MAAKD,EAAAA,EAAA,GACErc,GAAM,IACT6e,WAAW,EACXnB,QAAQ,IAEZzgB,QAAS,CACLuf,UAAU,EACVC,oBAAoB,EACpBC,oBAAoB,EACpBC,qBAAqB,EACrBC,gBAAgB,IAGxBgB,aAAa,EACbqB,SAAS,GAIjB,GAEA,CAAArV,IAAA,mCAAAzO,MAMA,SAAwC6e,GACpC,IAAA6D,EAA6D7D,EAArDzhB,YAAAA,OAAW,IAAAslB,EAAG,CAAC,EAACA,EAAE7gB,EAAmCgd,EAAnChd,QAASyL,EAA0BuR,EAA1BvR,QAASC,EAAiBsR,EAAjBtR,aAC7B1I,EAAgBhD,EAAvBsf,MAAeC,EAAQvf,EAARuf,IACfoB,EAAiBplB,EAAjBolB,KAAMzd,EAAW3H,EAAX2H,OAER8d,EAAY,EAAIpjB,KAAK+lB,GAAKzgB,EAC1Bud,EAAS,GAEfA,EAAOziB,KAAKgF,GACZyd,EAAOziB,KAAKuhB,GAIZ,MAAO,CACHoB,KAAAA,EACAK,UAAAA,EACA9d,OAAAA,EACAud,OAAAA,EACAP,4BAPgC,oCAQhCzU,QAAAA,EACAC,aAAcA,GAAgB,GAEtC,KAACgY,CAAA,CA9EU,GAiFfA,EAAUjT,SAAWgT,EACrBC,EAAU9E,gBAAkB6E,EAC5BC,EAAUvG,qBAAuBoG,EACjCG,EAAUhX,qCAAuC,SAAA/J,GAC7C,IAAKA,EAAmBtH,SAAS,KAC7B,OAAO,EAGX,IAAiE8kB,EAAAL,EAA7Bnd,EAAmBE,MAAM,KAAI,GAA1Dud,EAAeD,EAAA,GAAE1P,EAAQ0P,EAAA,GAEhC,OAAIC,IAAoBtB,GAIjBrO,IAAagT,CACxB,EAEArI,EAAkBiF,aAAaqD,GCrG/B,IAAeE,EAAgBvmB,EAAAA,GAAU2hB,OAAjC6E,MAEFC,GAAiB,gBACjBC,GAAsB,sBAEtBC,GAAa,oBAAAC,IAAA5I,EAAA,KAAA4I,EAAA,CAyEd,OAzEc3I,EAAA2I,EAAA,OAAArX,IAAA,qBAAAzO,MACf,SAA0B2I,GACtB,IAAAqY,EACI/D,EAAkBgE,wBAAwBtY,GADtC8U,EAAYuD,EAAZvD,aAAcD,EAAWwD,EAAXxD,YAGhBtE,EAHyC8H,EAAZ3D,aAGT7P,oBAAoBC,YAEtClJ,EAAgBiZ,EAAhBjZ,YAwCR,OAtCW2c,EAAAA,EAAA,GACJzD,GAAY,IACfnL,SAAUwT,EAAcxT,SACxBiQ,QAAQ,EACR1gB,QAAS,CACLsf,MAAO,CACH9e,EAAGkC,EAAY,GACfhC,EAAGgC,EAAY,GACfmf,WAAW,EACXnB,QAAQ,GAIZnB,IAAK,CACD/e,EAC0B,GAAtBkC,EAAY3I,OACN2I,EAAY,GACZA,EAAY,GAAK,GAC3BhC,EAC0B,GAAtBgC,EAAY3I,OACN2I,EAAY,GACZA,EAAY,GAAK,GAC3Bmf,WAAW,EACXnB,QAAQ,GAEZzgB,QAAS,CACLuf,UAAU,EACVC,oBAAoB,EACpBC,oBAAoB,EACpBC,qBAAqB,EACrBC,gBAAgB,IAGxBgB,aAAa,EACbvJ,KAAAA,EACA4K,SAAS,GAIjB,GAAC,CAAArV,IAAA,mCAAAzO,MAED,SAAwC6e,GACpC,IAAMyD,EAAS,CAACzD,EAAKhd,QAAQsf,MAAOtC,EAAKhd,QAAQuf,KAE3C9T,EAA0BuR,EAA1BvR,QAEAyY,EAAgC,CAClCzD,OAAAA,EACAP,4BAAoE,wCACpExU,aAL4BsR,EAAjBtR,cAKmB,IAclC,OAVKD,GAAWA,EAAQ9C,YAAcob,KAClCtY,EAAU,CACN9C,UAAWob,GACXxc,uBAAwB,OACxBqE,YAAaoR,EAAK3F,OAI1B6M,EAA8BzY,QAAUA,EAEjCyY,CACX,KAACD,CAAA,CAzEc,GA4EnBD,GAAcvT,SAAWqT,GACzBE,GAAcpF,gBAAkBkF,GAChCE,GAAc7G,qBAAuByG,EACrCI,GAActX,qCAAuC,SAAA/J,GACjD,IAAKA,EAAmBtH,SAAS,KAC7B,OAAO,EAGX,IAAiE8kB,EAAAL,EAA7Bnd,EAAmBE,MAAM,KAAI,GAA1Dud,EAAeD,EAAA,GAAE1P,EAAQ0P,EAAA,GAEhC,OAAIC,IAAoBtB,GAIjBrO,IAAaqT,EACxB,EAEA1I,EAAkBiF,aAAa2D,ICnG/B,IAAmBG,GAAoB9mB,EAAAA,GAAU2hB,OAAzCoF,UAEFC,GAAa,YAEbC,GAAS,oBAAAF,IAAA/I,EAAA,KAAA+I,EAAA,CAiEV,OAjEU9I,EAAA8I,EAAA,OAAAxX,IAAA,qBAAAzO,MAEX,SAA0B2I,GACtB,IAAAqY,EACI/D,EAAkBgE,wBAAwBtY,GADtC8U,EAAYuD,EAAZvD,aAAcF,EAAQyD,EAARzD,SAAUC,EAAWwD,EAAXxD,YAG1B7E,EAAKuI,EAAAA,EAAA,GACJzD,GAAY,IACf2I,OAAQ7I,EAASpQ,sBAAsBgD,aACvCmC,SAAU2T,EAAU3T,SACpBzQ,QAAS,CACLsf,MAAO,CAAC,EACRC,IAAK,CAAC,EACNiF,OAAQ,CACJ3C,WAAW,EACXnC,oBAAoB,GAExB+E,KAAM,CACF5C,WAAW,EACXnC,oBAAoB,GAExBzf,QAAS,CACLuf,UAAU,EACVC,oBAAoB,EACpBC,oBAAoB,EACpBC,qBAAqB,EACrBC,gBAAgB,MAG1BC,EAAAC,EAWEnE,EAAYjZ,YAAW,GAE3B,OAVIoU,EAAM9W,QAAQsf,MAAM9e,EAACqf,EAAA,GACrB/I,EAAM9W,QAAQsf,MAAM5e,EAACmf,EAAA,GACrB/I,EAAM9W,QAAQuf,IAAI/e,EAACqf,EAAA,GACnB/I,EAAM9W,QAAQuf,IAAI7e,EAACmf,EAAA,GACnB/I,EAAM9W,QAAQwkB,OAAOhkB,EAACqf,EAAA,GACtB/I,EAAM9W,QAAQwkB,OAAO9jB,EAACmf,EAAA,GACtB/I,EAAM9W,QAAQykB,KAAKjkB,EAACqf,EAAA,GACpB/I,EAAM9W,QAAQykB,KAAK/jB,EAACmf,EAAA,GAGjB/I,CACX,GAAC,CAAAlK,IAAA,mCAAAzO,MAED,SAAwC6e,GACpC,IAAQhd,EAAmCgd,EAAnChd,QAASyL,EAA0BuR,EAA1BvR,QAASC,EAAiBsR,EAAjBtR,aAS1B,MAAO,CACHqU,OATW/f,EAAQsf,MAUnBU,OATWhgB,EAAQuf,IAUnBmF,OATW1kB,EAAQwkB,OAUnBG,OATW3kB,EAAQykB,KAUnBF,OATWvH,EAAKuH,OAUhBrE,4BARgC,oCAShCzU,QAAAA,EACAC,aAAcA,GAAgB,GAEtC,KAAC0Y,CAAA,CAjEU,GAoEfE,GAAU7T,SAAW4T,GACrBC,GAAU1F,gBAAkByF,GAC5BC,GAAUnH,qBAAuBgH,GACjCG,GAAU5X,qCAAuC,SAAA/J,GAC7C,IAAKA,EAAmBtH,SAAS,KAC7B,OAAO,EAGX,IAAiE8kB,EAAAL,EAA7Bnd,EAAmBE,MAAM,KAAI,GAA1Dud,EAAeD,EAAA,GAAE1P,EAAQ0P,EAAA,GAEhC,OAAIC,IAAoBtB,GAIjBrO,IAAa4T,EACxB,EAEAjJ,EAAkBiF,aAAaiE,ICxF/B,IAAeM,GAAgBvnB,EAAAA,GAAU2hB,OAAjC6F,MAEFC,GAAQ,QAERC,GAAK,oBAAAF,IAAAxJ,EAAA,KAAAwJ,EAAA,CA4DN,OA5DMvJ,EAAAuJ,EAAA,OAAAjY,IAAA,qBAAAzO,MAIP,SAA0B2I,GACtB,IAAAqY,EACI/D,EAAkBgE,wBAAwBtY,GADtC8U,EAAYuD,EAAZvD,aAAcF,EAAQyD,EAARzD,SAAUC,EAAWwD,EAAXxD,YAG1B7E,EAAKuI,EAAAA,EAAA,GACJzD,GAAY,IACf2I,OAAQ7I,EAASpQ,sBAAsBgD,aACvCmC,SAAUoU,EAAMpU,SAChBzQ,QAAS,CACLsf,MAAO,CAAC,EACR0F,OAAQ,CAAC,EACTzF,IAAK,CAAC,EACNtf,QAAS,CACLuf,UAAU,EACVC,oBAAoB,EACpBC,oBAAoB,EACpBC,qBAAqB,EACrBC,gBAAgB,MAG1BC,EAAAC,EAWEnE,EAAYjZ,YAAW,GAE3B,OAVIoU,EAAM9W,QAAQsf,MAAM9e,EAACqf,EAAA,GACrB/I,EAAM9W,QAAQsf,MAAM5e,EAACmf,EAAA,GACrB/I,EAAM9W,QAAQglB,OAAOxkB,EAACqf,EAAA,GACtB/I,EAAM9W,QAAQglB,OAAOtkB,EAACmf,EAAA,GACtB/I,EAAM9W,QAAQglB,OAAOxkB,EAACqf,EAAA,GACtB/I,EAAM9W,QAAQglB,OAAOtkB,EAACmf,EAAA,GACtB/I,EAAM9W,QAAQuf,IAAI/e,EAACqf,EAAA,GACnB/I,EAAM9W,QAAQuf,IAAI7e,EAACmf,EAAA,GAGhB/I,CACX,GAAC,CAAAlK,IAAA,mCAAAzO,MAED,SAAwC6e,GACpC,IAAQhd,EAAmCgd,EAAnChd,QAASyL,EAA0BuR,EAA1BvR,QAASC,EAAiBsR,EAAjBtR,aAS1B,MAAO,CACHqU,OATW/f,EAAQsf,MAUnBU,OATWhgB,EAAQglB,OAUnBN,OATW1kB,EAAQglB,OAUnBL,OATW3kB,EAAQuf,IAUnBgF,OATWvH,EAAKuH,OAUhBrE,4BARgC,gCAShCzU,QAAAA,EACAC,aAAcA,GAAgB,GAEtC,KAACmZ,CAAA,CA5DM,GA+DXE,GAAMtU,SAAWqU,GACjBC,GAAMnG,gBAAkBkG,GACxBC,GAAM5H,qBAAuByH,GAC7BG,GAAMrY,qCAAuC,SAAA/J,GACzC,IAAKA,EAAmBtH,SAAS,KAC7B,OAAO,EAGX,IAAiE8kB,EAAAL,EAA7Bnd,EAAmBE,MAAM,KAAI,GAA1Dud,EAAeD,EAAA,GAAE1P,EAAQ0P,EAAA,GAEhC,OAAIC,IAAoBtB,GAIjBrO,IAAaqU,EACxB,EAEA1J,EAAkBiF,aAAa0E,ICrF/B,IAAkBE,GAAmB5nB,EAAAA,GAAU2hB,OAAvCuB,SAEF2E,GAAY,oBAAAA,IAAA7J,EAAA,KAAA6J,EAAA,CA+Db,OA/Da5J,EAAA4J,EAAA,OAAAtY,IAAA,qBAAAzO,MACd,SAA0B2I,GACtB,IAAAqY,EACI/D,EAAkBgE,wBAAwBtY,GADtC8U,EAAYuD,EAAZvD,aAAcD,EAAWwD,EAAXxD,YAAaD,EAAQyD,EAARzD,SAG7B5E,EAAKuI,EAAAA,EAAA,GACJzD,GAAY,IACfnL,SAAUyU,EAAazU,SACvBzQ,QAAS,CACLsf,MAAO,CAAC,EACRC,IAAK,CAAC,EACNtf,QAAS,CACLygB,QAAQ,EACRlB,UAAU,EACVC,oBAAoB,EACpBC,oBAAoB,EACpBC,qBAAqB,EACrBC,gBAAgB,GAEpBwD,gBAAiB,GAErB7nB,YAAa,CACTolB,KAAMjF,EAAWA,EAASpQ,sBAAsBgD,aAAe,GAEnE9R,WAAOxC,EACP4mB,aAAa,IAEOf,EAAAC,EASpBnE,EAAYjZ,YAAW,GAE3B,OARIoU,EAAM9W,QAAQsf,MAAM9e,EAACqf,EAAA,GACrB/I,EAAM9W,QAAQsf,MAAM5e,EAACmf,EAAA,GACPA,EAAA,GACAA,EAAA,GACd/I,EAAM9W,QAAQuf,IAAI/e,EAACqf,EAAA,GACnB/I,EAAM9W,QAAQuf,IAAI7e,EAACmf,EAAA,GAGhB/I,CACX,GAAC,CAAAlK,IAAA,mCAAAzO,MAED,SAAwC6e,GACpC,IAAQvR,EAAqDuR,EAArDvR,QAASC,EAA4CsR,EAA5CtR,aAAYmV,EAAgC7D,EAA9BzhB,YAAAA,OAAW,IAAAslB,EAAG,CAAC,EAACA,EAAE7gB,EAAYgd,EAAZhd,QACzCsf,EAAetf,EAAfsf,MAAOC,EAAQvf,EAARuf,IAYf,MAAO,CACHkB,OAZW,CACXnB,EACA,CAAE9e,EAAG8e,EAAM9e,EAAGE,EAAG6e,EAAI7e,GACrB6e,EACA,CAAE/e,EAAG+e,EAAI/e,EAAGE,EAAG4e,EAAM5e,IASrBigB,KAPwBplB,EAApBolB,KAQJK,UARwBzlB,EAAdylB,UASVd,4BANA,uCAOAzU,QAAAA,EACAC,aAAcA,GAAgB,GAEtC,KAACwZ,CAAA,CA/Da,GAkElBA,GAAazU,SAAW,eACxByU,GAAatG,gBAAkB,eAC/BsG,GAAa/H,qBAAuB8H,GACpCC,GAAaxY,qCAAuC,SAAA/J,GAChD,IAAKA,EAAmBtH,SAAS,KAC7B,OAAO,EAGX,IAAiE8kB,EAAAL,EAA7Bnd,EAAmBE,MAAM,KAAI,GAA1Dud,EAAeD,EAAA,GAAE1P,EAAQ0P,EAAA,GAEhC,OAAIC,IAAoBtB,GAIjBrO,IAAayU,GAAazU,QACrC,EAEA2K,EAAkBiF,aAAa6E,ICtF/B,IAAAC,GAKI9nB,EAAAA,GAAU+nB,YAJVC,GAA6BF,GAA7BG,8BAC6BC,GAAOJ,GAApCK,4BACAC,GAAYN,GAAZO,aACAC,GAAgBR,GAAhBS,iBAGI3T,GACJ5U,EAAAA,GADI4U,cAAe4T,GACnBxoB,EAAAA,GADmByoB,SAAUC,GAC7B1oB,EAAAA,GAD6B2oB,aAAcC,GAC3C5oB,EAAAA,GAD2Cyd,oBAGvCoL,GAAe3L,EAAAA,GAAfC,WACc2L,GAA2B/L,EAAAA,GAAzCgM,aAEFC,GAAe,CACjBC,qBAsBJ,SACI3Y,EACA4Y,GAEF,IADEhqB,EAAOzC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAG,IAAE0sB,qBAAqB,GAEzBtK,EAAwBqK,EAAxBrK,UAAWuK,EAAaF,EAAbE,SAGbC,EAAS/Y,EAAO,GAEhBgZ,EAAO,CACTnmB,EAAGkmB,EAAOvnB,QACVuB,EAAGgmB,EAAOtnB,KACVwnB,EAAGjZ,EAAO5T,QAOd,GAJA4sB,EAAKE,GAAKF,EAAKnmB,EAAImmB,EAAKjmB,GAEJomB,GAAaC,EAAKN,GAGlC,MAAM,IAAInpB,MAAM,0BAWpB,IARA,IAAM0pB,EAAeN,EAAOtkB,QAAQ/G,SAAS,UACvC0rB,EAgIV,SAA8BpZ,EAAQqZ,EAAczqB,GAChD,IAAM0qB,EAAW,GAEjB,GAAID,EAAc,CACd,IACME,EADQvZ,EAAO,GACKrS,KAAK6rB,UAAUrJ,OAEnCsJ,EAAYrB,GAAasB,SAASH,GAClC/T,EAAU8S,GAAoBqB,kBAAkBF,EAAUG,MAEhEpU,EAAQwK,MAAQsI,GAAoBuB,cAAcJ,EAAUK,MAE5DR,EAASjpB,KAAKmV,EAClB,MACI,IAAK,IAAIpX,EAAI,EAAGA,EAAI4R,EAAO5T,OAAQgC,IAAK,CACpC,IACM2rB,EADQ/Z,EAAO5R,GACKT,KAAK6rB,UAAUrJ,OACnC6J,EAAY5B,GAAasB,SAASK,GAClCE,EAAU3B,GAAoBqB,kBAChCK,EAAUJ,MAGdK,EAAQjK,MAAQsI,GAAoBuB,cAAcG,EAAUF,MAC5DR,EAASjpB,KAAK4pB,EAClB,CAGJ,IAAMC,EAAa3B,GAAW4B,mBAAmBb,GAEjD,OAAO,IAAId,GAAuB,CAAC0B,GAAatrB,EACpD,CA9JgBwrB,CAAqBpa,EAAQqZ,EAAczqB,GAEvDyrB,EAuEJ,SAAsC9L,EAAWvO,EAAQ8Y,GAIrD,IAHA,IAAMwB,EAAkB,GAClBC,EAA6B,GAE1BnsB,EAAI,EAAGA,EAAI0qB,EAAS1sB,OAAQgC,IAC7B0qB,EAAS1qB,KACTksB,EAAgBjqB,KAAKjC,GACrBmsB,EAA2BlqB,KAAK,KAIxC,IAAK,IAAI4oB,EAAI,EAAGA,EAAIjZ,EAAO5T,OAAQ6sB,IAI/B,IAHA,IACMlW,EAA2BwL,EADjBvO,EAAOiZ,GAAGxkB,SAGjB+lB,EAAI,EAAGA,EAAIF,EAAgBluB,OAAQouB,IAAK,CAC7C,IAAMC,EAASH,EAAgBE,GAG3BzX,GACAA,EAAyB2X,OACzB3X,EAAyB2X,MAAM/sB,MAC/BoV,EAAyB2X,MAAM/sB,KAAK8sB,IACpC1X,EAAyB2X,MAAM/sB,KAAK8sB,GAAQE,WAE5CJ,EAA2BC,GAAGnqB,KAAK4oB,EAE3C,CAGJ,MAAO,CACHsB,2BAAAA,EACAD,gBAAAA,EAER,CAxGQM,CAA6BrM,EAAWvO,EAAQ8Y,GAD5CyB,EAA0BF,EAA1BE,2BAA4BD,EAAeD,EAAfC,gBAGhCO,EAAiB,EAEZzsB,EAAI,EAAGA,EAAImsB,EAA2BnuB,OAAQgC,IACnDysB,GAAkBN,EAA2BnsB,GAAGhC,OAGpDgtB,EAAI0B,kBAAkBD,GAEtB,IAAK,IAAIE,EAAI,EAAGA,EAAIT,EAAgBluB,OAAQ2uB,IAAK,CAC7C,IAAMC,EAAeV,EAAgBS,GAC/BE,EAA0BV,EAA2BQ,GAGrDG,EAAyBD,EAAwBrqB,KAAI,SAAA/D,GACvD,OAAOA,EAAU,CACrB,IAEMsuB,EAAUrC,EAASkC,GAEzB5B,EAAIgC,WACAD,EACAE,GACIL,EACAC,EACA1M,EACAvO,EACAgZ,GAEJkC,EAER,CAMA,OAJA9B,EAAIkC,mBAEYhX,GAAc8U,EAAI5T,QAGtC,EAxFI6F,kBAwNJ,SAA2BE,EAAUgO,EAAanhB,GAC9C,IAAMqhB,EAAYrB,GAAasB,SAASH,GAClC/T,EAAU8S,GAAoBqB,kBAAkBF,EAAUG,MAChEpU,EAAQwK,MAAQsI,GAAoBuB,cAAcJ,EAAUK,MAC5D,IAAMI,EAAa3B,GAAW4B,mBAAmB,CAAC3U,IAE5C/P,EAAmB2C,EAAiBuW,IACtC,mBACApD,EAAS,IAGR9V,GACDmB,QAAQC,KAAK,oDAqCjB,IAlCA,IAYM0kB,EA6QV,SAA8BC,GAC1B,IAAMC,EAAe,GAMrBA,EAAa,GAAKD,EAClBC,EAAa,GAAK7D,GAAQ8D,EAAEF,GAC5BC,EAAa,GAAK7D,GAAQ+D,EAAEH,GAE5B,IAAMI,EAAQlE,GAA8B8D,EAAKvrB,KAAK+lB,GAAK,GAS3D,OAPAyF,EAAa,GAAKG,EAClBH,EAAa,GAAK7D,GAAQ8D,EAAEE,GAC5BH,EAAa,GAAK7D,GAAQ+D,EAAEC,GAE5BH,EAAa,GAAK/D,GAA8B8D,EAAKvrB,KAAK+lB,IAC1DyF,EAAa,GAAK/D,GAA8B8D,EAAK,IAAMvrB,KAAK+lB,IAEzDyF,CACX,CAlS8BI,CAZM9a,MAAMC,QAAQvL,EAAiBE,YAAW,GAAAzE,OAAA4qB,EAChErmB,EAAiBE,YAAUmmB,EAAKrmB,EAAiBC,gBACrD,CACID,EAAiBE,WAAW9C,EAC5B4C,EAAiBE,WAAW5C,EAC5B0C,EAAiBE,WAAWsjB,EAC5BxjB,EAAiBC,cAAc7C,EAC/B4C,EAAiBC,cAAc3C,EAC/B0C,EAAiBC,cAAcujB,IAMnC8C,EACF7B,EAAW6B,+BAETC,EACFD,EAA+BE,yBACzBF,EAA+BE,yBAC1BC,6BACL7vB,EAEJ8vB,EAAcjC,EAAWkC,QAAUlC,EAAWmC,KAC9CC,EAmVV,SAA4BpC,GACxB,IAAMvsB,EAAO,GAEP4uB,EAAkBrC,EAAWsC,gBAEnC,GAAIzb,MAAMC,QAAQub,GACd,IAAK,IAAI9B,EAAS,EAAGA,EAAS8B,EAAgBnwB,OAAQquB,IAClD9sB,EAAK0C,KAAKksB,EAAgB9B,SAI9B9sB,EAAK0C,KAAKksB,GAGd,MAAO,CACHE,kBACIvC,EAAWwC,yBAAyBhiB,kBACxC/M,KAAAA,EAER,CAtWwBgvB,CAAmBzC,GACjCS,EAkFV,SAAyBT,GACrB,IAAM0C,EAAU1C,EAAW2C,iBAE3B,GAAgB,WAAZD,EACA,OAAO1E,GAAS4E,OAAO5C,EAAWzJ,WAGtC,IAAMkK,EAAY,IAAI7K,WAAWoK,EAAWzJ,WAEtCwD,EAAMiG,EAAW6C,uBACjBC,OAEF3wB,IADAsuB,EAAUre,MAAK,SAAAzP,GAAO,OAAgB,IAAZA,GAAiBA,IAAYonB,CAAG,IAG9D,IAAK+I,EAID,YAHA5d,EAAAA,GAAIvI,KACA,wEASR,OAJAuI,EAAAA,GAAIvI,KACA,sEAGG8jB,CACX,CA5GsBsC,CAAgB/C,GAE5BgD,EACFhD,EAAWgD,iCAET3O,EAAY,CAAC,EAEf4O,GAAU,EAEL/uB,EAAI,EAAGA,EAAI8uB,EAAiC9wB,OAAQgC,IAAK,CAC9D,IAAMgvB,EAA2BF,EAAiC9uB,GAE5DivB,EACFrB,GACAoB,EAAyBnB,yBACpBC,wBAOHoB,EAAoBC,GALLC,IACjB,IAAI1N,WAAW6K,EAAUxK,OAAQ/hB,EAAI+tB,EAAaA,GAClD,CAACjC,EAAWmC,KAAMnC,EAAWkC,UAK7BiB,EACA9B,GAGJ,IAAK+B,EAAmB,CACpB1mB,QAAQC,KACJ,gIAEJsmB,GAAU,EACV,KACJ,CAEA,IAAMnC,EACFoC,EAAyBK,8BACpBC,wBAA0B,EAuBnCC,GACIpP,EAPYqP,GAbZ7B,EAA+B8B,yBAC/B9B,EAA+B8B,wBAC1BC,oBAGD/B,EAA+B8B,wBAC1BC,oBAAoB1vB,GAGzBgvB,EAAyBS,wBACpBC,oBAKTvS,EACAnT,GAMA4iB,EACAsC,EAER,CAEA,IAAKH,EACD,OAGJ,MAAO,CAAE5O,UAAAA,EAAW+N,YAAAA,EACxB,GAhPA,SAASjB,GACLL,EACA+C,EACAxP,EACAvO,EACAgZ,GAMA,IAJA,IAAM2B,EAAY,IAAI7K,WAAWkJ,EAAKE,GAAK6E,EAAiB3xB,QAExD4xB,EAAiB,EAEZ5vB,EAAI,EAAGA,EAAI2vB,EAAiB3xB,OAAQgC,IASzC,IARA,IAKM6vB,EAF2B1P,EADjBvO,EAFF+d,EAAiB3vB,IAEDqG,SAIDimB,MAAM/sB,KAAKqtB,GAAcL,UAE7C7pB,EAAI,EAAGA,EAAImtB,EAAe7xB,OAAQ0E,IACvC6pB,EAAUqD,GAAkBC,EAAentB,GAC3CktB,IAIR,OAAOrD,CACX,CAsCA,SAASxB,GAAaC,EAAKN,GAGvB,IAFA,IAAIoF,EAAc,EAET9vB,EAAI,EAAGA,EAAI0qB,EAAS1sB,OAAQgC,IAC7B0qB,EAAS1qB,IACT8vB,IAIR,OAAOA,CACX,CAkNA,SAASP,GACLpP,EACA9Z,EACAumB,EACAmD,GAEK5P,EAAU9Z,GAIH8Z,EAAU9Z,GAASimB,MAGnBnM,EAAU9Z,GAASimB,MAAM/sB,OACjC4gB,EAAU9Z,GAASimB,MAAM/sB,KAAO,KAHhC4gB,EAAU9Z,GAASimB,MAAQ,CAAC,EAC5BnM,EAAU9Z,GAASimB,MAAM/sB,KAAO,KALhC4gB,EAAU9Z,GAAW,CAAC,EACtB8Z,EAAU9Z,GAASimB,MAAQ,CAAC,EAC5BnM,EAAU9Z,GAASimB,MAAM/sB,KAAO,IAQpC4gB,EAAU9Z,GAASimB,MAAM/sB,KAAKqtB,GAAgB,CAAC,EAE/C,IAAMoD,EAAa7P,EAAU9Z,GAASimB,MAAM/sB,KAAKqtB,GAEjDoD,EAAWzD,UAAY,IAAI7K,WAAWqO,EAAYxwB,KAAKvB,QAIvD,IAFA,IAAMiyB,EAAkBD,EAAWzD,UAE1B7pB,EAAI,EAAGA,EAAIutB,EAAgBjyB,OAAQ0E,IACpCqtB,EAAYxwB,KAAKmD,GACjButB,EAAgBvtB,GAAK,EAErButB,EAAgBvtB,GAAK,CAGjC,CAWA,SAAS8sB,GACLE,EACAvS,EACAnT,GAEA,IAAQZ,EACJsmB,EADItmB,yBAA0BN,EAC9B4mB,EAD8B5mB,sBAGlC,OAAOA,EAqDX,SACIuU,EACAzU,EACAuU,EACAnT,GAEA,IAAM3D,EAAU8W,EAASjP,MAAK,SAAA7H,GAC1B,IAAMqa,EAAkB1W,EAAiBuW,IACrC,kBACAla,GAEJ,GAAKqa,EAAL,CAIA,IAAMwP,EAAqB9d,OAAO/L,EAAQS,MAAM,UAAU,IAE1D,OAEI4Z,EAAgBE,iBAAmBvD,GACnC6S,IAAuBtnB,EAAc,CAPzC,CASJ,IAEA,OAAOvC,CACX,CA7EU8pB,CACI/mB,EACAN,EACAqU,EACAnT,GAmBd,SACIqT,EACAF,EACAnT,GAEA,OAAOmT,EAASjP,MAAK,SAAA7H,GACjB,IAAMqa,EAAkB1W,EAAiBuW,IACrC,kBACAla,GAEJ,GAAKqa,EAIL,OAAOA,EAAgBE,iBAAmBvD,CAC9C,GACJ,CAjCU+S,CACIhnB,EACA+T,EACAnT,EAEd,CAyGA,SAASmlB,GAA6BY,EAAa3C,EAAKC,GACpD,OAAIgD,GAAWjD,EAAKC,EAAa,IAEtB0C,EACAM,GAAWjD,EAAKC,EAAa,IAE7B3D,GAAa6D,EAAEwC,GACfM,GAAWjD,EAAKC,EAAa,IAE7B3D,GAAa4D,EAAEyC,GACfM,GAAWjD,EAAKC,EAAa,IAE7BzD,GAAiBmG,GACjBM,GAAWjD,EAAKC,EAAa,IAE7B3D,GAAa4D,EAAE1D,GAAiBmG,IAChCM,GAAWjD,EAAKC,EAAa,IAE7B3D,GAAa6D,EAAE3D,GAAiBmG,IAChCM,GAAWjD,EAAKC,EAAa,IAE7BzD,GAAiBA,GAAiBmG,IAClCM,GAAWjD,EAAKC,EAAa,IAE7BzD,GACHA,GAAiBA,GAAiBmG,UAHnC,CAMX,CAEA,IC5kBKO,GD4kBCC,GAAK,KAUX,SAASF,GAAWG,EAAMC,GACtB,OACI5uB,KAAKuG,IAAIooB,EAAK,GAAKC,EAAK,IAAMF,IAC9B1uB,KAAKuG,IAAIooB,EAAK,GAAKC,EAAK,IAAMF,IAC9B1uB,KAAKuG,IAAIooB,EAAK,GAAKC,EAAK,IAAMF,IAC9B1uB,KAAKuG,IAAIooB,EAAK,GAAKC,EAAK,IAAMF,IAC9B1uB,KAAKuG,IAAIooB,EAAK,GAAKC,EAAK,IAAMF,IAC9B1uB,KAAKuG,IAAIooB,EAAK,GAAKC,EAAK,IAAMF,EAEtC,EC/lBA,SAAKD,GAIDA,EAAA,2EACH,CALD,CAAKA,KAAAA,GAKJ,KAED,IAAAI,GAAeJ,GCGfK,GAMIrvB,EAAAA,GAAU+nB,YALVE,GAA6BoH,GAA7BpH,8BAC6BqH,GAAOD,GAApClH,4BACAE,GAAYgH,GAAZhH,aACAE,GAAgB8G,GAAhB9G,iBACAgH,GAAWF,GAAXE,YAGIC,GACJvxB,EAAAA,GADIuxB,cAAeC,GACnBxxB,EAAAA,GADmBwqB,SAAUE,GAC7B1qB,EAAAA,GAD6B0qB,aAAc+G,GAC3CzxB,EAAAA,GAD2Cwf,oBAGvCkS,GAAezS,EAAAA,GAAfC,WACcyS,GAA2B7S,EAAAA,GAAzCgM,aAER8G,GAA2B7vB,EAAAA,GAAU8vB,YAA7BC,GAAMF,GAANE,OAAQC,GAAMH,GAANG,OASVC,GAAqC,CACvC9G,qBAAqB,EACrB+G,WAAW,GAgCf,SAASC,GAAiBC,EAAcC,GAepC,IAfwE,IAAlBC,EAAW7zB,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,CAAC,EAC/DyC,EAAUE,OAAOqU,OACnB,CAAC,EACDwc,GACAK,GAIEC,EAAclf,MAAMC,QAAQ+e,GAC5BA,EACA,CAACA,GAEHG,EAAiB,EACfC,EAA8B,GAAGC,EAAA,WAYnC,IALA,IAAMC,EAAaJ,EAAYK,GACvBC,EAA0BF,EAA1BE,YAAa/xB,EAAa6xB,EAAb7xB,SAEf+rB,EAA6B,GAE1BnsB,EAAI,EAAGA,EAAII,EAASpC,OAAQgC,IAC7BI,EAASJ,KACTmsB,EAA2BnsB,GAAK,IAIxC,IAFC,IAAAoyB,EAAA,SAAAzF,GAGG,IAAM0F,EAAaF,EAAYxF,GAE3BwF,EAAYxF,IACmB0F,EAAvBC,mBAEW1xB,SAAQ,SAAAgsB,GACF,IAAjBA,IACAT,EAA2BS,GAAc3qB,KAAK0qB,GAC9CmF,IAER,G,EAXCnF,EAAI,EAAGA,EAAIwF,EAAYn0B,OAAQ2uB,IAAGyF,EAAAzF,GAe3CoF,EAA4BG,GAAiB/F,C,EA9BzC+F,EAAgB,EACpBA,EAAgBL,EAAY7zB,OAC5Bk0B,IAAeF,IA+BnBN,EAAahF,kBAAkBoF,GAE/B,IACI,IAAIS,EAAgB,EACpBA,EAAgBV,EAAY7zB,OAC5Bu0B,IAQA,IANA,IAAMpG,EACF4F,EAA4BQ,GAE1BN,EAAaJ,EAAYU,GACvBnyB,EAAa6xB,EAAb7xB,SAGAwsB,EAAe,EACnBA,EAAeT,EAA2BnuB,OAC1C4uB,IACF,CACE,IAAMC,EACFV,EAA2BS,GAE/B,GAAIC,EAAyB,CAEzB,IAAMC,EAAyBD,EAAwBrqB,KACnD,SAAA/D,GACI,OAAOA,EAAU,CACrB,IAEE+zB,EAAkBpyB,EAASwsB,GAC3B6F,EAAYC,GACdT,EACApF,GAGJ6E,EAAaiB,uBACTH,EACAC,EACA7F,EACAE,EAER,CACJ,CAEJ,GAAItsB,EAAQgxB,UAAW,CACnB,IAAMoB,EAAmBvB,GACrBK,EAAata,QAAQiL,UACrByP,EACAJ,EAAata,QAAQ6W,KACrByD,EAAata,QAAQ4W,SAMzB0D,EAAamB,gBAAgB,CACzBC,cAAe,IACfC,WAAY,IACZC,QAAS,IACTvE,iBAAkB,aAClBwE,2BAA4B,cAC5BtE,uBAAwB,QAG5B+C,EAAata,QAAQwK,MAAMK,kBAAoB,CAC3CH,MAAO,CAAC,uBACRE,GAAI,MAER0P,EAAata,QAAQgL,OAAOC,UAAY,KACxCqP,EAAata,QAAQiL,UAAYuQ,CACrC,MAEIlB,EAAaxE,mBAGjB,IAAMnL,EAASmR,EAAAA,GAAOC,KAAKrC,GAAcY,EAAata,SAASgc,SAG/D,OAFgB,IAAIC,KAAK,CAACtR,GAAS,CAAE7U,KAAM,qBAG/C,CAEA,SAASwlB,GACLT,EACApF,GAMA,IAJA,IAAQsF,EAAgBF,EAAhBE,YAEFM,EAAY,GAETzyB,EAAI,EAAGA,EAAI6sB,EAAwB7uB,OAAQgC,IAAK,CACrD,IAAMszB,EAAQzG,EAAwB7sB,GAEtCyyB,EAAUxwB,KAAKkwB,EAAYmB,GAAO/G,UACtC,CAEA,OAAOkG,CACX,CAwbA,SAAAc,K,MA7KC,O,EA6KDC,IAAAC,MAhYA,SAAAC,EACIvW,EACAgO,EACAnhB,EACAxJ,GAAO,IAAAmzB,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAA/I,EAAAjU,EAAA0U,EAAAzkB,EAAAiZ,EAAAhU,EAAAwhB,EAAAX,EAAAY,EAAAG,EAAA3B,EAAA8H,EAAAzB,EAAAvJ,EAAAiL,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAA,OAAAvB,IAAAwB,MAAA,SAAAC,GAAA,cAAAA,EAAAC,KAAAD,EAAAE,MAAA,OAgD8D,GAhD9DxB,EASHnzB,EANAozB,gBAAAA,OAAkB,IAAHD,GAAQA,EAAAE,EAMvBrzB,EALAszB,UAAAA,OAAS,IAAAD,EAAG,KAAIA,EAAAE,EAKhBvzB,EAJAwzB,sBAAAA,OAAwB,IAAHD,EAAGrS,WAAUqS,EAAAE,EAIlCzzB,EAHA0zB,iBAAAA,OAAgB,IAAAD,EAAG,MAASA,EAC5BE,EAEA3zB,EAFA2zB,YACAC,EACA5zB,EADA4zB,aAEE/I,EAAYpB,GAAaqB,SAASH,IAClC/T,EAAU4Z,GAAoBzF,kBAAkBF,EAAUG,OACxD5J,MAAQoP,GAAoBvF,cAAcJ,EAAUK,MACtDI,EAAamF,GAAWlF,mBAAmB,CAAC3U,IAE5C/P,EAAmB2C,EAAiBuW,IACtC,mBACApD,EAAS,IAGPmD,EAAsBtW,EAAiBuW,IACzC,sBACApD,EAAS,IAGP7Q,EAAoBgU,EAAoBG,kBAEzCpZ,GACDmB,QAAQC,KAAK,oDAGXqlB,EAA0Bnb,MAAMC,QAAQvL,EAAiBE,YAAW,GAAAzE,OAAA4qB,EAChErmB,EAAiBE,YAAUmmB,EAAKrmB,EAAiBC,gBACrD,CACID,EAAiBE,WAAW9C,EAC5B4C,EAAiBE,WAAW5C,EAC5B0C,EAAiBE,WAAWsjB,EAC5BxjB,EAAiBC,cAAc7C,EAC/B4C,EAAiBC,cAAc3C,EAC/B0C,EAAiBC,cAAcujB,GAInCsC,EAAoBiI,GAAqBtH,GAEzCC,EAAcjC,EAAWkC,QAAUlC,EAAWmC,KAC9CC,EAAcmH,GAAmBvJ,EAAYxf,GAOzB,wBALAwf,EAAWlK,MAAMK,kBAAkBH,MAAM,GAKpB,CAAAmT,EAAAE,KAAA,SASzC,GARIvC,EAAmBjgB,MAAMC,QAAQkZ,EAAWzJ,WAC5CyJ,EAAWzJ,UACX,CAACyJ,EAAWzJ,WAElBkK,EAAY+E,GACRsB,EACA9G,EAAWmC,KACXnC,EAAWkC,SAGe,IAA1BlC,EAAWiH,WAAgB,CAAAkC,EAAAE,KAAA,SAC6B,OAAxD3sB,QAAQC,KAAK,2CAA2CwsB,EAAAK,OAAA,kBAM5DjB,EAAkB,CAAC9H,GAAW0I,EAAAE,KAAA,iBAEsC,GAApEd,EAAkBkB,GAAgBzJ,EAAY,CAAEoI,iBAAAA,IAE1B,CAAFe,EAAAE,KAAA,eACV,IAAI5zB,MAAM,kDAAiD,QAInE8nB,EAAcmM,GAChB1J,EACAqB,EACA,CAAC9lB,EAAiBhE,KAAMgE,EAAiBjE,QAAS+Z,EAASnf,QAC3D81B,GAMEQ,EAAwBnX,EAASsY,QAAO,SAACC,EAAKrvB,GAMhD,OADAqvB,EAJ2B1rB,EAAiBuW,IACxC,qBACAla,GAFIgX,gBAIchX,EACfqvB,C,GACR,CAAC,GAEAnB,GAAc,EACbX,IACDW,EAAcoB,GACVtB,EACAvI,EACA3O,EACAgQ,EACAnjB,EACA8pB,EACAE,EACAM,IAEPW,EAAAW,GAIOvM,EAAW4L,EAAAE,KACV,WADUF,EAAAW,GACF,GAOR,kBAPQX,EAAAW,GAOO,GAKf,YALeX,EAAAW,GAKN,oBAPT,OAHGpB,EADAD,EACiBsB,GAEAC,GACpBb,EAAAK,OAAA,0BAIK,IAAI/zB,MACN,+FACH,cAEK,IAAIA,MACN,4FACH,QAiC6B,OAxBhCkzB,EAAuB,IACR,GAAK,GACpBC,EAAkB,GAElBC,EACF5G,EAAc5Q,EAASnf,OAASg2B,EAAsB+B,mBACpDnB,EAAsB,IACR,GAAK,IAAIoB,YAAYrB,GAInCE,EAAc1X,EAASsY,QACzB,SAACC,EAAKO,EAAMxzB,GAGR,OAFAizB,EAAIQ,QAAQD,GAAQxzB,EACpBizB,EAAIt1B,SAAS61B,GAAQjsB,EAAiBuW,IAAI,WAAY0V,GAC/CP,CACX,GACA,CAAEQ,QAAS,CAAC,EAAG91B,SAAU,CAAC,IAOxB00B,EAAuB,IAAIqB,IAAKlB,EAAAE,KAAA,GAEhCX,EACFE,EACAD,EACAG,EACAP,EACAvI,EACA3O,EACAgQ,EACAnjB,EACA8pB,EACAE,EACAc,EACAR,EACAO,EACAV,EACAC,GACH,QAgBE,OAbGW,EAAc,IAAIoB,IAExBrB,EAAqBl0B,SAAQ,SAACw1B,EAAyBxJ,GACnD,IAAAyJ,EAAoCC,GAChCF,EACAtK,GAFIyK,EAAIF,EAAJE,KAAMC,EAAIH,EAAJG,KAAMC,EAAIJ,EAAJI,KAAMC,EAAKL,EAALK,MAK1B3B,EAAY4B,IAAI/J,EAAc,CAC1BnoB,EAAG5C,KAAK+0B,MAAML,EAAOG,GACrB/xB,EAAG9C,KAAK+0B,MAAMJ,EAAOE,GACrB7L,EAAGhpB,KAAK+0B,MAAMH,EAAOC,IAE7B,IAAGzB,EAAAK,OAEI,UACHV,oBAAAA,EACA1G,YAAAA,EACAwG,gBAAAA,EACAD,qBAAAA,EACAoC,UAAW9B,IACd,yBAAAE,EAAA6B,OAAA,GAAApD,E,IA8KLH,G,8KA7KCA,GAAAwD,MAAA,KAAAh5B,UAAA,CAwLD,SAASi5B,GACLlL,EACAmL,EACA9Z,EACAnT,EACA8pB,EACAQ,GAEA,IAAIjuB,OAAUpI,EAEd,IAAK6tB,EACD,OAAOzlB,EAGX,IACI2C,EAIA8iB,EAJA9iB,oBACA8lB,EAGAhD,EAHAgD,iCACAY,EAEA5D,EAFA4D,oBACApB,EACAxC,EADAwC,yBAGJ,IACKQ,GAC2C,IAA5CA,EAAiC9wB,OAEjC,OAAOqI,EAGX,IAAM6wB,EACFpI,EAAiCmI,GAErC,IAAKC,EACD,OAAO7wB,EAGX,IAAI8wB,OAA2Bl5B,EAC/B,GAAIyxB,GAAsD,IAA/BA,EAAoB1xB,OAC3Cm5B,EAA2BzH,EAAoBuH,QAC5C,GAAIC,EAAwBzH,wBAAyB,CACxD,IAAIA,EACAyH,EAAwBzH,wBACxB9c,MAAMC,QAAQ6c,KAEVA,EADmC,IAAnCA,EAAwBzxB,OACEyxB,EAAwB,QAExBxxB,GAI9BwxB,IACA0H,EACI1H,EAAwBC,oBACxB/c,MAAMC,QAAQukB,KAEVA,EADoC,IAApCA,EAAyBn5B,OACEm5B,EAAyB,QAEzBl5B,GAI3C,EAEIk5B,IACA9wB,EAmsBR,SACIqpB,EACA4E,GAEA,IAAQlrB,EACJsmB,EADItmB,yBAA0BN,EAC9B4mB,EAD8B5mB,sBAGlC,OAAOA,EAkFX,SACIuU,EACAzU,EACA0rB,GAEA,IAAMjuB,EAAUiuB,EAAsBjX,GAEtC,IAAKhX,EACD,OAGJ,IAAM6pB,EAAqB9d,OAAO/L,EAAQS,MAAM,UAAU,IAE1D,OAAOopB,IAAuBtnB,EAAc,EAAIvC,OAAUpI,CAC9D,CA/FUm5B,CACIhuB,EACAN,EACAwrB,GAEJA,EAAsBlrB,EAChC,CAjtBkBiuB,CACNF,EACA7C,SAIQr2B,IAAZoI,GAAyBioB,KAOzBjoB,EAktBR,SACIixB,EACAtuB,EACAkuB,EACA/Z,EACAnT,EACA8pB,GAEA,QACoC71B,IAAhCq5B,QACkDr5B,IAAlDi5B,EAAwBK,4BAC6Bt5B,IAArDi5B,EAAwBK,sBAAsB,SAEhBt5B,IAD9Bi5B,EAAwBK,sBAAsB,GACzCC,qBAEL,OAGJ,IACI,IAAIC,EAAiB,EACrBA,EAAiBta,EAASnf,SACxBy5B,EACJ,CACE,IAAMC,EAAsB1tB,EAAiBuW,IACzC,WACApD,EAASsa,IAGb,QAC4Bx5B,IAAxBy5B,QAC6Cz5B,IAA7Cy5B,EAAoBF,sBACpBE,EAAoB1uB,sBAAwBA,GAC5C0uB,EAAoBprB,oBAChBgrB,GAMJK,GACIT,EAAwBK,sBAAsB,GACzCC,qBACLE,EAAoBF,qBACpB1D,GAGJ,OAAO3W,EAASsa,EAExB,CACJ,CAnwBkBG,EANuBjlB,MAAMC,QAAQ0b,GACzCA,EAAyB,GACzBA,GAEuBhiB,kBAIzBtD,EACAkuB,EACA/Z,EACAnT,EACA8pB,IAIR,OAAOztB,CACX,CAOA,SAASsvB,GACLpJ,EACAT,EACA3O,EACAgQ,EACAnjB,EACA8pB,EACAE,EACAM,GAEA,IACI3G,EAKA7B,EALA6B,+BACAmB,EAIAhD,EAJAgD,iCACAV,EAGAtC,EAHAsC,gBACAH,EAEAnC,EAFAmC,KACAD,EACAlC,EADAkC,QAIJ,GADmBI,EAAgBpwB,OAChB,EACf,OAAO,EAkBX,IAfA,IAAM4vB,EACFD,EAA+BE,yBACzBF,EAA+BE,yBAC1BC,6BACL7vB,EACJ8vB,EAAcC,EAAUC,EACxB4J,EAAY/I,EAAiC9wB,OAQ/C85B,EAAuB,IAAI3B,IAAM4B,EAAA,WAGjC,QAAqB95B,IADA+5B,GAAgBlM,EAAYmL,GAM3C,OAJFzuB,QAAQC,KACJ,0DACIwuB,EACA,0BACN,WAIN,IAAM5wB,EAAU2wB,GACZlL,EACAmL,EACA9Z,EACAnT,EACA8pB,EACAQ,GAGJ,IAAKjuB,EAKC,OAJFmC,QAAQC,KACJ,oDACIwuB,EACA,KACN,WAIN,IAAMgB,EAAe9a,EAASzH,WAAU,SAAAjX,GAAO,OAAIA,IAAY4H,C,IAE/D,GAAIyxB,EAAqBI,IAAID,GAAe,CACxC,IAAIE,EAAeL,EAAqBvX,IAAI0X,GACvCE,EAAa74B,SAAS23B,KACvBkB,EAAal2B,KAAKg1B,GAClBa,EAAqBnB,IAAIsB,EAAcE,GAE/C,MACIL,EAAqBnB,IAAIsB,EAAc,CAAChB,G,EAtCvCA,EAAe,EAAGA,EAAeY,IAAaZ,EAAYc,IAwClE,IAEkDK,EAFlDC,EAAAC,EAEoBR,EAAqBS,WAAS,IAAnD,IAAAF,EAAAG,MAAAJ,EAAAC,EAAAI,KAAAC,MAGI,IAHiD,IAAzCC,EAAyC5U,EAAAqU,EAAAh2B,MAAA,GAArC,GACRw2B,EAAc,IAAI5E,EAAsBjG,GAAa8K,KAAK,GAErD74B,EAAI,EAAGA,EAAI24B,EAAK36B,SAAUgC,EAAG,CAClC,IAAM84B,EAAeH,EAAK34B,GAEpBgvB,EACFF,EAAiCgK,GAE/B7J,EACFrB,GACAoB,EAAyBnB,yBACpBC,wBAEHiL,EAAOC,GACTzM,EACAuM,EAAe/K,EACfA,GAKEmB,EAAoB+J,GAFL7J,IAAQ2J,EAAM,CAAC9K,EAAMD,IAItCiB,EACA9B,EACA2G,GAGJ,GAAK5E,GAQL,IADA,IAAM3vB,EAAO2vB,EAAkB3vB,KACtB0S,EAAI,EAAGinB,EAAM35B,EAAKvB,OAAQiU,EAAIinB,IAAOjnB,EAC1C,GAAgB,IAAZ1S,EAAK0S,KACL2mB,EAAY3mB,KACR2mB,EAAY3mB,GAAK,GACjB,OAAO,OAXfzJ,QAAQC,KACJ,8HAcZ,CACH,OAAA0wB,GAAAd,EAAAe,EAAAD,EAAA,SAAAd,EAAAgB,GAAA,CAED,OAAO,CACX,CAEA,SAASxD,GACLnB,EACAD,EACAG,EACArI,EACAT,EACA3O,EACAgQ,EACAnjB,EACA8pB,EACAE,EACAc,EACAR,GAqCA,IAnCA,IACI3G,EAIA7B,EAJA6B,+BACAmB,EAGAhD,EAHAgD,iCACAb,EAEAnC,EAFAmC,KACAD,EACAlC,EADAkC,QAGEJ,EACFD,EAA+BE,yBACzBF,EAA+BE,yBAC1BC,6BACL7vB,EACJ8vB,EAAcC,EAAUC,EACxB0G,EACF5G,EAAc5Q,EAASnf,OAASg2B,EAAsB+B,kBAEtDuD,EAAI,EAGJ/oB,EAAI,EAGJgpB,EAAa3E,EAAoBrkB,GAAG0E,MAAM,GAG1CukB,EAAsBC,IAAUhF,EAAqBlkB,IASrDmpB,EAAe5N,EAAWsC,gBAAgBpwB,OAEtC27B,EAAwB,EAC5BA,GAAyBD,IACvBC,EACJ,CACE,IADF,IAAAC,EAAA,SAAAxN,GAMM,IAAM4C,EACFF,EAAgC1C,GAE9BQ,EAAeoL,GAAgBlM,EAAUM,GAC/C,QAAqBnuB,IAAjB2uB,EACA,MAAM,IAAIrrB,MACN,wEAIR,GAAIqrB,IAAiB+M,EAAuB,OAAA35B,EAAAosB,EAAA,WAI5C,IAAM6C,EACFrB,GACAoB,EAAyBnB,yBACpBC,wBAKHiL,EAAOC,GACTzM,EACAH,EAAI2B,EACJA,GAKEmB,EAAoB+J,GAFL7J,IAAQ2J,EAAM,CAAC9K,EAAMD,IAItCiB,EACA9B,EACA2G,GAGJ,IAAK5E,EACD,MAAM,IAAI3tB,MACN,yIAKR,IAAM8E,EAAU2wB,GACZlL,EAAUM,EAEVjP,EACAnT,EACA8pB,EACAQ,GAGJ,IAAKjuB,EAKC,OAJFmC,QAAQC,KACJ,oDAAmD2jB,EAE/C,KACNpsB,EAAAosB,EAAA,WAIN,IAAMsL,EAAsB1tB,EAAiBuW,IACzC,WACAla,GAEJ,GACI4nB,IAASyJ,EAAoBzJ,MAC7BD,IAAY0J,EAAoB1J,QAEhC,MAAM,IAAIzsB,MACN,uLAuBR,IAjBA,IAAM02B,EAAe9a,EAASzH,WAC1B,SAAAjX,GAAO,OAAIA,IAAY4H,CAAO,IAE5BwzB,EACF9L,EACAkK,EACAjE,EAAsB+B,kBAEpB+D,EAAiB,IAAI9F,EACvBuF,EACAM,EACA9L,GAGExuB,EAAO2vB,EAAkB3vB,KAE3Bw6B,GAAiB,EACZ9nB,EAAI,EAAGinB,EAAMhK,EAAkB3vB,KAAKvB,OAAQiU,EAAIinB,IAAOjnB,EAC5D,GAAI1S,EAAK0S,GAAI,CACT,GAA0B,IAAtB6nB,EAAe7nB,GAAU,GACzB1B,GACS+oB,IACL1E,EAAoBrkB,GAAK,IAAIylB,YACzBrB,GAEJF,EAAqBlkB,GAAK,GAC1B+oB,KAEJC,EAAa3E,EAAoBrkB,GAAG0E,MAAM,GAC1CukB,EAAsBC,IAClBhF,EAAqBlkB,IAGzB6b,EAAI,EACJ,KACJ,CACI0N,EAAe7nB,GAAK2a,EACpBmN,GAAiB,CAEzB,CAGAA,IACKP,EAAoBvB,KACrBuB,EAAoBvB,GAAgB,IAGxCuB,EAAoBvB,GAAch2B,KAAK2qB,GAElC8H,EAAgBuD,KACjBvD,EAAgBuD,GAAgB,IAGpCvD,EAAgBuD,GAAch2B,KAAK2qB,IACtC5sB,EAAAosB,C,EAvIGpsB,EAAI,EAAG63B,EAAY/I,EAAiC9wB,OACxDgC,EAAI63B,IACF73B,EAAC45B,EAAA55B,GAwIP40B,EAAoBrkB,GAAKgpB,EAAWtkB,MAAM,GAC1Cwf,EAAqBlkB,GAAKkpB,IAAUD,GAIpCD,EAAa3E,EADbrkB,EAAI,GACgC0E,MAAM,GAC1CukB,EAAsBC,IAAUhF,EAAqBlkB,GACzD,CACJ,CAEA,IAAMynB,GAAkB,SAAClM,EAAYwH,GACjC,IAAQxE,EACJhD,EADIgD,iCAAkCnB,EACtC7B,EADsC6B,+BAEpCqB,EAA2BF,EAAiCwE,GAClE,OAAOtE,GACHA,EAAyBK,8BACvBL,EAAyBK,8BACpBC,wBACL3B,EAA+B0B,8BAC/B1B,EAA+B0B,8BAC1BC,6BACLrxB,CACV,EAEA,SAAS63B,GACLpB,EACAD,EACAG,EACArI,EACAT,EACA3O,EACAgQ,EACAnjB,EACA8pB,EACAE,EACAc,EACAR,EACAO,EACAV,EACAC,GAEA,IACIzG,EAIA7B,EAJA6B,+BACAmB,EAGAhD,EAHAgD,iCACAb,EAEAnC,EAFAmC,KACAD,EACAlC,EADAkC,QAGEJ,EACFD,EAA+BE,yBACzBF,EAA+BE,yBAC1BC,6BACL7vB,EACJ8vB,EAAcC,EAAUC,EAE1BjuB,EAAI,EACF63B,EAAY/I,EAAiC9wB,OAC7Cg8B,EAAYn4B,KAAKo4B,KAAKpC,EAAY,IAElCqC,EAAqB9F,GAAgBD,EAK3C,OAAO,IAAIpd,SAAQ,SAAAojB,IACf,SAASC,IAEL,IAAK,IAAI5W,EAAM3hB,KAAKC,IAAI9B,EAAIg6B,EAAWnC,GAAY73B,EAAIwjB,IAAOxjB,EAAG,CAC7D,IAAMgvB,EACFF,EAAiC9uB,GAE/BivB,EACFrB,GACAoB,EAAyBnB,yBACpBC,wBAEHiL,EAAOC,GACTzM,EACAvsB,EAAI+tB,EACJA,GAKEmB,EAAoB+J,GAFL7J,IAAQ2J,EAAM,CAAC9K,EAAMD,IAItCiB,EACA9B,EACA2G,GAGJ,IAAK5E,EACD,MAAM,IAAI3tB,MACN,yIAKR,IAAMqrB,EAAeoL,GAAgBlM,EAAY9rB,GAEjD,QAAqB/B,IAAjB2uB,EACA,MAAM,IAAIrrB,MACN,wEAIHuzB,EAAqBoD,IAAItL,IAC1BkI,EAAqB6B,IAAI/J,EAAc,CAAC,GAG5C,IAAMvmB,EAAU2wB,GACZlL,EACA9rB,EACAmd,EACAnT,EACA8pB,EACAQ,GAGJ,GAAKjuB,EAAL,CASA,IAAMqxB,EAAsB7C,EAAYz0B,SAASiG,GACjD,GACI4nB,IAASyJ,EAAoBzJ,MAC7BD,IAAY0J,EAAoB1J,QAEhC,MAAM,IAAIzsB,MACN,uLAsBR,IAhBA,IAAM02B,EAAepD,EAAYqB,QAAQ7vB,GAEnCwzB,EACF9L,EACAkK,EACAjE,EAAsB+B,kBAEpB+D,EAAiB,IAAI9F,EACvBY,EAAoB,GACpBiF,EACA9L,GAGExuB,EAAO2vB,EAAkB3vB,KAEzB86B,EAAa,GAEXpoB,EAAI,EAAGinB,EAAMhK,EAAkB3vB,KAAKvB,OACxCiU,EAAIinB,IACFjnB,EAEF,GAAI1S,EAAK0S,GAAI,CACT,IAAK,IAAIxN,EAAIwN,EAAGxN,EAAIy0B,IAAOz0B,EACnBlF,EAAKkF,KACLq1B,EAAer1B,GAAKmoB,EACpByN,EAAWp4B,KAAKwC,IAInBiwB,EAAgBuD,KACjBvD,EAAgBuD,GAAgB,IAGpCvD,EAAgBuD,GAAch2B,KAAK2qB,GAEnC,KACJ,CAGJ,IAAM0N,EACFxF,EAAqBvU,IAAIqM,GAC7B0N,EAAmBrC,GAAgBoC,EACnCvF,EAAqB6B,IAAI/J,EAAc0N,EAxDvC,MANI9xB,QAAQC,KACJ,oDACIzI,EACA,IA4DhB,CAGA,GAAIk6B,EAAoB,CACpB,IAAMK,EAAkB14B,KAAK24B,MAAOx6B,EAAI63B,EAAa,KACrDzD,EAAaD,EAAazD,GAAO+J,2BAA4B,CACzDF,gBAAAA,GAER,CAGIv6B,EAAI63B,EACJ6C,WAAWN,EAAiB,GAG5BD,GAER,CAEAC,EACJ,GACJ,CAEA,SAAS5E,GACL1J,EACAqB,EACAwN,EACA7G,GAEA,IAAQnG,EACJ7B,EADI6B,+BAAgCmB,EACpChD,EADoCgD,iCAGlClB,EACFD,EAA+BE,yBACzBF,EAA+BE,yBAC1BC,6BACL7vB,EAGJ+wB,EAA2BF,EAAiC,GAE5D1B,EACFQ,GACAoB,EAAyBnB,yBACpBC,wBAMT,OAJgBX,EAAkBre,MAAK,SAAA8rB,GAAS,OAC5CjD,GAAcvK,EAAKwN,EAAW9G,EAAU,IAIjC,SAwBf,SAA8BtD,EAAMC,EAAMqD,GACtC,IAAM+G,EAAsBh5B,KAAKuG,IAC7BooB,EAAK,GAAKC,EAAK,GAAKD,EAAK,GAAKC,EAAK,GAAKD,EAAK,GAAKC,EAAK,IAErDqK,EAAmBj5B,KAAKuG,IAC1BooB,EAAK,GAAKC,EAAK,GAAKD,EAAK,GAAKC,EAAK,GAAKD,EAAK,GAAKC,EAAK,IAG3D,OACKoK,EAAsB/G,GACnBjyB,KAAKuG,IAAIyyB,EAAsB,GAAK/G,KACvCgH,EAAmBhH,GAChBjyB,KAAKuG,IAAI0yB,EAAmB,GAAKhH,EAE7C,CAlCQiH,CAAqB3N,EAAKD,EAAkB,GAAI2G,IAChD6G,EAAqBr7B,SAASwsB,EAAWmC,OACzC0M,EAAqBr7B,SAASwsB,EAAWkC,SAGlC,gBAGJ,SACX,CAkCA,SAASuH,GAAgBzJ,EAAYtrB,GACjC,IAEIjB,EAFEivB,EAAU1C,EAAW2C,iBAa3B,QAJaxwB,KALTsB,EADAoT,MAAMC,QAAQkZ,EAAWzJ,WAClByJ,EAAWzJ,UAAU,GAErByJ,EAAWzJ,YAIlBrR,EAAAA,GAAI8F,MAAM,6CAGE,WAAZ0X,EAIA,OAsBR,SAA2BjvB,EAAM20B,GAO7B,IANA,IAAI8G,EAAW,IAAItZ,WAAWniB,GAC1B07B,EAAS,GAETC,EAAqC,EAAnBhH,EAClBiH,EAAiBt5B,KAAKo4B,KAAwB,EAAlBe,EAASh9B,OAAck9B,GAE9Cl7B,EAAI,EAAGA,EAAIm7B,EAAgBn7B,IAAK,CACrC,IAAIo7B,EAAWp7B,EAAIk7B,EACfG,EAASx5B,KAAKC,IAAIs5B,EAAWF,EAAmC,EAAlBF,EAASh9B,QAEvDs9B,EAAYz5B,KAAK+0B,MAAMwE,EAAW,GAClCG,EAAU15B,KAAKo4B,KAAKoB,EAAS,GAE7BG,EAAQR,EAAS/lB,MAAMqmB,EAAWC,GAClCE,EAAgB1K,GAASrC,OAAO8M,GAEpCP,EAAOh5B,KAAKw5B,EAChB,CAEA,OAAOR,CACX,CA3CeS,CAAkBn8B,EAAMiB,EAAQ0zB,kBAG3C,IAAM3H,EAAY,IAAI7K,WAAWniB,GAE3BsmB,EAAMiG,EAAW6C,uBAKvB,YAFI1wB,IADAsuB,EAAUre,MAAK,SAAAzP,GAAO,OAAgB,IAAZA,GAAiBA,IAAYonB,CAAG,KAQ9D7U,EAAAA,GAAIvI,KACA,sEAGG8jB,QATP,CAUJ,CAgJA,SAAS6I,GAAqBhI,GAC1B,IAAMC,EAAe,GAMrBA,EAAa,GAAKD,EAClBC,EAAa,GAAKuD,GAAQtD,EAAEF,GAC5BC,EAAa,GAAKuD,GAAQrD,EAAEH,GAE5B,IAAMI,EAAQjE,GAA8B6D,EAAKvrB,KAAK+lB,GAAK,GAS3D,OAPAyF,EAAa,GAAKG,EAClBH,EAAa,GAAKuD,GAAQtD,EAAEE,GAC5BH,EAAa,GAAKuD,GAAQrD,EAAEC,GAE5BH,EAAa,GAAK9D,GAA8B6D,EAAKvrB,KAAK+lB,IAC1DyF,EAAa,GAAK9D,GAA8B6D,EAAK,IAAMvrB,KAAK+lB,IAEzDyF,CACX,CAWA,SAAS4L,GACLlJ,EACA3C,EACAC,EACAyG,GAEA,OAAI6D,GAAcvK,EAAKC,EAAa,GAAIyG,GAC7B/D,EACA4H,GAAcvK,EAAKC,EAAa,GAAIyG,GAIpCnK,GAAa4D,EAAEwC,GACf4H,GAAcvK,EAAKC,EAAa,GAAIyG,GAIpCnK,GAAa2D,EAAEyC,GACf4H,GAAcvK,EAAKC,EAAa,GAAIyG,GAIpCjK,GAAiBkG,GACjB4H,GAAcvK,EAAKC,EAAa,GAAIyG,GAIpCjK,GAAiBF,GAAa2D,EAAEyC,IAChC4H,GAAcvK,EAAKC,EAAa,GAAIyG,GAIpCjK,GAAiBF,GAAa4D,EAAEwC,IAChC4H,GAAcvK,EAAKC,EAAa,GAAIyG,GAGpCjK,GAAiBA,GAAiBkG,IAClC4H,GAAcvK,EAAKC,EAAa,GAAIyG,GAIpCjK,GACHA,GAAiBA,GAAiBkG,UALnC,CAQX,CAWA,SAAS4H,GAAcgE,EAAQC,EAAQ9H,GACnC,GAAI6H,EAAO39B,QAAU49B,EAAO59B,OACxB,OAAO,EAGX,IAAK,IAAIgC,EAAI,EAAGA,EAAI27B,EAAO39B,SAAUgC,EACjC,IAAK6wB,GAAY8K,EAAO37B,GAAI47B,EAAO57B,GAAI8zB,GACnC,OAAO,EAIf,OAAO,CACX,CAEA,SAASuB,GAAmBvJ,EAAYuC,GACpC,IAAMF,EAAkBrC,EAAWsC,gBAUnC,MAAO,CACHC,kBAAAA,EACA9uB,KATAoT,MAAMC,QAAQub,GACP,MAAClwB,GAAS6E,OAAA4qB,EAAKS,IAGf,MAAClwB,EAAWkwB,GAO3B,CAWA,SAAS6K,GAAuBiC,EAAQY,EAAQ79B,GAC5C,IAAM89B,EAqCV,SAAoCb,EAAQY,EAAQ79B,GAChD,IAAI+9B,EAAad,EAAOxF,QAAO,SAACuG,EAAOR,GAAK,OAAKQ,EAAQR,EAAMx9B,MAAM,GAAE,GAEvE,GAAI69B,EAAS,GAAKA,EAAS79B,EAAS+9B,EAChC,MAAM,IAAIx6B,MAAM,mCAGpB,IAAI06B,EAAkB,EAClBC,EAAqBL,EAEzB,KAAOK,GAAsBjB,EAAOgB,GAAiBj+B,QACjDk+B,GAAsBjB,EAAOgB,GAAiBj+B,OAC9Ci+B,IAGJ,IAAIE,EAAgBF,EAChBG,EAAmBF,EAAqBl+B,EAE5C,KAAOo+B,EAAmBnB,EAAOkB,GAAen+B,QAC5Co+B,GAAoBnB,EAAOkB,GAAen+B,OAC1Cm+B,IAGJ,MAAO,CACH5Y,MAAO,CAAE8Y,WAAYJ,EAAiBJ,OAAQK,GAC9C1Y,IAAK,CAAE6Y,WAAYF,EAAeN,OAAQO,GAElD,CAhEoBE,CAA2BrB,EAAQY,EAAQ79B,GAG3D,GAAI89B,EAAQvY,MAAM8Y,aAAeP,EAAQtY,IAAI6Y,WACzC,OAAO,IAAI3a,WACPuZ,EAAOa,EAAQvY,MAAM8Y,YAAYta,OACjC+Z,EAAQvY,MAAMsY,OACd79B,GAOJ,IAHA,IAAIu+B,EAAS,IAAI7a,WAAW1jB,GACxBw+B,EAAe,EAGXx8B,EAAI87B,EAAQvY,MAAM8Y,WACtBr8B,GAAK87B,EAAQtY,IAAI6Y,WACjBr8B,IACF,CACE,IAAIujB,EACAvjB,IAAM87B,EAAQvY,MAAM8Y,WAAaP,EAAQvY,MAAMsY,OAAS,EACxDrY,EACAxjB,IAAM87B,EAAQtY,IAAI6Y,WACZP,EAAQtY,IAAIqY,OACZZ,EAAOj7B,GAAGhC,OAEpBu+B,EAAO5F,IACH,IAAIjV,WAAWuZ,EAAOj7B,GAAG+hB,OAAQwB,EAAOC,EAAMD,GAC9CiZ,GAEJA,GAAgBhZ,EAAMD,CAC1B,CAEA,OAAOgZ,CAEf,CA+BA,SAASjG,GAAkBF,EAAyBtK,GAMhD,IALA,IAAIyK,EAAO,EACPC,EAAO,EACPC,EAAO,EACPC,EAAQ,EAEZ+F,EAAA,EAAAC,EAA4Ch8B,OAAO63B,QAC/CnC,GACHqG,EAAAC,EAAA1+B,OAAAy+B,IAAE,CAFE,IAAAE,EAAA5Y,EAAA2Y,EAAAD,GAAA,GAAOxE,EAAY0E,EAAA,GAAEC,EAAaD,EAAA,GAG7B9R,EAAIzY,OAAO6lB,GAEjB,GAAK2E,GAA0C,IAAzBA,EAAc5+B,OAApC,CAEC,IAEsC6+B,EAFtCC,EAAAxE,EAEyBsE,GAAa,IAAvC,IAAAE,EAAAtE,MAAAqE,EAAAC,EAAArE,KAAAC,MAAyC,KAA9BqE,EAAWF,EAAAz6B,MACZuC,EAAI9C,KAAK+0B,MAAMmG,EAAcjR,EAAWmC,MAG9CsI,GAFUwG,EAAcjR,EAAWmC,KAGnCuI,GAAQ7xB,EACR8xB,GAAQ5L,EAER6L,GACJ,CAAC,OAAAyC,GAAA2D,EAAA1D,EAAAD,EAAA,SAAA2D,EAAAzD,GAAA,CAXD,CAYJ,CAEA,MAAO,CAAE9C,KAAAA,EAAMC,KAAAA,EAAMC,KAAAA,EAAMC,MAAAA,EAC/B,CAEA,IAAMsG,GAAe,CACjBzS,qBAzrDJ,SAA8B3Y,EAAQ+f,GAAoC,IAAlBC,EAAW7zB,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,CAAC,EAC7DktB,EAAerZ,EAAO,GAAGvL,QAAQ/G,SAAS,UAOhD,OAAOmyB,GAoKX,SAA8B7f,EAAQqZ,EAAczqB,GAChD,IAAM0qB,EAAW,GAEjB,GAAID,EAAc,CACd,IACME,EADQvZ,EAAO,GACKrS,KAAK6rB,UAAUrJ,OAEnCsJ,EAAYpB,GAAaqB,SAASH,GAClC/T,EAAU4Z,GAAoBzF,kBAAkBF,EAAUG,MAEhEpU,EAAQwK,MAAQoP,GAAoBvF,cAAcJ,EAAUK,MAE5DR,EAASjpB,KAAKmV,EAClB,MACI,IAAK,IAAIpX,EAAI,EAAGA,EAAI4R,EAAO5T,OAAQgC,IAAK,CACpC,IACM2rB,EADQ/Z,EAAO5R,GACKT,KAAK6rB,UAAUrJ,OACnC6J,EAAY3B,GAAaqB,SAASK,GAClCE,EAAUmF,GAAoBzF,kBAChCK,EAAUJ,MAGdK,EAAQjK,MAAQoP,GAAoBvF,cAAcG,EAAUF,MAC5DR,EAASjpB,KAAK4pB,EAClB,CAGJ,IAAMC,EAAamF,GAAWlF,mBAAmBb,GAEjD,OAAO,IAAIgG,GAAuB,CAACpF,GAAatrB,EACpD,CAxMyBy8B,CACjBrrB,EACAqZ,EACA2G,GAGkCD,EAAkBC,EAC5D,EAirDI3U,kBA9+CJ,SAegCigB,EAAAC,EAAAC,EAAAC,GAAA,OAAA9J,GAAAwD,MAAC,KAADh5B,UAAA,EAg+C5Bu/B,iBAAA7L,ICjuDJ,IAAM8L,GAAgB,CAClBl4B,OAAM8d,EACNsB,YAAWA,EACXU,cAAaE,EACbsB,cAAaA,EACbgB,UAASA,EACTO,cAAaD,GACbze,kBAAiB6V,EACjBgJ,UAASE,GACTO,MAAKE,GACLG,aAAYA,IAGVqU,GAAiB,CACnBnT,aCxBiB,CACjBE,qBAgBJ,SACI3Y,EACA6rB,GAGF,IAFEj9B,EAAOzC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAG,IAAE0sB,qBAAqB,GACjCiT,EAAuB3/B,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,EAE1B,GAAgC,IAA5B2/B,EACA,OAAOV,GAAgBzS,qBACnB3Y,EACA6rB,EACAj9B,GAIR,GAAgC,IAA5Bk9B,EACA,OAAOpT,GAAgBC,qBACnB3Y,EACA6rB,EACAj9B,GAIRgI,QAAQC,KAAK,4DAAD3F,OACoD46B,EAAuB,cAE3F,EAxCIzgB,kBAwDJ,SACIE,EACAgO,EACAnhB,GAIF,IAHE4pB,EAAe71B,UAAAC,OAAA,QAAAC,IAAAF,UAAA,IAAAA,UAAA,GACf+1B,EAAS/1B,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,KACZ2/B,EAAuB3/B,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,EAE1B,GAAgC,IAA5B2/B,EACA,OAAOV,GAAgB/f,kBACnBE,EACAgO,EACAnhB,EACA4pB,EACAE,GAIR,GAAgC,IAA5B4J,EACA,OAAOpT,GAAgBrN,kBACnBE,EACAgO,EACAnhB,GAIRxB,QAAQC,KAAK,yDAAD3F,OACiD46B,EAAuB,cAExF,EApFIJ,iBA8FJ,SACI5L,EACAC,GAGF,IAFEnxB,EAAOzC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAG,IAAE0sB,qBAAqB,GACjCiT,EAAuB3/B,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,EAE1B,GAAgC,IAA5B2/B,EACA,OAAOV,GAAgBM,iBACnB5L,EACAC,EACAnxB,GAIRgI,QAAQC,KAAK,4DAAD3F,OACoD46B,EAAuB,cAE3F,ICtFWC,GAAW,WAQlB,OAPAA,GAAWj9B,OAAOqU,QAAU,SAAkB6oB,GAC1C,IAAK,IAAIpF,EAAGx4B,EAAI,EAAGy4B,EAAI16B,UAAUC,OAAQgC,EAAIy4B,EAAGz4B,IAE5C,IAAK,IAAI0C,KADT81B,EAAIz6B,UAAUiC,GACOU,OAAOm9B,UAAUC,eAAeC,KAAKvF,EAAG91B,KAAIk7B,EAAEl7B,GAAK81B,EAAE91B,IAE9E,OAAOk7B,C,EAEJD,GAAS5G,MAAMn4B,KAAMb,UAChC,EA6KO,SAASigC,GAAcC,EAAI9K,EAAM+K,GACpC,GAAIA,GAA6B,IAArBngC,UAAUC,OAAc,IAAK,IAA4BmgC,EAAxBn+B,EAAI,EAAGo+B,EAAIjL,EAAKn1B,OAAYgC,EAAIo+B,EAAGp+B,KACxEm+B,GAAQn+B,KAAKmzB,IACRgL,IAAIA,EAAKxrB,MAAMkrB,UAAU5oB,MAAM8oB,KAAK5K,EAAM,EAAGnzB,IAClDm+B,EAAGn+B,GAAKmzB,EAAKnzB,IAGrB,OAAOi+B,EAAGn7B,OAAOq7B,GAAMxrB,MAAMkrB,UAAU5oB,MAAM8oB,KAAK5K,GACtD,CC7NA,IAAAxpB,GAAe,4BCQT00B,GAAe,CACjB7yB,uBAH2B,gBAI3BJ,WAAY,CACR9F,oBARoB,wBCGpB2Y,GAA0B3c,EAAAA,GAAS2c,QAA1BE,GAAiB7c,EAAAA,GAAS6c,aAEnCG,GAAqBD,EAAAA,GAAWC,iBAEhCggB,GAAe9f,EAAAA,GAAWC,WAE1BE,GAAsDV,GAAOU,yBAAnCE,GAA4BZ,GAAOY,wBAE7DE,GAAwBxf,EAAAA,GAAIwf,oBAE9Bwf,GAAU,CAAE/yB,uBAAwB,MAAOoB,UAAW,UACtD4xB,GAAe,CAAEhzB,uBAAwB,MAAOoB,UAAW,aAC3D6xB,GAAmB,CAAEjzB,uBAAwB,MAAOoB,UAAW,UAE/D8xB,GAAiB,SAAC3vB,EAAOsM,EAAM+D,GACzB,IAAA1S,EAA4BqC,EAAKrC,wBACzC,GAAKA,EAAL,CACQ,IAAAlB,EAAsCkB,EAAuBlB,uBAArCoB,EAAcF,EAAuBE,UACrE,OACKpB,GAA0B6P,EAAK7P,wBAC5BoB,GAAayO,EAAKzO,WACrBwS,GACG5T,GAA0B4T,EAAQ5T,wBAClCoB,GAAawS,EAAQxS,SAPO,CASxC,EAoBA,SAAS+xB,GACLjqB,EACAI,EACAjM,EACA+1B,GAEA,IAAM9d,EAAehM,EAASJ,GACxBoD,EACFtO,GAAkBuX,sCAAsCrM,GAC5D,GACKoM,GACAA,EAAavhB,MACbuhB,EAAavhB,KAAKvB,QAClB8Z,EAJL,CAWA,IAAMkJ,EAAeF,EAAavhB,KAAKiD,KAAI,SAAAye,GACvC,OAvCR,SACIA,EACAvM,EACA7L,EACAiP,EACA8mB,GAEA,IAAM1d,EAAOpJ,EAAUqJ,iCACnBF,EACA2d,GAMJ,OAJA1d,EAAKrY,sBAAwBA,EAEH,IAAIiP,EAAUsJ,qBAAqBF,EAGjE,CAuBe2d,CACH5d,EACAvM,EACA7L,EACAiP,EACA8mB,EAER,IAEA,OAAO,IAAI/f,GAAwBmC,EAdlC,CAeL,CAEA,IAAAxX,GAAA,oBAAAA,IAAA,CA2WA,OArWWA,EAAmCs1B,oCAA1C,SAA2Cjf,GAC/B,IAAAkf,EAA+Blf,EAAdlQ,aAAjBA,OAAY,IAAAovB,EAAG,GAAEA,EAAErvB,EAAYmQ,EAAYnQ,QAE7CsvB,EACFX,GAA0BjzB,WAAW9F,oBAEnCmY,EAAgB9N,EAAazB,MAC/B,SAAAwP,GAAM,OAAAA,EAAG9Q,YAAcoyB,CAAjB,IAGV,OAAIvhB,EACOA,EAAc5N,YAGrBH,GAAWA,EAAQ9C,YAAcoyB,EAC1BtvB,EAAQG,iBADnB,C,EAKGrG,EAAAy1B,oBAAP,WAII,IAAMxd,EAAkC,IAAIC,WAAW,GAwBvD,OAvBAD,EAAgC,GAAK,EAEvB,CACVI,2BAA4B,CACxBC,MAAO,CAACL,EAAgCM,QACxCC,GAAI,MAIRC,kBAAmB,CACfH,MAAO,CAAC,uBACRE,GAAI,MAERE,uBAAwB,CACpBJ,MAAO,CAAC/C,GAAoBzU,OAC5B0X,GAAI,MAERG,0BAA2B,CACvBL,MAAO,CAAC,SACRE,GAAI,M,EAuBTxY,EAAuB6Z,wBAA9B,SACItY,EACAm0B,EACA9+B,EACAsU,GAEQ,IAAA3G,EAAoBhD,EAAgBgD,gBAEtCyR,EAAqBjD,EAAQxO,GAC7B0R,EAAeD,EAAmBtR,MAAK,SAAAa,GACzC,OAAA2vB,GAAe3vB,EAAOwvB,GAAtB,IAEE7e,EACFF,EAAmBngB,QAAO,SAAA0P,GACtB,OAAA2vB,GAAe3vB,EAAOyvB,GAAcC,G,KACnC,GACH9e,EAAWH,EAAmBtR,MAChC,SAAAa,GAAS,MAAoB,QAApBA,EAAMC,SAAN,IAEP4Q,EAAcrD,EAAQoD,EAAS5R,iBAAiBG,MAClD,SAAAa,GAAS,MAAoB,WAApBA,EAAMC,SAAsB,IAEjCnG,EAA0B+W,EAAY7R,gBAAelF,sBACrDO,EACJP,EAAqBO,yBADSN,EAC9BD,EAAqBC,sBAEnB3I,EACF++B,EAA2B91B,GACzB/B,EAAmBjH,EAASmgB,IAC9B,mBACApgB,GAGEuP,EAAU+P,EACVtB,GAAasB,EAAa7P,0BAC1B3R,EACA0R,EAAe+P,EAAkBld,KAAI,SAAAwd,GACvC,OAAO7B,GAAa6B,EAAIpQ,oBAC5B,IAEMiQ,EAAe,CACjBI,iBAAahiB,EACbof,eAAgBjU,EAChBzK,WAAY,CACRsB,cAAe8e,GAAoBzU,MACnClK,SAAU,CACNN,SAAU4U,EACVvU,kBAAiBA,EACjB6I,oBAAqB3B,EAAiB4B,oBACtC9G,MAAO,IAEX5C,UAAMtB,GAEVyR,QAAOA,EACPC,aAAYA,GAShB,OAPIkQ,EAAanQ,UACbmQ,EAAaI,YAAcJ,EAAanQ,QAAQG,aAGpDgQ,EAAalhB,WAAWyB,SAAS+B,MAC7BqH,EAAkBs1B,oCAAoCjf,GAEnD,CACHA,aAAYA,EACZF,SAAQA,EACRC,YAAWA,EACX/W,sBAAqBA,EACrBO,yBAAwBA,EACxBN,sBAAqBA,E,EAItBU,EAAcuM,eAArB,SACIoK,EACAnW,EACA40B,EACAp+B,GAIA,IAAI4f,EAAuB,GASrB+e,EAAwC,CAAC,EACzCC,EAA2B,GAE3Bxd,EAAQpY,EAAkBy1B,sBAGhCv+B,OAAOC,KAAKwf,GAAWvf,SAAQ,SAAAyF,GAC3B,IAAMqa,EAAkB1W,EAAiBuW,IACrC,kBACAla,GAEE4F,EAAWjC,EAAiBuW,IAAI,WAAYla,GAE1Cua,EAAgCF,EAAeE,eAA/BD,EAAgBD,EAAeC,YAC5BF,EAAsBxU,EAAQK,kBAKzD,GAHA6yB,EAAsCve,GAClCH,GAGC2e,EAAyBlxB,MACtB,SAAAmxB,GAAO,OAAAA,EAAI/yB,oBAAsBmU,CAA1B,IAEb,CAEE,IAAMkB,EACFnY,EAAkB81B,gCAAgCrzB,GAEtDmzB,EAAyBn9B,KAAK0f,EACjC,CAED,IAAM/Y,EAAcoB,EAAiBuW,IAAI,cAAela,GAClDyO,EAAWqL,EAAU9Z,GACrBkP,EAAY7U,OAAOC,KAAKmU,GAExBjM,EAAwB,CAC1BwF,sBAAuBsS,EACvBvX,yBAA0BwX,EAC1B9X,2BAAuB7K,IAItBgO,GACGA,EAASwgB,gBACTxgB,EAASwgB,eAAiB,GAC9B6R,GAAWzd,wBAAwBF,MAEnC9X,EAAsBC,sBAAwBF,GAIlD,IAAM6T,EAAoB,GAE1BlH,EAAU3U,SAAQ,SAAA8T,GACd,IAAM3F,EAAQ4vB,GACVjqB,EACAI,EACAjM,EACA+1B,GAEA7vB,GACA0N,EAAkBxa,KAAK8M,EAE/B,IAEAqR,EACIA,EAAqBtd,OAAO2Z,EACpC,IAEA,IAAM8iB,EAA2B,IAAI5gB,GACjC,CAAE6C,yBAA0BpB,GAC5B5f,GAGE2W,EAAS,IAAImH,GAAiB8gB,EAA0B5+B,GAExDsc,EAAcyiB,EAAyBziB,YACzCsiB,EAAwBzB,GAAAA,GAAA,GACnBn9B,GAAO,CAAE2+B,sCAAqCA,KAOvD,OAHAhoB,EAAOC,QAAU1W,OAAOqU,OAAOoC,EAAOC,QAAS0F,GAC/C3F,EAAOC,QAAQwK,MAAQA,EAEhBzK,C,EAMJ3N,EAAiByT,kBAAxB,SACI7F,EACA8nB,EACAM,EACAp/B,EACAkiB,GAGA,GAA2D,SAAvDlL,EAAQmL,wBAAwBC,mBAChC,MAAM,IAAIjhB,MACN,+DAIR,IAKM+a,EAA4BC,EAAQnF,EAAQrJ,iBAAiBG,KAC/DsO,EANW,yBAUTC,EAAoBF,EACtBD,EAA0BvO,iBAC5B1O,OAAOmd,EAXK,sBAcRhW,EAAkB,CAAC,EAEnBkW,EACFlT,EAAkBC,yCAEhBkT,EAAwB,GA2D9B,OAzDAjc,OAAOC,KAAK+b,GAAwB9b,SAAQ,SAAAiQ,GACxC8L,EAAsB1a,KAAKya,EAAuB7L,IAClDrK,EAAgBqK,GAAO,EAC3B,IAEA4L,EAAkB7b,SAAQ,SAAAgc,G,MACtB,IACI,IAWM6iB,EAXkCljB,EACpCK,EAAiB7O,iBAIeG,MAC5B,SAAA4O,GACI,MAlCQ,wBAkCRA,EAAYpQ,wBAAwBmD,WAApC,IAKgBP,UAEtBwI,GAEE,QADJinB,EAAAzc,aAAK,EAALA,EAAOI,oBACH,IAAAqc,OAAA,EAAAA,EAAAhB,KAAAzb,EAAA1F,EACAxF,EACAuF,KAEJA,EAAsBzO,MAAK,SAAAyU,GACvB,OAAAA,EAAGhS,qCACC8uB,EADJ,IAKR,GAAI3nB,EAAW,CACX,IAAM1R,EAAc0R,EAAU8K,mBAC1BhG,EACAsiB,EACAM,EACAp/B,GAGJoI,QAAQwI,IAAI,OAAAlO,OAAOgV,EAAUpD,SAAc,SAC3ClM,QAAQwI,IAAI5K,GAEZI,EAAgBsR,EAAUpD,UAAUzS,KAAKmE,EAC5C,CACJ,CAAC,MAAOgzB,GACL5wB,QAAQC,KACJ,oCACAmU,EACAwc,EAEP,CACL,IAIO5yB,C,EAOGgD,EAAY8a,aAA1B,SAA2BxM,GACvBtO,EAAkBC,yCACdqO,EAAU+K,iBACV/K,EACJtO,EAAkBuX,sCACdjJ,EAAUpD,UACVoD,EACJtO,EAAkBsZ,wBAAwBhL,EAAUpD,UAChDoD,EAAU+K,e,EAxWJrZ,EAAkBG,mBAAGA,GACrBH,EAAuBsZ,wBAAG,CAAC,EAC3BtZ,EAAwCC,yCAAG,CAAC,EAC5CD,EAAqCuX,sCAAG,CAAC,EAoDhDvX,EAA+B81B,gCAAG,SAAArzB,GACrC,IAIM2V,EAAQpY,EAAkBy1B,sBAQhC,OAN6BtB,GAAAA,GAAA,GACtB1xB,GAAQ,CACX2V,MAAOA,EACPQ,OATW,CACXC,UAAW,OAYnB,EAqSH7Y,CAAA,CA3WD,GC/Eek2B,GAAgBp+B,EAAAA,GAAU2hB,OAAjC6E,MAEF6X,GAAiB,gBACjBC,GAA8B,GAAH98B,OAAM6G,GAAkB,KAAA7G,OAAI68B,IAErDv0B,GAAuCizB,GAAvCjzB,WAAYI,GAA2B6yB,GAA3B7yB,uBAEd0c,GAAa,oBAAAA,IAAA5I,EAAA,KAAA4I,EAAA,CAwHd,OAxHc3I,EAAA2I,EAAA,OAAArX,IAAA,qBAAAzO,MACf,SACI2I,EACAm0B,EACAM,EACAp/B,GAkBA,IAhBA,IAAAgjB,EACI5Z,GAAkB6Z,wBACdtY,EACAm0B,EACA9+B,EACA8nB,EAAcxT,UALdmL,EAAYuD,EAAZvD,aAAcD,EAAWwD,EAAXxD,YAAa9W,EAAqBsa,EAArBta,sBAQ7B3I,EACF0f,EAAalhB,WAAWyB,SAASD,kBAE/Bmb,EAAOuE,EAAalhB,WAAWyB,SAAS+B,MAEtCwE,EAAgBiZ,EAAhBjZ,YAEFk5B,EAAc,GACX7/B,EAAI,EAAGA,EAAI2G,EAAY3I,OAAQgC,GAAK,EAAG,CAC5C,IAAM+C,EAAQy8B,EAAmBr/B,EAAmB,CAChDwG,EAAY3G,GACZ2G,EAAY3G,EAAI,KAEpB6/B,EAAY59B,KAAKc,EACrB,CAIA,GAA2B,IAAvB88B,EAAY7hC,OAAc,CAC1B,IAAMgF,EAAmB5C,EAASmgB,IAC9B,mBACApgB,GAGA+C,EAAU,GACVC,EAAU,GAEd,GAAIH,EAEAE,EAD0BF,EAAlBI,QACY,GACpBD,EAF0BH,EAATK,KAEA,GAGrB,IAAMy8B,EAAcN,EAAmBr/B,EAAmB,CACtDwG,EAAY,GAAKzD,EACjByD,EAAY,GAAKxD,IAGrB08B,EAAY59B,KAAK69B,EACrB,CAEA,IAAM/kB,EAAQ8E,EAed,OAbA9E,EAAMpc,WAAWY,KAAO,CACpB+b,KAAAA,EACArX,QAAS,CACL87B,YAAY,EACZrb,OAAQ,CAACmb,EAAY,GAAIA,EAAY,IACrCG,kBAAmB,EACnB97B,QAAS,CACLuf,UAAU,IAGlB7a,YAAaE,GAGViS,CACX,GAAC,CAAAlK,IAAA,mCAAAzO,MAED,SAAwC6e,EAAM2d,GAC1C,IAAQr/B,EAAmB0hB,EAAnB1hB,KAAMa,EAAa6gB,EAAb7gB,SACRsP,EAA0BuR,EAA1BvR,QAASC,EAAiBsR,EAAjBtR,aACPxP,EAAsBC,EAAtBD,kBAER,IAAKA,EACD,MAAM,IAAIoB,MACN,oFAIR,IAAA0+B,EAA+B1gC,EAAK0E,QAA5BygB,EAAMub,EAANvb,OAUFwb,EAAatB,EAAmBz+B,EAVZ8/B,EAAVF,WAKJrb,EAAO,GAEPA,EAAO,IAKbyD,EAAgC,CAClCzD,OAAQ,CACJ,CACIjgB,EAAGy7B,EAAW,GACdv7B,EAAGu7B,EAAW,KAGtB/b,4BAAAyb,GACAjwB,aAAcA,GAAgB,IAclC,OAVKD,GAAWA,EAAQ9C,YAAcxB,GAAW9F,sBAC7CoK,EAAU,CACN9C,UAAWxB,GAAW9F,oBACtBkG,uBAAAA,GACAqE,YAAatQ,EAAK+b,OAI1B6M,EAA8BzY,QAAUA,EAEjCyY,CACX,KAACD,CAAA,CAxHc,GA2HnBA,GAAcxT,SAAWirB,GACzBzX,GAAcrF,gBAAkB8c,GAChCzX,GAAc9G,qBAAuBse,GACrCxX,GAAcvX,qCAAuC,SAAA/J,GACjD,IAAKA,EAAmBtH,SAAS,KAC7B,OAAO,EAGX,IAAkE8kB,EAAAL,EAA7Bnd,EAAmBE,MAAM,KAAI,GAA3Dq5B,EAAgB/b,EAAA,GAAE1P,EAAQ0P,EAAA,GAEjC,OAAI+b,IAAqBx2B,IAIlB+K,IAAairB,EACxB,EAEAn2B,GAAkB8a,aAAa4D,ICnJvB,IAAekY,GAAwB9+B,EAAAA,GAAU2hB,OAAMkC,cAEzDkb,GAAgB,gBAGhBC,GAA8B,GAAAx9B,OAAG6G,GAAsB,KAAA7G,OAAAu9B,IAE7Dlb,GAAA,oBAAAA,IAAA,CAmLA,OAjKkBA,EAAkBvC,mBAAhC,SACI7X,EACAm0B,EACAM,EACAp/B,G,MAEMmgC,EACF/2B,GAAkB6Z,wBACdtY,EACAm0B,EACA9+B,EACA+kB,EAAczQ,UALdmL,EAAY0gB,EAAA1gB,aAAE/W,EAAqBy3B,EAAAz3B,sBAQrC3I,EACF0f,EAAalhB,WAAWyB,SAASD,kBAC7B4N,EAAoBhD,EAAgBgD,gBAEtCuX,EAAmB/I,EAAQxO,GAAiBG,MAC9C,SAAAa,GAAS,MAzCH,cAyCGA,EAAMrC,wBAAwBmD,WAAyB,IAG9D0V,EAAsBhJ,EACxB+I,EAAiBvX,iBACnBG,MAAK,SAAAa,GAAS,MAAoB,WAApBA,EAAMC,SAAsB,IAEtCwW,EAAoBjJ,EAAQxO,GAAiBG,MAC/C,SAAAa,GAAS,MAhDF,eAgDEA,EAAMrC,wBAAwBmD,WAA0B,IAG/D4V,EAAuBlJ,EACzBiJ,EAAkBzX,iBACpBG,MAAK,SAAAa,GAAS,MAAoB,WAApBA,EAAMC,SAAsB,IAEtC6wB,EAAc,GAEpB,CAACta,EAAqBE,GAAsB7kB,SAAQ,SAAAmO,GAEhD,IADQ,IAAApI,EAAgBoI,EAAKpI,YACpB3G,EAAI,EAAGA,EAAI2G,EAAY3I,OAAQgC,GAAK,EAAG,CAC5C,IAAM+C,EAAQy8B,EAAmBr/B,EAAmB,CAChDwG,EAAY3G,GACZ2G,EAAY3G,EAAI,KAEpB6/B,EAAY59B,KAAKc,EACpB,CACL,IAEA,IAAMgY,EAAQ8E,EAwBd,OAtBA9E,EAAMpc,WAAWY,KAAO,CACpB0E,QAAS,CACLygB,OAAQ,CACJmb,EAAY,GACZA,EAAY,GACZA,EAAY,GACZA,EAAY,IAEhBG,kBAAmB,EACnB97B,QAAS,CACLuf,UAAU,IAGlBjkB,aAAWu/B,EAAA,GACPA,EAAC,WAAAj8B,OAAW3C,IAAsB,CAC9BnC,OAAQsnB,EAAiB/V,sBAAsBgD,aAC/CjQ,MAAOkjB,EAAkBjW,sBAAsBgD,cAEtDwsB,GACDn2B,YAAaE,GAGViS,C,EAGJoK,EAAAhE,iCAAP,SAAwCF,EAAM2d,GAClC,IAAAr/B,EAA0C0hB,EAAI1hB,KAAxCmQ,EAAoCuR,EAAIvR,QAA/BC,EAA2BsR,EAAftR,aAAEvP,EAAa6gB,EAAI7gB,SAC9C2+B,EAA8Bx/B,EAAdC,YAAhBA,OAAW,IAAAu/B,EAAG,CAAC,EAACA,EAAE96B,EAAY1E,EAAI0E,QAElC9D,EAAsBC,EAAQD,kBAEtC,IAAKA,EACD,MAAM,IAAIoB,MACN,oFAIF,IAoBFi/B,EACAC,EArBEF,EACF/gC,EAAY,WAAAsD,OAAW3C,KAAwB,CAAC,EAD5CnC,EAAMuiC,EAAAviC,OAAEsE,EAAKi+B,EAAAj+B,MAEboiB,EAAWzgB,EAAOygB,OAGpBgc,EAAkB,CAAChc,EAAO,GAAIA,EAAO,IACrCic,EAAmB,CAACjc,EAAO,GAAIA,EAAO,IAEZ7iB,KAAKklB,KACjCllB,KAAKmlB,IAAI0Z,EAAgB,GAAG,GAAKA,EAAgB,GAAG,GAAI,GACpD7+B,KAAKmlB,IAAI0Z,EAAgB,GAAG,GAAKA,EAAgB,GAAG,GAAI,GACxD7+B,KAAKmlB,IAAI0Z,EAAgB,GAAG,GAAKA,EAAgB,GAAG,GAAI,IAG/B7+B,KAAKklB,KAClCllB,KAAKmlB,IAAI2Z,EAAiB,GAAG,GAAKA,EAAiB,GAAG,GAAI,GACtD9+B,KAAKmlB,IAAI2Z,EAAiB,GAAG,GAAKA,EAAiB,GAAG,GAAI,GAC1D9+B,KAAKmlB,IAAI2Z,EAAiB,GAAG,GAAKA,EAAiB,GAAG,GAAI,KAM9DH,EAAkBE,EAClBD,EAAiBE,IAEjBH,EAAkBG,EAClBF,EAAiBC,GAGrB,IAAME,EAAqBhC,EACvBz+B,EACAqgC,EAAgB,IAEdK,EAAmBjC,EACrBz+B,EACAqgC,EAAgB,IAEdM,EAAsBlC,EACxBz+B,EACAsgC,EAAe,IAEbM,EAAoBnC,EACtBz+B,EACAsgC,EAAe,IAGnB,MAAO,CACHra,SAAU,CACNpC,OAAQ,CACJvf,EAAGm8B,EAAmB,GACtBj8B,EAAGi8B,EAAmB,IAE1B3c,OAAQ,CACJxf,EAAGo8B,EAAiB,GACpBl8B,EAAGk8B,EAAiB,KAG5Bxa,UAAW,CACPrC,OAAQ,CACJvf,EAAGq8B,EAAoB,GACvBn8B,EAAGm8B,EAAoB,IAE3B7c,OAAQ,CACJxf,EAAGs8B,EAAkB,GACrBp8B,EAAGo8B,EAAkB,KAG7Bza,eAAgBtoB,EAChBuoB,gBAAiBjkB,EACjB6hB,4BAA2Bmc,GAC3B5wB,QAASA,EACTC,aAAcA,GAAgB,G,EA/KxBwV,EAAQzQ,SAAG2rB,GACXlb,EAAetC,gBAAGwd,GAClBlb,EAAoB/D,qBAAGgf,GACvBjb,EAAoCxU,qCAAG,SAAA/J,GACjD,IAAKA,EAAmBtH,SAAS,KAC7B,OAAO,EAGL,IAAAy/B,EAA+Bn4B,EAAmBE,MAAM,KAAvDq5B,EAAgBpB,EAAA,GAAErqB,EAAQqqB,EAAA,GAEjC,OAAIoB,IAAqBx2B,IAIlB+K,IAAa2rB,EACxB,EAmKHlb,CAAA,CAnLD,GAqLA3b,GAAkB8a,aAAaa,IC7LvB,IAAW6b,GAAoB1/B,EAAAA,GAAU2hB,OAAMoF,UAEjD4Y,GAAmB,QACnBC,GAA8B,GAAAp+B,OAAG6G,GAAsB,KAAA7G,OAAAm+B,IAE7DnY,GAAA,oBAAAA,IAAA,CAyGA,OAtFkBA,EAAkBlG,mBAAhC,SACI7X,EACAm0B,EACAM,EACAp/B,GAeA,I,MAbMmgC,EACF/2B,GAAkB6Z,wBACdtY,EACAm0B,EACA9+B,EACA0oB,EAAMpU,UALNmL,EAAY0gB,EAAA1gB,aAAEF,EAAQ4gB,EAAA5gB,SAAEC,EAAW2gB,EAAA3gB,YAAE9W,EAAqBy3B,EAAAz3B,sBAQ5D3I,EACF0f,EAAalhB,WAAWyB,SAASD,kBAE7BwG,EAAgBiZ,EAAWjZ,YAC7Bk5B,EAAc,GACX7/B,EAAI,EAAGA,EAAI2G,EAAY3I,OAAQgC,GAAK,EAAG,CAC5C,IAAM+C,EAAQy8B,EAAmBr/B,EAAmB,CAChDwG,EAAY3G,GACZ2G,EAAY3G,EAAI,KAEpB6/B,EAAY59B,KAAKc,EACpB,CAED,IAAMgY,EAAQ8E,EAoBd,OAlBA9E,EAAMpc,WAAWY,KAAO,CACpB0E,QAAS,CACLygB,OAAQ,CAACmb,EAAY,GAAIA,EAAY,GAAIA,EAAY,IACrDG,kBAAmB,EACnB97B,QAAS,CACLuf,UAAU,IAGlBjkB,aAAWu/B,EAAA,GACPA,EAAC,WAAAj8B,OAAW3C,IAAsB,CAC9BghC,MAAOxhB,EACDA,EAASpQ,sBAAsBgD,aAC/B,MAEbwsB,GACDn2B,YAAaE,GAGViS,C,EAGG+N,EAAA3H,iCAAd,SAA+CF,EAAM2d,GACzC,IAAAr/B,EAA0C0hB,EAAI1hB,KAAxCmQ,EAAoCuR,EAAIvR,QAA/BC,EAA2BsR,EAAftR,aAAEvP,EAAa6gB,EAAI7gB,SAC9C2+B,EAA8Bx/B,EAAdC,YAAhBA,OAAW,IAAAu/B,EAAG,CAAC,EAACA,EAAE96B,EAAY1E,EAAI0E,QAElC9D,EAAsBC,EAAQD,kBAEtC,IAAKA,EACD,MAAM,IAAIoB,MACN,4EAIR,IAAM6/B,EAASxC,EAAmBz+B,EAAmB8D,EAAQygB,OAAO,IAC9DuE,EAAS2V,EAAmBz+B,EAAmB8D,EAAQygB,OAAO,IAE9DlB,EAAMob,EAAmBz+B,EAAmB8D,EAAQygB,OAAO,IAE3DV,EAAS,CAAEvf,EAAG28B,EAAO,GAAIz8B,EAAGy8B,EAAO,IACnCnd,EAAS,CAAExf,EAAGwkB,EAAO,GAAItkB,EAAGskB,EAAO,IAOzC,MAAO,CACHjF,OAAMA,EACNC,OAAMA,EACN0E,OATW1E,EAUX2E,OATW,CAAEnkB,EAAG+e,EAAI,GAAI7e,EAAG6e,EAAI,IAU/BgF,QARchpB,EAAY,WAAAsD,OAAW3C,KAAwB,CAAC,GAACghC,MAS/Dhd,4BAA2B+c,GAC3BxxB,QAAOA,EACPC,aAAcA,GAAgB,G,EArGxBmZ,EAAQpU,SAAGusB,GACXnY,EAAejG,gBAAGoe,GAClBnY,EAAoB1H,qBAAG4f,GACvBlY,EAAoCnY,qCAAG,SAAA/J,GACjD,IAAKA,EAAmBtH,SAAS,KAC7B,OAAO,EAGL,IAAAy/B,EAA+Bn4B,EAAmBE,MAAM,KAAvDq5B,EAAgBpB,EAAA,GAAErqB,EAAQqqB,EAAA,GAEjC,OAAIoB,IAAqBx2B,IAIlB+K,IAAausB,EACxB,EAyFHnY,CAAA,CAzGD,GA2GAtf,GAAkB8a,aAAawE,IChHvB,IAAWuY,GAAoB//B,EAAAA,GAAU2hB,OAAMoF,UAEjDiZ,GAAmB,YACnBC,GAA8B,GAAAz+B,OAAG6G,GAAsB,KAAA7G,OAAAw+B,IAE7DjZ,GAAA,oBAAAA,IAAA,CA8GA,OA3FkBA,EAAkBzF,mBAAhC,SACI7X,EACAm0B,EACAM,EACAp/B,GAeA,I,MAbMmgC,EACF/2B,GAAkB6Z,wBACdtY,EACAm0B,EACA9+B,EACAioB,EAAU3T,UALVmL,EAAY0gB,EAAA1gB,aAAEF,EAAQ4gB,EAAA5gB,SAAEC,EAAW2gB,EAAA3gB,YAAE9W,EAAqBy3B,EAAAz3B,sBAQ5D3I,EACF0f,EAAalhB,WAAWyB,SAASD,kBAE7BwG,EAAgBiZ,EAAWjZ,YAC7Bk5B,EAAc,GACX7/B,EAAI,EAAGA,EAAI2G,EAAY3I,OAAQgC,GAAK,EAAG,CAC5C,IAAM+C,EAAQy8B,EAAmBr/B,EAAmB,CAChDwG,EAAY3G,GACZ2G,EAAY3G,EAAI,KAEpB6/B,EAAY59B,KAAKc,EACpB,CAED,IAAMgY,EAAQ8E,EAyBd,OAvBA9E,EAAMpc,WAAWY,KAAO,CACpB0E,QAAS,CACLygB,OAAQ,CACJmb,EAAY,GACZA,EAAY,GACZA,EAAY,GACZA,EAAY,IAEhBG,kBAAmB,EACnB97B,QAAS,CACLuf,UAAU,IAGlBjkB,aAAWu/B,EAAA,GACPA,EAAC,WAAAj8B,OAAW3C,IAAsB,CAC9BghC,MAAOxhB,EACDA,EAASpQ,sBAAsBgD,aAC/B,MAEbwsB,GACDn2B,YAAaE,GAGViS,C,EAGGsN,EAAAlH,iCAAd,SAA+CF,EAAM2d,GACzC,IAAAr/B,EAA0C0hB,EAAI1hB,KAAxCmQ,EAAoCuR,EAAIvR,QAA/BC,EAA2BsR,EAAftR,aAAEvP,EAAa6gB,EAAI7gB,SAC9C2+B,EAA8Bx/B,EAAdC,YAAhBA,OAAW,IAAAu/B,EAAG,CAAC,EAACA,EAAE96B,EAAY1E,EAAI0E,QAElC9D,EAAsBC,EAAQD,kBAEtC,IAAKA,EACD,MAAM,IAAIoB,MACN,gFAIR,IAAM6/B,EAASxC,EAAmBz+B,EAAmB8D,EAAQygB,OAAO,IAC9D8c,EAAO5C,EAAmBz+B,EAAmB8D,EAAQygB,OAAO,IAE5D+D,EAASmW,EAAmBz+B,EAAmB8D,EAAQygB,OAAO,IAC9DgE,EAAOkW,EAAmBz+B,EAAmB8D,EAAQygB,OAAO,IASlE,MAAO,CACHV,OARW,CAAEvf,EAAG28B,EAAO,GAAIz8B,EAAGy8B,EAAO,IASrCnd,OARW,CAAExf,EAAG+8B,EAAK,GAAI78B,EAAG68B,EAAK,IASjC7Y,OARW,CAAElkB,EAAGgkB,EAAO,GAAI9jB,EAAG8jB,EAAO,IASrCG,OARW,CAAEnkB,EAAGikB,EAAK,GAAI/jB,EAAG+jB,EAAK,IASjCF,QAPchpB,EAAY,WAAAsD,OAAW3C,KAAwB,CAAC,GAACghC,MAQ/Dhd,4BAA2Bod,GAC3B7xB,QAAOA,EACPC,aAAcA,GAAgB,G,EA1GxB0Y,EAAQ3T,SAAG4sB,GACXjZ,EAAexF,gBAAGye,GAClBjZ,EAAoBjH,qBAAGigB,GACvBhZ,EAAoC1X,qCAAG,SAAA/J,GACjD,IAAKA,EAAmBtH,SAAS,KAC7B,OAAO,EAGL,IAAAy/B,EAA+Bn4B,EAAmBE,MAAM,KAAvDq5B,EAAgBpB,EAAA,GAAErqB,EAAQqqB,EAAA,GAEjC,OAAIoB,IAAqBx2B,IAIlB+K,IAAa4sB,EACxB,EA8FHjZ,CAAA,CA9GD,GCPwB,SAAA1X,GACpB8wB,GAEA,IAAKA,EAAmBniC,SAAS,KAC7B,OAAO,EAGL,IAAAy/B,EAA+B0C,EAAmB36B,MAAM,KAAvDq5B,EAAgBpB,EAAA,GAAErqB,EAAQqqB,EAAA,GAEjC,OAAIoB,IAAqBx2B,IAMlB+K,EAASgtB,gBAAkB9iC,KAAK8V,SAASgtB,aACpD,CDuGAl4B,GAAkB8a,aAAa+D,IEpHvB,IAAQsZ,GAAiBrgC,EAAAA,GAAU2hB,OAAMwE,OAE3Cma,GAAY,YAElBC,GAAA,oBAAAA,IAAA,CAwGA,OA/FWA,EAAkBjf,mBAAzB,SACI7X,EACAm0B,EACAM,EACAp/B,GAiBA,I,MAfMmgC,EACF/2B,GAAkB6Z,wBACdtY,EACAm0B,EACA9+B,EACAyhC,EAAUntB,UALVmL,EAAY0gB,EAAA1gB,aAAEF,EAAQ4gB,EAAA5gB,SAAEC,EAAW2gB,EAAA3gB,YAAE9W,EAAqBy3B,EAAAz3B,sBAQ5D3I,EACF0f,EAAalhB,WAAWyB,SAASD,kBAE7BwG,EAAgBiZ,EAAWjZ,YAG7BK,EAAc,GACXhH,EAAI,EAAGA,EAAI2G,EAAY3I,OAAQgC,GAAK,EAAG,CAC5C,IAAM+G,EAAWy4B,EAAmBr/B,EAAmB,CACnDwG,EAAY3G,GACZ2G,EAAY3G,EAAI,KAGpBgH,EAAY/E,KAAK8E,EACpB,CAED,IAAMgU,EAAQ8E,EAuBd,OArBA9E,EAAMpc,WAAWY,KAAO,CACpB0E,QAAS,CACLygB,OAAMsZ,GAAA,GAAMh3B,GAAY,GACxBg5B,kBAAmB,EACnB97B,QAAS,CACLuf,UAAU,IAGlBjkB,aAAWu/B,EAAA,GACPA,EAAC,WAAAj8B,OAAW3C,IAAsB,CAC9BykB,KAAMjF,EACAA,EAASpQ,sBAAsBgD,aAC/B,EAENpL,OAAQ,EACR8d,UAAW,GAElB8Z,GACDn2B,YAAaE,GAGViS,C,EASJ8mB,EAAA1gB,iCAAP,SAAwCF,EAAM2d,GAClC,IAAAr/B,EAA0C0hB,EAAI1hB,KAAxCmQ,EAAoCuR,EAAIvR,QAA/BC,EAA2BsR,EAAftR,aAAEvP,EAAa6gB,EAAI7gB,SAC9C2+B,EAA8Bx/B,EAAdC,YAAhBA,OAAW,IAAAu/B,EAAG,CAAC,EAACA,EAAE96B,EAAY1E,EAAI0E,QAElC9D,EAAsBC,EAAQD,kBAEtC,IAAKA,EACD,MAAM,IAAIoB,MACN,gFAIR,IAAM0F,EAAS23B,EAAmBz+B,EAAmB8D,EAAQygB,OAAO,IAC9DlB,EAAMob,EAAmBz+B,EAAmB8D,EAAQygB,OAAO,IAE3DA,EAAS,GACfA,EAAOziB,KAAK,CAAEwC,EAAGwC,EAAO,GAAItC,EAAGsC,EAAO,KACtCyd,EAAOziB,KAAK,CAAEwC,EAAG+e,EAAI,GAAI7e,EAAG6e,EAAI,KAE1B,IAAA+c,EACF/gC,EAAY,WAAAsD,OAAW3C,KAAwB,CAAC,EAD5CykB,EAAI2b,EAAA3b,KAAEzd,EAAMo5B,EAAAp5B,OAIpB,MAAO,CACHyd,KAAIA,EACJK,UAJc,EAAIpjB,KAAK+lB,GAAKzgB,EAK5BA,OAAMA,EACNud,OAAMA,EACNP,4BAA6BvlB,KAAKulB,4BAClCzU,QAAOA,EACPC,aAAcA,GAAgB,G,EApG/BkyB,EAAA1d,4BAA8B,GAAGrhB,OAAA6G,GAAsB,KAAA7G,OAAA8+B,IACvDC,EAAQntB,SAAGktB,GACXC,EAAehf,gBAAG+e,GAClBC,EAAoBzgB,qBAAGugB,GACvBE,EAAoClxB,qCACvCA,GAkGPkxB,CAAA,CAxGD,GA0GAr4B,GAAkB8a,aAAaud,IC3GvB,IAASC,GAAkBxgC,EAAAA,GAAU2hB,OAAMwD,QAE7Csb,GAAgB,gBAChB77B,GAAU,KAEhB87B,GAAA,oBAAAA,IAAA,CA0LA,OAlLWA,EAAkBpf,mBAAzB,SACI7X,EACAm0B,EACAM,EACAp/B,GAoBA,I,MAlBMmgC,EACF/2B,GAAkB6Z,wBACdtY,EACAm0B,EACA9+B,EACA4hC,EAActtB,UALdmL,EAAY0gB,EAAA1gB,aAAEF,EAAQ4gB,EAAA5gB,SAAEC,EAAW2gB,EAAA3gB,YAAE9W,EAAqBy3B,EAAAz3B,sBAQ5D3I,EACF0f,EAAalhB,WAAWyB,SAASD,kBAE7BwG,EAAgBiZ,EAAWjZ,YAM7BK,EAAwB,GACrBhH,EAAI,EAAGA,EAAI2G,EAAY3I,OAAQgC,GAAK,EAAG,CAC5C,IAAM+G,EAAWy4B,EAAmBr/B,EAAmB,CACnDwG,EAAY3G,GACZ2G,EAAY3G,EAAI,KAGpBgH,EAAY/E,KAAK8E,EACpB,CAED,IAAMa,EAAiBR,EAAAA,GAAAA,WAAe2vB,MAAf3vB,EAAAA,GAAmBJ,EAAY,IAChDa,EAAeT,EAAAA,GAAAA,WAAe2vB,MAAf3vB,EAAAA,GAAmBJ,EAAY,IAC9Cc,EAAiBV,EAAAA,GAAAA,WAAe2vB,MAAf3vB,EAAAA,GAAmBJ,EAAY,IAChDe,EAAeX,EAAAA,GAAAA,WAAe2vB,MAAf3vB,EAAAA,GAAmBJ,EAAY,IAE9CgB,EAAeZ,EAAAA,GAAAA,SACrBA,EAAAA,GAAAA,IAASY,EAAcH,EAAcD,GAGrCR,EAAAA,GAAAA,UAAeY,EAAcA,GAE7B,IAAMC,EAAeb,EAAAA,GAAAA,SACrBA,EAAAA,GAAAA,IAASa,EAAcF,EAAcD,GACrCV,EAAAA,GAAAA,UAAea,EAAcA,GAE7B,IAAMZ,EAAmBjH,EAASmgB,IAC9B,mBACApgB,GAGJ,IAAKkH,EACD,MAAM,IAAI9F,MAAM,mDAGZ,IAAA+F,EAAkBD,EAAgBC,cAGpCY,EAAmBd,EAAAA,GAAAA,WACrBE,EAAc,GACdA,EAAc,GACdA,EAAc,IAEZa,EAA6Bf,EAAAA,GAAAA,IAC/Bc,EACAF,GAGEK,EAA6BjB,EAAAA,GAAAA,IAC/Bc,EACAD,GAGEK,EAA4BzG,KAAKuG,IAAID,GACrCI,EAA4B1G,KAAKuG,IAAIC,GAEvC45B,EAAgB,GAChBpgC,KAAKuG,IAAIE,EAA4B,GAAKpC,GAC1C+7B,EAAgB,CACZj7B,EAAY,GACZA,EAAY,GACZA,EAAY,GACZA,EAAY,IAETnF,KAAKuG,IAAIG,EAA4B,GAAKrC,GACjD+7B,EAAgB,CACZj7B,EAAY,GACZA,EAAY,GACZA,EAAY,GACZA,EAAY,IAGhBwB,QAAQC,KAAK,qCAGjB,IAAMsS,EAAQ8E,EAoBd,OAlBA9E,EAAMpc,WAAWY,KAAO,CACpB0E,QAAS,CACLygB,OAAMsZ,GAAA,GAAMiE,GAAc,GAC1BjC,kBAAmB,EACnB97B,QAAS,CACLuf,UAAU,IAGlBjkB,aAAWu/B,EAAA,GACPA,EAAC,WAAAj8B,OAAW3C,IAAsB,CAC9BykB,KAAMjF,EACAA,EAASpQ,sBAAsBgD,aAC/B,GAEbwsB,GACDn2B,YAAaE,GAGViS,C,EAGJinB,EAAA7gB,iCAAP,SAAwCF,EAAM2d,GAClC,IAUJh6B,EAAKs9B,EAAQx9B,EAAMy9B,EAVf5iC,EAA0C0hB,EAAI1hB,KAAxCmQ,EAAoCuR,EAAIvR,QAA/BC,EAA2BsR,EAAftR,aAAEvP,EAAa6gB,EAAI7gB,SAC9C2+B,EAA8Bx/B,EAAdC,YAAhBA,OAAW,IAAAu/B,EAAG,CAAC,EAACA,EAAE96B,EAAY1E,EAAI0E,QACpCN,EAAWpE,EAAK8nB,iBAAmB,EACjClnB,EAAsBC,EAAQD,kBAEtC,IAAKA,EACD,MAAM,IAAIoB,MACN,oFAKQ,IAAZoC,GAA8B,KAAZA,GAClBu+B,EAAStD,EAAmBz+B,EAAmB8D,EAAQygB,OAAO,IAC9D9f,EAAMg6B,EAAmBz+B,EAAmB8D,EAAQygB,OAAO,IAC3DhgB,EAAOk6B,EAAmBz+B,EAAmB8D,EAAQygB,OAAO,IAC5Dyd,EAAQvD,EAAmBz+B,EAAmB8D,EAAQygB,OAAO,MAE7D9f,EAAMg6B,EAAmBz+B,EAAmB8D,EAAQygB,OAAO,IAC3Dwd,EAAStD,EAAmBz+B,EAAmB8D,EAAQygB,OAAO,IAC9DhgB,EAAOk6B,EAAmBz+B,EAAmB8D,EAAQygB,OAAO,IAC5Dyd,EAAQvD,EAAmBz+B,EAAmB8D,EAAQygB,OAAO,KAIjE,IAGMA,EAAS,GAqBf,OAxBwB7iB,KAAKuG,IAAIxD,EAAI,GAAKs9B,EAAO,IACzBrgC,KAAKuG,IAAI1D,EAAK,GAAKy9B,EAAM,KAK7Czd,EAAOziB,KAAK,CAAEwC,EAAGG,EAAI,GAAID,EAAGC,EAAI,KAChC8f,EAAOziB,KAAK,CAAEwC,EAAGy9B,EAAO,GAAIv9B,EAAGu9B,EAAO,KAGtCxd,EAAOziB,KAAK,CAAEwC,EAAGC,EAAK,GAAIC,EAAGD,EAAK,KAClCggB,EAAOziB,KAAK,CAAEwC,EAAG09B,EAAM,GAAIx9B,EAAGw9B,EAAM,OAGpCzd,EAAOziB,KAAK,CAAEwC,EAAGC,EAAK,GAAIC,EAAGD,EAAK,KAClCggB,EAAOziB,KAAK,CAAEwC,EAAG09B,EAAM,GAAIx9B,EAAGw9B,EAAM,KAGpCzd,EAAOziB,KAAK,CAAEwC,EAAGG,EAAI,GAAID,EAAGC,EAAI,KAChC8f,EAAOziB,KAAK,CAAEwC,EAAGy9B,EAAO,GAAIv9B,EAAGu9B,EAAO,MAKnC,CACHtd,MAHaplB,EAAY,WAAAsD,OAAW3C,KAAwB,CAAC,GAACykB,KAI9DF,OAAMA,EACNP,4BAA6BvlB,KAAKulB,4BAClCzU,QAAOA,EACPC,aAAcA,GAAgB,G,EAtL/BqyB,EAAA7d,4BAA8B,GAAGrhB,OAAA6G,GAAsB,KAAA7G,OAAAi/B,IACvDC,EAAQttB,SAAGqtB,GACXC,EAAenf,gBAAGkf,GAClBC,EAAoB5gB,qBAAG0gB,GACvBE,EAAoCrxB,qCACvCA,GAoLPqxB,CAAA,CA1LD,GA4LAx4B,GAAkB8a,aAAa0d,ICrMvB,IAAUI,GAAmB9gC,EAAAA,GAAU2hB,OAAMuB,SAE/C6d,GAAW,eACXC,GAA8B,GAAAx/B,OAAG6G,GAAsB,KAAA7G,OAAAu/B,IAE7DE,GAAA,oBAAAA,IAAA,CA2GA,OAxFkBA,EAAkB3f,mBAAhC,SACI7X,EACAm0B,EACAM,EACAp/B,GAeA,I,MAbMmgC,EACF/2B,GAAkB6Z,wBACdtY,EACAm0B,EACA9+B,EACAmiC,EAAa7tB,UALbmL,EAAY0gB,EAAA1gB,aAAEF,EAAQ4gB,EAAA5gB,SAAEC,EAAW2gB,EAAA3gB,YAAE9W,EAAqBy3B,EAAAz3B,sBAQ5D3I,EACF0f,EAAalhB,WAAWyB,SAASD,kBAE7BwG,EAAgBiZ,EAAWjZ,YAC7Bk5B,EAAc,GACX7/B,EAAI,EAAGA,EAAI2G,EAAY3I,OAAQgC,GAAK,EAAG,CAC5C,IAAM+C,EAAQy8B,EAAmBr/B,EAAmB,CAChDwG,EAAY3G,GACZ2G,EAAY3G,EAAI,KAEpB6/B,EAAY59B,KAAKc,EACpB,CAED,IAAMgY,EAAQ8E,EAyBd,OAvBA9E,EAAMpc,WAAWY,KAAO,CACpB0E,QAAS,CACLygB,OAAQ,CACJmb,EAAY,GACZA,EAAY,GACZA,EAAY,GACZA,EAAY,IAEhBG,kBAAmB,EACnB97B,QAAS,CACLuf,UAAU,IAGlBjkB,aAAWu/B,EAAA,GACPA,EAAC,WAAAj8B,OAAW3C,IAAsB,CAC9BykB,KAAMjF,EACAA,EAASpQ,sBAAsBgD,aAC/B,MAEbwsB,GACDn2B,YAAaE,GAGViS,C,EAGJwnB,EAAAphB,iCAAP,SAAwCF,EAAM2d,GAClC,IAAAr/B,EAA0C0hB,EAAI1hB,KAAxCmQ,EAAoCuR,EAAIvR,QAA/BC,EAA2BsR,EAAftR,aAAEvP,EAAa6gB,EAAI7gB,SAC9C2+B,EAA8Bx/B,EAAdC,YAAhBA,OAAW,IAAAu/B,EAAG,CAAC,EAACA,EAAE96B,EAAY1E,EAAI0E,QAElC9D,EAAsBC,EAAQD,kBAEtC,IAAKA,EACD,MAAM,IAAIoB,MACN,gFAIR,IAAMihC,EAAUv+B,EAAQygB,OAAOliB,KAAI,SAAAO,GAC/B,OAAA67B,EAAmBz+B,EAAmB4C,EAAtC,IAGI6hB,EAAoBplB,EAAWolB,KAAzBK,EAAczlB,EAAWylB,UAEvC,MAAO,CACHP,OAAQ,CACJ8d,EAAQ,GACRA,EAAQ,GACRA,EAAQ,GACRA,EAAQ,GACRA,EAAQ,IAEZ5d,KAAIA,EACJK,UAASA,EACTd,4BAA2Bme,GAC3B5yB,QAAOA,EACPC,aAAcA,GAAgB,G,EAvGxB4yB,EAAQ7tB,SAAG2tB,GACXE,EAAe1f,gBAAGwf,GAClBE,EAAoBnhB,qBAAGghB,GAEvBG,EAAoC5xB,qCAAG,SAAA/J,GACjD,IAAKA,EAAmBtH,SAAS,KAC7B,OAAO,EAGL,IAAAy/B,EAA+Bn4B,EAAmBE,MAAM,KAAvDq5B,EAAgBpB,EAAA,GAAErqB,EAAQqqB,EAAA,GAEjC,OAAIoB,IAAqBx2B,IAIlB+K,IAAa2tB,EACxB,EA0FHE,CAAA,CA3GD,GA6GA/4B,GAAkB8a,aAAaie,IClH/B,IAAgBE,GAAiBnhC,EAAAA,GAAU2hB,OAAnC5d,OAEFq9B,GAAS,SACTC,GAA8B,GAAH7/B,OAAM6G,GAAkB,KAAA7G,OAAI4/B,IAEvDr9B,GAAM,oBAAAA,IAAAia,EAAA,KAAAja,EAAA,CAiFP,OAjFOka,EAAAla,EAAA,OAAAwL,IAAA,qBAAAzO,MAER,SACI2I,EACAm0B,EACAM,EACAp/B,GAeA,IAbA,IAAAgjB,EACI5Z,GAAkB6Z,wBACdtY,EACAm0B,EACA9+B,EACAiF,EAAOqP,UALPmL,EAAYuD,EAAZvD,aAAcF,EAAQyD,EAARzD,SAAUC,EAAWwD,EAAXxD,YAAa9W,EAAqBsa,EAArBta,sBAQvC3I,EACF0f,EAAalhB,WAAWyB,SAASD,kBAE7BwG,EAAgBiZ,EAAhBjZ,YACFk5B,EAAc,GACX7/B,EAAI,EAAGA,EAAI2G,EAAY3I,OAAQgC,GAAK,EAAG,CAC5C,IAAM+C,EAAQy8B,EAAmBr/B,EAAmB,CAChDwG,EAAY3G,GACZ2G,EAAY3G,EAAI,KAEpB6/B,EAAY59B,KAAKc,EACrB,CAEA,IAAMgY,EAAQ8E,EAoBd,OAlBA9E,EAAMpc,WAAWY,KAAO,CACpB0E,QAAS,CACLygB,OAAQ,CAACmb,EAAY,GAAIA,EAAY,IACrCG,kBAAmB,EACnB97B,QAAS,CACLuf,UAAU,IAGlBjkB,YAAWojC,EAAA,cAAA9/B,OACK3C,GAAsB,CAC9BnC,OAAQ2hB,EACFA,EAASpQ,sBAAsBgD,aAC/B,IAGd3J,YAAaE,GAGViS,CACX,GAAC,CAAAlK,IAAA,mCAAAzO,MAED,SAAwC6e,EAAM2d,GAC1C,IAAQr/B,EAA0C0hB,EAA1C1hB,KAAMmQ,EAAoCuR,EAApCvR,QAASC,EAA2BsR,EAA3BtR,aAAcvP,EAAa6gB,EAAb7gB,SACrCyiC,EAAsCtjC,EAA9BC,YAAAA,OAAW,IAAAqjC,EAAG,CAAC,EAACA,EAAE5+B,EAAY1E,EAAZ0E,QAElB9D,EAAsBC,EAAtBD,kBAER,IAAKA,EACD,MAAM,IAAIoB,MACN,6EAIR,IAAMgiB,EAAQqb,EAAmBz+B,EAAmB8D,EAAQygB,OAAO,IAC7DlB,EAAMob,EAAmBz+B,EAAmB8D,EAAQygB,OAAO,IAQjE,MAAO,CACHV,OAPW,CAAEvf,EAAG8e,EAAM,GAAI5e,EAAG4e,EAAM,IAQnCU,OAPW,CAAExf,EAAG+e,EAAI,GAAI7e,EAAG6e,EAAI,IAQ/BU,UALA1kB,EAAY,WAADsD,OAAY3C,KAAwB,CAAC,GAD5CnC,OAOJmmB,4BAAAwe,GACAjzB,QAAAA,EACAC,aAAcA,GAAgB,GAEtC,KAACtK,CAAA,CAjFO,GAoFZA,GAAOqP,SAAWguB,GAClBr9B,GAAOwd,gBAAkB6f,GACzBr9B,GAAO+b,qBAAuBqhB,GAC9Bp9B,GAAOsL,qCAAuC,SAAA/J,GAC1C,IAAKA,EAAmBtH,SAAS,KAC7B,OAAO,EAGX,IAAkE8kB,EAAAL,EAA7Bnd,EAAmBE,MAAM,KAAI,GAA3Dq5B,EAAgB/b,EAAA,GAAE1P,EAAQ0P,EAAA,GAEjC,OAAI+b,IAAqBx2B,IAIlB+K,IAAaguB,EACxB,EAEAl5B,GAAkB8a,aAAajf,ICzGvB,IAAUy9B,GAAmBxhC,EAAAA,GAAU2hB,OAAMuB,SAE/Cue,GAAoB,oBACpBC,GAA8B,GAAAlgC,OAAG6G,GAAsB,KAAA7G,OAAAigC,IAG7DE,GAAA,oBAAAA,IAAA,CAyHA,OAvGWA,EAAkBrgB,mBAAzB,SACI7X,EACAm0B,EACAM,EACAp/B,GAgBA,IAdM,IAAA2+B,EACFv1B,GAAkB6Z,wBACdtY,EACAm0B,EACA9+B,EACA6iC,EAAkBvuB,UALlBmL,EAAYkf,EAAAlf,aAAED,EAAWmf,EAAAnf,YAAE9W,EAAqBi2B,EAAAj2B,sBAQlD3I,EACF0f,EAAalhB,WAAWyB,SAASD,kBAC7BwG,EAAgBiZ,EAAWjZ,YAE7Bk5B,EAAc,GAEX7/B,EAAI,EAAGA,EAAI2G,EAAY3I,OAAQgC,GAAK,EAAG,CAC5C,IAAM+C,EAAQy8B,EAAmBr/B,EAAmB,CAChDwG,EAAY3G,GACZ2G,EAAY3G,EAAI,KAGpB6/B,EAAY59B,KAAKc,EACpB,CAED,IAKImgC,GAAgB,EALqB97B,EAAAA,GAAAA,SACrCy4B,EAAYA,EAAY7hC,OAAS,GACjC6hC,EAAY,IAnDO,OA0DnBA,EAAYsD,MAEZD,GAAgB,GAGpB,IAAMxe,EAAS,GAEXwe,GACAxe,EAAOziB,KAAK49B,EAAY,GAAIA,EAAYA,EAAY7hC,OAAS,IAGjE,IAAM+c,EAAQ8E,EAed,OAbA9E,EAAMpc,WAAWY,KAAO,CACpB6jC,SAAUvD,EACVqD,cAAaA,EACbj/B,QAAS,CACLygB,OAAMA,EACNsb,kBAAmB,KACnB97B,QAAS,CACLuf,UAAU,IAGlB7a,YAAaE,GAGViS,C,EAGJkoB,EAAA9hB,iCAAP,SAAwCF,EAAM2d,GAClC,IAAAr/B,EAA0C0hB,EAAI1hB,KAAxCmQ,EAAoCuR,EAAIvR,QAA/BC,EAA2BsR,EAAftR,aAAEvP,EAAa6gB,EAAI7gB,SAC9C8iC,EAA4B3jC,EAAI2jC,cAAjBE,EAAa7jC,EAAI6jC,SAEhCjjC,EAAsBC,EAAQD,kBAEtC,IAAKA,EACD,MAAM,IAAIoB,MACN,wFAIR,IAAMmjB,EAAS0e,EAAS5gC,KAAI,SAAAuE,GACxB,OAAA63B,EAAmBz+B,EAAmB4G,EAAtC,IAGJ,IAAKm8B,EAAe,CAEhB,IAAMG,EAAa3e,EAAO,GAG1BA,EAAOziB,KAAK,CAACohC,EAAW,GAAIA,EAAW,IAC1C,CAKD,MAAO,CACH3e,OAAMA,EACNE,KALS,EAMTK,UALc,EAMdd,4BAA2B6e,GAC3BtzB,QAAOA,EACPC,aAAcA,GAAgB,G,EArHxBszB,EAAQvuB,SAAGquB,GACXE,EAAepgB,gBAAGkgB,GAClBE,EAAoB7hB,qBAAG0hB,GACvBG,EAAoCtyB,qCAAG,SAAA/J,GACjD,IAAKA,EAAmBtH,SAAS,KAC7B,OAAO,EAGL,IAAAy/B,EAA+Bn4B,EAAmBE,MAAM,KAAvDq5B,EAAgBpB,EAAA,GAAErqB,EAAQqqB,EAAA,GAEjC,OAAIoB,IAAqBx2B,IAIlB+K,IAAaquB,EACxB,EAyGHE,CAAA,CAzHD,GA2HAz5B,GAAkB8a,aAAa2e,IClI/B,IAAeK,GAAgBhiC,EAAAA,GAAU2hB,OAAjC6E,MAEFyb,GAAQ,QACRpf,GAA8B,GAAHrhB,OAAM6G,GAAkB,KAAA7G,OAAIygC,IAEvDC,GAAK,oBAAAA,IAAAlkB,EAAA,KAAAkkB,EAAA,CA0EN,OA1EMjkB,EAAAikB,EAAA,OAAA3yB,IAAA,qBAAAzO,MACP,SACI2I,EACAm0B,EACAM,EACAp/B,GAgBA,IAdA,IAAAgjB,EACI5Z,GAAkB6Z,wBACdtY,EACAm0B,EACA9+B,EACAojC,EAAM9uB,UALNmL,EAAYuD,EAAZvD,aAAcD,EAAWwD,EAAXxD,YAAa9W,EAAqBsa,EAArBta,sBAQ7B3I,EACF0f,EAAalhB,WAAWyB,SAASD,kBAE7BwG,EAAgBiZ,EAAhBjZ,YAEFk5B,EAAc,GACX7/B,EAAI,EAAGA,EAAI2G,EAAY3I,OAAQgC,GAAK,EAAG,CAC5C,IAAM+C,EAAQy8B,EAAmBr/B,EAAmB,CAChDwG,EAAY3G,GACZ2G,EAAY3G,EAAI,KAEpB6/B,EAAY59B,KAAKc,EACrB,CAEA,IAAMgY,EAAQ8E,EAad,OAXA9E,EAAMpc,WAAWY,KAAO,CACpB0E,QAAS,CACLygB,OAAQmb,EACRG,kBAAmB,KACnB97B,QAAS,CACLuf,UAAU,IAGlB7a,YAAaE,GAGViS,CACX,GAAC,CAAAlK,IAAA,mCAAAzO,MAED,SAAwC6e,EAAM2d,GAC1C,IAAQr/B,EAAmB0hB,EAAnB1hB,KAAMa,EAAa6gB,EAAb7gB,SACRsP,EAA0BuR,EAA1BvR,QAASC,EAAiBsR,EAAjBtR,aACPxP,EAAsBC,EAAtBD,kBAER,IAAKA,EACD,MAAM,IAAIoB,MACN,4EAqBR,MAPsC,CAClCmjB,OAXenlB,EAAK0E,QAAhBygB,OAEmBliB,KAAI,SAAAO,GAC3B,IAAMm9B,EAAatB,EAAmBz+B,EAAmB4C,GACzD,MAAO,CACH0B,EAAGy7B,EAAW,GACdv7B,EAAGu7B,EAAW,GAEtB,IAII/b,4BAAAA,GACAxU,aAAcA,GAAgB,GAC9BD,QAAAA,EAIR,KAAC8zB,CAAA,CA1EM,GA6EXA,GAAM9uB,SAAW6uB,GACjBC,GAAM3gB,gBAAkB0gB,GACxBC,GAAMpiB,qBAAuBkiB,GAC7BE,GAAM7yB,qCAAuC,SAAA/J,GACzC,IAAKA,EAAmBtH,SAAS,KAC7B,OAAO,EAGX,IAAkE8kB,EAAAL,EAA7Bnd,EAAmBE,MAAM,KAAI,GAA3Dq5B,EAAgB/b,EAAA,GAAE1P,EAAQ0P,EAAA,GAEjC,OAAI+b,IAAqBx2B,IAIlB+K,IAAa6uB,EACxB,EAEA/5B,GAAkB8a,aAAakf,ICpGRhlB,EAAAA,GAAWC,WACeJ,EAAAA,GAAWgM,aCFnCmT,GAAcnT,aACuCpN,kB,ICaxEwmB,GAAkB,CACpBte,cAAaA,GACbkD,UAASA,GACTS,MAAKA,GACLzjB,OAAMA,GACNw8B,UAASA,GACTG,cAAaA,GACbO,aAAYA,GACZra,cAAaA,GACbsb,MAAKA,GACLP,kBAAiBA,GACjBz5B,kBAAiBA,GACjBI,WAAUy0B,GACV10B,mBAAkBA,IC3BOpK,EAAAA,GAArBmkC,OAAqBnkC,EAAAA,GAAbwqB,SAkHf,IC9GKzgB,GAAa,CACfq6B,YAAapG,GACbh0B,cAAek6B,G","sources":["webpack:///../../../extensions/cornerstone-dicom-sr/src/id.js","webpack:///../../../extensions/cornerstone-dicom-sr/src/constants/scoordTypes.js","webpack:///../../../extensions/cornerstone-dicom-sr/src/tools/DICOMSRDisplayTool.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/tools/toolNames.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/utils/addMeasurement.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/utils/isRehydratable.js","webpack:///../../../extensions/cornerstone-dicom-sr/src/getSopClassHandlerModule.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/getHangingProtocolModule.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/utils/getFilteredCornerstoneToolState.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/commandsModule.js","webpack:///../../../extensions/cornerstone-dicom-sr/src/utils/addToolInstance.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/utils/createReferencedImageDisplaySet.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/index.tsx","webpack:///../../../extensions/cornerstone-dicom-sr/src/onModeEnter.js","webpack:///../../../extensions/cornerstone-dicom-sr/src/init.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/tools/modules/dicomSRModule.js","webpack:///../../../extensions/cornerstone-dicom-sr/src/utils/hydrateStructuredReport.js","webpack:///../../../extensions/cornerstone-dicom-sr/src/utils/getLabelFromDCMJSImportedToolData.js","webpack:///../../../../cornerstone3D/packages/adapters/src/adapters/helpers/toArray.ts","webpack:///../../../../cornerstone3D/packages/adapters/src/adapters/helpers/codeMeaningEquals.ts","webpack:///../../../../cornerstone3D/packages/adapters/src/adapters/Cornerstone/MeasurementReport.js","webpack:///../../../../cornerstone3D/packages/adapters/src/adapters/Cornerstone/cornerstone4Tag.js","webpack:///../../../../cornerstone3D/packages/adapters/src/adapters/Cornerstone/Length.js","webpack:///../../../../cornerstone3D/packages/adapters/src/adapters/Cornerstone/FreehandRoi.js","webpack:///../../../../cornerstone3D/packages/adapters/src/adapters/Cornerstone/Bidirectional.js","webpack:///../../../../cornerstone3D/packages/adapters/src/adapters/Cornerstone/EllipticalRoi.js","webpack:///../../../../cornerstone3D/packages/adapters/src/adapters/Cornerstone/CircleRoi.js","webpack:///../../../../cornerstone3D/packages/adapters/src/adapters/Cornerstone/ArrowAnnotate.js","webpack:///../../../../cornerstone3D/packages/adapters/src/adapters/Cornerstone/CobbAngle.js","webpack:///../../../../cornerstone3D/packages/adapters/src/adapters/Cornerstone/Angle.js","webpack:///../../../../cornerstone3D/packages/adapters/src/adapters/Cornerstone/RectangleRoi.js","webpack:///../../../../cornerstone3D/packages/adapters/src/adapters/Cornerstone/Segmentation_3X.js","webpack:///../../../../cornerstone3D/packages/adapters/src/adapters/enums/Events.ts","webpack:///../../../../cornerstone3D/packages/adapters/src/adapters/Cornerstone/Segmentation_4X.js","webpack:///../../../../cornerstone3D/packages/adapters/src/adapters/Cornerstone/index.ts","webpack:///../../../../cornerstone3D/packages/adapters/src/adapters/Cornerstone/Segmentation.js","webpack:///../../../../cornerstone3D/node_modules/tslib/tslib.es6.js","webpack:///../../../../cornerstone3D/packages/adapters/src/adapters/Cornerstone3D/cornerstone3DTag.js","webpack:///../../../../cornerstone3D/packages/adapters/src/adapters/Cornerstone3D/CodingScheme.js","webpack:///../../../../cornerstone3D/packages/adapters/src/adapters/Cornerstone3D/MeasurementReport.ts","webpack:///../../../../cornerstone3D/packages/adapters/src/adapters/Cornerstone3D/ArrowAnnotate.js","webpack:///../../../../cornerstone3D/packages/adapters/src/adapters/Cornerstone3D/Bidirectional.ts","webpack:///../../../../cornerstone3D/packages/adapters/src/adapters/Cornerstone3D/Angle.ts","webpack:///../../../../cornerstone3D/packages/adapters/src/adapters/Cornerstone3D/CobbAngle.ts","webpack:///../../../../cornerstone3D/packages/adapters/src/adapters/Cornerstone3D/isValidCornerstoneTrackingIdentifier.ts","webpack:///../../../../cornerstone3D/packages/adapters/src/adapters/Cornerstone3D/CircleROI.ts","webpack:///../../../../cornerstone3D/packages/adapters/src/adapters/Cornerstone3D/EllipticalROI.ts","webpack:///../../../../cornerstone3D/packages/adapters/src/adapters/Cornerstone3D/RectangleROI.ts","webpack:///../../../../cornerstone3D/packages/adapters/src/adapters/Cornerstone3D/Length.js","webpack:///../../../../cornerstone3D/packages/adapters/src/adapters/Cornerstone3D/PlanarFreehandROI.ts","webpack:///../../../../cornerstone3D/packages/adapters/src/adapters/Cornerstone3D/Probe.js","webpack:///../../../../cornerstone3D/packages/adapters/src/adapters/Cornerstone3D/Segmentation/generateSegmentation.ts","webpack:///../../../../cornerstone3D/packages/adapters/src/adapters/Cornerstone3D/Segmentation/generateToolState.ts","webpack:///../../../../cornerstone3D/packages/adapters/src/adapters/Cornerstone3D/index.ts","webpack:///../../../../cornerstone3D/packages/adapters/src/adapters/VTKjs/Segmentation.js","webpack:///../../../../cornerstone3D/packages/adapters/src/adapters/index.ts"],"sourcesContent":["import packageJson from '../package.json';\n\nconst id = packageJson.name;\n\nconst SOPClassHandlerName = 'dicom-sr';\nconst SOPClassHandlerId = `${id}.sopClassHandlerModule.${SOPClassHandlerName}`;\n\nexport { SOPClassHandlerName, SOPClassHandlerId, id };\n","export default {\n  POINT: 'POINT',\n  MULTIPOINT: 'MULTIPOINT',\n  POLYLINE: 'POLYLINE',\n  CIRCLE: 'CIRCLE',\n  ELLIPSE: 'ELLIPSE',\n};\n","import { Types, metaData, utilities as csUtils } from '@cornerstonejs/core';\nimport {\n  AnnotationTool,\n  annotation,\n  drawing,\n  utilities,\n  Types as cs3DToolsTypes,\n} from '@cornerstonejs/tools';\nimport { getTrackingUniqueIdentifiersForElement } from './modules/dicomSRModule';\nimport SCOORD_TYPES from '../constants/scoordTypes';\n\nexport default class DICOMSRDisplayTool extends AnnotationTool {\n  static toolName = 'DICOMSRDisplay';\n\n  constructor(\n    toolProps = {},\n    defaultToolProps = {\n      configuration: {},\n    }\n  ) {\n    super(toolProps, defaultToolProps);\n  }\n\n  _getTextBoxLinesFromLabels(labels) {\n    // TODO -> max 3 for now (label + shortAxis + longAxis), need a generic solution for this!\n\n    const labelLength = Math.min(labels.length, 3);\n    const lines = [];\n\n    for (let i = 0; i < labelLength; i++) {\n      const labelEntry = labels[i];\n      lines.push(`${_labelToShorthand(labelEntry.label)}${labelEntry.value}`);\n    }\n\n    return lines;\n  }\n\n  // This tool should not inherit from AnnotationTool and we should not need\n  // to add the following lines.\n  isPointNearTool = () => null;\n  getHandleNearImagePoint = () => null;\n\n  renderAnnotation = (\n    enabledElement: Types.IEnabledElement,\n    svgDrawingHelper: any\n  ): void => {\n    const { viewport } = enabledElement;\n    const { element } = viewport;\n\n    let annotations = annotation.state.getAnnotations(\n      this.getToolName(),\n      element\n    );\n\n    // Todo: We don't need this anymore, filtering happens in triggerAnnotationRender\n    if (!annotations?.length) {\n      return;\n    }\n\n    annotations = this.filterInteractableAnnotationsForElement(\n      element,\n      annotations\n    );\n\n    if (!annotations?.length) {\n      return;\n    }\n\n    const trackingUniqueIdentifiersForElement = getTrackingUniqueIdentifiersForElement(\n      element\n    );\n\n    const {\n      activeIndex,\n      trackingUniqueIdentifiers,\n    } = trackingUniqueIdentifiersForElement;\n\n    const activeTrackingUniqueIdentifier =\n      trackingUniqueIdentifiers[activeIndex];\n\n    // Filter toolData to only render the data for the active SR.\n    const filteredAnnotations = annotations.filter(annotation =>\n      trackingUniqueIdentifiers.includes(\n        annotation.data?.cachedStats?.TrackingUniqueIdentifier\n      )\n    );\n\n    if (!viewport._actors?.size) {\n      return;\n    }\n\n    const styleSpecifier: cs3DToolsTypes.AnnotationStyle.StyleSpecifier = {\n      toolGroupId: this.toolGroupId,\n      toolName: this.getToolName(),\n      viewportId: enabledElement.viewport.id,\n    };\n\n    for (let i = 0; i < filteredAnnotations.length; i++) {\n      const annotation = filteredAnnotations[i];\n      const annotationUID = annotation.annotationUID;\n      const { renderableData } = annotation.data.cachedStats;\n      const { cachedStats } = annotation.data;\n      const { referencedImageId } = annotation.metadata;\n\n      styleSpecifier.annotationUID = annotationUID;\n\n      const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n      const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n      const color =\n        cachedStats.TrackingUniqueIdentifier === activeTrackingUniqueIdentifier\n          ? 'rgb(0, 255, 0)'\n          : this.getStyle('color', styleSpecifier, annotation);\n\n      const options = {\n        color,\n        lineDash,\n        lineWidth,\n      };\n\n      Object.keys(renderableData).forEach(GraphicType => {\n        const renderableDataForGraphicType = renderableData[GraphicType];\n\n        let renderMethod;\n        let canvasCoordinatesAdapter;\n\n        switch (GraphicType) {\n          case SCOORD_TYPES.POINT:\n            renderMethod = this.renderPoint;\n            break;\n          case SCOORD_TYPES.MULTIPOINT:\n            renderMethod = this.renderMultipoint;\n            break;\n          case SCOORD_TYPES.POLYLINE:\n            renderMethod = this.renderPolyLine;\n            break;\n          case SCOORD_TYPES.CIRCLE:\n            renderMethod = this.renderEllipse;\n            break;\n          case SCOORD_TYPES.ELLIPSE:\n            renderMethod = this.renderEllipse;\n            canvasCoordinatesAdapter =\n              utilities.math.ellipse.getCanvasEllipseCorners;\n            break;\n          default:\n            throw new Error(`Unsupported GraphicType: ${GraphicType}`);\n        }\n\n        const canvasCoordinates = renderMethod(\n          svgDrawingHelper,\n          viewport,\n          renderableDataForGraphicType,\n          annotationUID,\n          referencedImageId,\n          options\n        );\n\n        this.renderTextBox(\n          svgDrawingHelper,\n          viewport,\n          canvasCoordinates,\n          canvasCoordinatesAdapter,\n          annotation,\n          styleSpecifier,\n          options\n        );\n      });\n    }\n  };\n\n  renderPolyLine(\n    svgDrawingHelper,\n    viewport,\n    renderableData,\n    annotationUID,\n    referencedImageId,\n    options\n  ) {\n    const drawingOptions = {\n      color: options.color,\n      width: options.lineWidth,\n    };\n    let allCanvasCoordinates = [];\n    renderableData.map((data, index) => {\n      const canvasCoordinates = data.map(p => viewport.worldToCanvas(p));\n      const lineUID = `${index}`;\n\n      if (canvasCoordinates.length === 2) {\n        drawing.drawLine(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          canvasCoordinates[0],\n          canvasCoordinates[1],\n          drawingOptions\n        );\n      } else {\n        drawing.drawPolyline(\n          svgDrawingHelper,\n          annotationUID,\n          lineUID,\n          canvasCoordinates,\n          drawingOptions\n        );\n      }\n\n      allCanvasCoordinates = allCanvasCoordinates.concat(canvasCoordinates);\n    });\n\n    return allCanvasCoordinates; // used for drawing textBox\n  }\n\n  renderMultipoint(\n    svgDrawingHelper,\n    viewport,\n    renderableData,\n    annotationUID,\n    referencedImageId,\n    options\n  ) {\n    let canvasCoordinates;\n    renderableData.map((data, index) => {\n      canvasCoordinates = data.map(p => viewport.worldToCanvas(p));\n      const handleGroupUID = '0';\n      drawing.drawHandles(\n        svgDrawingHelper,\n        annotationUID,\n        handleGroupUID,\n        canvasCoordinates,\n        {\n          color: options.color,\n        }\n      );\n    });\n  }\n\n  renderPoint(\n    svgDrawingHelper,\n    viewport,\n    renderableData,\n    annotationUID,\n    referencedImageId,\n    options\n  ) {\n    const canvasCoordinates = [];\n    renderableData.map((data, index) => {\n      const point = data[0];\n      // This gives us one point for arrow\n      canvasCoordinates.push(viewport.worldToCanvas(point));\n\n      // We get the other point for the arrow by using the image size\n      const imagePixelModule = metaData.get(\n        'imagePixelModule',\n        referencedImageId\n      );\n\n      let xOffset = 10;\n      let yOffset = 10;\n\n      if (imagePixelModule) {\n        const { columns, rows } = imagePixelModule;\n        xOffset = columns / 10;\n        yOffset = rows / 10;\n      }\n\n      const imagePoint = csUtils.worldToImageCoords(referencedImageId, point);\n      const arrowEnd = csUtils.imageToWorldCoords(referencedImageId, [\n        imagePoint[0] + xOffset,\n        imagePoint[1] + yOffset,\n      ]);\n\n      canvasCoordinates.push(viewport.worldToCanvas(arrowEnd));\n\n      const arrowUID = `${index}`;\n\n      // Todo: handle drawing probe as probe, currently we are drawing it as an arrow\n      drawing.drawArrow(\n        svgDrawingHelper,\n        annotationUID,\n        arrowUID,\n        canvasCoordinates[1],\n        canvasCoordinates[0],\n        {\n          color: options.color,\n          width: options.lineWidth,\n        }\n      );\n    });\n\n    return canvasCoordinates; // used for drawing textBox\n  }\n\n  renderEllipse(\n    svgDrawingHelper,\n    viewport,\n    renderableData,\n    annotationUID,\n    referencedImageId,\n    options\n  ) {\n    let canvasCoordinates;\n    renderableData.map((data, index) => {\n      if (data.length === 0) {\n        // since oblique ellipse is not supported for hydration right now\n        // we just return\n        return;\n      }\n\n      const ellipsePointsWorld = data;\n\n      const rotation = viewport.getRotation();\n\n      canvasCoordinates = ellipsePointsWorld.map(p =>\n        viewport.worldToCanvas(p)\n      );\n      let canvasCorners;\n      if (rotation == 90 || rotation == 270) {\n        canvasCorners = <Array<Types.Point2>>(\n          utilities.math.ellipse.getCanvasEllipseCorners([\n            canvasCoordinates[2],\n            canvasCoordinates[3],\n            canvasCoordinates[0],\n            canvasCoordinates[1],\n          ])\n        );\n      } else {\n        canvasCorners = <Array<Types.Point2>>(\n          utilities.math.ellipse.getCanvasEllipseCorners(canvasCoordinates)\n        );\n      }\n\n      const lineUID = `${index}`;\n      drawing.drawEllipse(\n        svgDrawingHelper,\n        annotationUID,\n        lineUID,\n        canvasCorners[0],\n        canvasCorners[1],\n        {\n          color: options.color,\n          width: options.lineWidth,\n        }\n      );\n    });\n\n    return canvasCoordinates;\n  }\n\n  renderTextBox(\n    svgDrawingHelper,\n    viewport,\n    canvasCoordinates,\n    canvasCoordinatesAdapter,\n    annotation,\n    styleSpecifier,\n    options = {}\n  ) {\n    if (!canvasCoordinates || !annotation) {\n      return;\n    }\n\n    const { annotationUID, data = {} } = annotation;\n    const { label } = data;\n    const { color } = options;\n\n    let adaptedCanvasCoordinates = canvasCoordinates;\n    // adapt coordinates if there is an adapter\n    if (typeof canvasCoordinatesAdapter === 'function') {\n      adaptedCanvasCoordinates = canvasCoordinatesAdapter(canvasCoordinates);\n    }\n    const textLines = this._getTextBoxLinesFromLabels(label);\n    const canvasTextBoxCoords = utilities.drawing.getTextBoxCoordsCanvas(\n      adaptedCanvasCoordinates\n    );\n\n    annotation.data.handles.textBox.worldPosition = viewport.canvasToWorld(\n      canvasTextBoxCoords\n    );\n\n    const textBoxPosition = viewport.worldToCanvas(\n      annotation.data.handles.textBox.worldPosition\n    );\n\n    const textBoxUID = '1';\n    const textBoxOptions = this.getLinkedTextBoxStyle(\n      styleSpecifier,\n      annotation\n    );\n\n    const boundingBox = drawing.drawLinkedTextBox(\n      svgDrawingHelper,\n      annotationUID,\n      textBoxUID,\n      textLines,\n      textBoxPosition,\n      canvasCoordinates,\n      {},\n      {\n        ...textBoxOptions,\n        color,\n      }\n    );\n\n    const { x: left, y: top, width, height } = boundingBox;\n\n    annotation.data.handles.textBox.worldBoundingBox = {\n      topLeft: viewport.canvasToWorld([left, top]),\n      topRight: viewport.canvasToWorld([left + width, top]),\n      bottomLeft: viewport.canvasToWorld([left, top + height]),\n      bottomRight: viewport.canvasToWorld([left + width, top + height]),\n    };\n  }\n}\n\nconst SHORT_HAND_MAP = {\n  'Short Axis': 'W: ',\n  'Long Axis': 'L: ',\n  AREA: 'Area: ',\n  Length: '',\n  CORNERSTONEFREETEXT: '',\n};\n\nfunction _labelToShorthand(label) {\n  const shortHand = SHORT_HAND_MAP[label];\n\n  if (shortHand !== undefined) {\n    return shortHand;\n  }\n\n  return label;\n}\n","import DICOMSRDisplayTool from './DICOMSRDisplayTool';\n\nconst toolNames = {\n  DICOMSRDisplay: DICOMSRDisplayTool.toolName,\n  SRLength: 'SRLength',\n  SRBidirectional: 'SRBidirectional',\n  SREllipticalROI: 'SREllipticalROI',\n  SRCircleROI: 'SRCircleROI',\n  SRArrowAnnotate: 'SRArrowAnnotate',\n  SRAngle: 'SRAngle',\n  SRCobbAngle: 'SRCobbAngle',\n  SRRectangleROI: 'SRRectangleROI',\n  SRPlanarFreehandROI: 'SRPlanarFreehandROI',\n};\n\nexport default toolNames;\n","import { vec3 } from 'gl-matrix';\nimport { Types, annotation } from '@cornerstonejs/tools';\nimport { metaData, utilities, Types as csTypes } from '@cornerstonejs/core';\nimport toolNames from '../tools/toolNames';\nimport SCOORD_TYPES from '../constants/scoordTypes';\n\nconst EPSILON = 1e-4;\n\nconst supportedLegacyCornerstoneTags = ['cornerstoneTools@^4.0.0'];\n\nexport default function addMeasurement(\n  measurement,\n  imageId,\n  displaySetInstanceUID\n) {\n  // TODO -> Render rotated ellipse .\n  const toolName = toolNames.DICOMSRDisplay;\n\n  const measurementData = {\n    TrackingUniqueIdentifier: measurement.TrackingUniqueIdentifier,\n    renderableData: {},\n    labels: measurement.labels,\n    imageId,\n  };\n\n  measurement.coords.forEach(coord => {\n    const { GraphicType, GraphicData } = coord;\n\n    if (measurementData.renderableData[GraphicType] === undefined) {\n      measurementData.renderableData[GraphicType] = [];\n    }\n\n    measurementData.renderableData[GraphicType].push(\n      _getRenderableData(\n        GraphicType,\n        GraphicData,\n        imageId,\n        measurement.TrackingIdentifier\n      )\n    );\n  });\n\n  // Use the metadata provider to grab its imagePlaneModule metadata\n  const imagePlaneModule = metaData.get('imagePlaneModule', imageId);\n\n  const annotationManager = annotation.state.getAnnotationManager();\n\n  // Create Cornerstone3D Annotation from measurement\n  const frameNumber =\n    (measurement.coords[0].ReferencedSOPSequence &&\n      measurement.coords[0].ReferencedSOPSequence[0]?.ReferencedFrameNumber) ||\n    1;\n\n  const SRAnnotation: Types.Annotation = {\n    annotationUID: measurement.TrackingUniqueIdentifier,\n    metadata: {\n      FrameOfReferenceUID: imagePlaneModule.frameOfReferenceUID,\n      toolName: toolName,\n      referencedImageId: imageId,\n    },\n    data: {\n      label: measurement.labels,\n      handles: {\n        textBox: {},\n      },\n      cachedStats: {\n        TrackingUniqueIdentifier: measurementData.TrackingUniqueIdentifier,\n        renderableData: measurementData.renderableData,\n      },\n      frameNumber: frameNumber,\n    },\n  };\n\n  annotationManager.addAnnotation(SRAnnotation);\n\n  measurement.loaded = true;\n  measurement.imageId = imageId;\n  measurement.displaySetInstanceUID = displaySetInstanceUID;\n\n  // Remove the unneeded coord now its processed, but keep the SOPInstanceUID.\n  // NOTE: We assume that each SCOORD in the MeasurementGroup maps onto one frame,\n  // It'd be super weird if it didn't anyway as a SCOORD.\n  measurement.ReferencedSOPInstanceUID =\n    measurement.coords[0].ReferencedSOPSequence.ReferencedSOPInstanceUID;\n  measurement.frameNumber = frameNumber;\n  delete measurement.coords;\n}\n\nfunction _getRenderableData(\n  GraphicType,\n  GraphicData,\n  imageId,\n  TrackingIdentifier\n) {\n  const [cornerstoneTag, toolName] = TrackingIdentifier.split(':');\n\n  let renderableData: csTypes.Point3[];\n\n  switch (GraphicType) {\n    case SCOORD_TYPES.POINT:\n    case SCOORD_TYPES.MULTIPOINT:\n    case SCOORD_TYPES.POLYLINE:\n      renderableData = [];\n\n      for (let i = 0; i < GraphicData.length; i += 2) {\n        const worldPos = utilities.imageToWorldCoords(imageId, [\n          GraphicData[i],\n          GraphicData[i + 1],\n        ]);\n\n        renderableData.push(worldPos);\n      }\n\n      break;\n    case SCOORD_TYPES.CIRCLE: {\n      const pointsWorld = [];\n      for (let i = 0; i < GraphicData.length; i += 2) {\n        const worldPos = utilities.imageToWorldCoords(imageId, [\n          GraphicData[i],\n          GraphicData[i + 1],\n        ]);\n\n        pointsWorld.push(worldPos);\n      }\n\n      // We do not have an explicit draw circle svg helper in Cornerstone3D at\n      // this time, but we can use the ellipse svg helper to draw a circle, so\n      // here we reshape the data for that purpose.\n      const center = pointsWorld[0];\n      const onPerimeter = pointsWorld[1];\n\n      const radius = vec3.distance(center, onPerimeter);\n\n      const imagePlaneModule = metaData.get('imagePlaneModule', imageId);\n\n      if (!imagePlaneModule) {\n        throw new Error('No imagePlaneModule found');\n      }\n\n      const {\n        columnCosines,\n        rowCosines,\n      }: {\n        columnCosines: csTypes.Point3;\n        rowCosines: csTypes.Point3;\n      } = imagePlaneModule;\n\n      // we need to get major/minor axis (which are both the same size major = minor)\n\n      // first axisStart\n      const firstAxisStart = vec3.create();\n      vec3.scaleAndAdd(firstAxisStart, center, columnCosines, radius);\n\n      const firstAxisEnd = vec3.create();\n      vec3.scaleAndAdd(firstAxisEnd, center, columnCosines, -radius);\n\n      // second axisStart\n      const secondAxisStart = vec3.create();\n      vec3.scaleAndAdd(secondAxisStart, center, rowCosines, radius);\n\n      const secondAxisEnd = vec3.create();\n      vec3.scaleAndAdd(secondAxisEnd, center, rowCosines, -radius);\n\n      renderableData = [\n        firstAxisStart as csTypes.Point3,\n        firstAxisEnd as csTypes.Point3,\n        secondAxisStart as csTypes.Point3,\n        secondAxisEnd as csTypes.Point3,\n      ];\n\n      break;\n    }\n    case SCOORD_TYPES.ELLIPSE: {\n      // GraphicData is ordered as [majorAxisStartX, majorAxisStartY, majorAxisEndX, majorAxisEndY, minorAxisStartX, minorAxisStartY, minorAxisEndX, minorAxisEndY]\n      // But Cornerstone3D points are ordered as top, bottom, left, right for the\n      // ellipse so we need to identify if the majorAxis is horizontal or vertical\n      // and then choose the correct points to use for the ellipse.\n\n      const pointsWorld: csTypes.Point3[] = [];\n      for (let i = 0; i < GraphicData.length; i += 2) {\n        const worldPos = utilities.imageToWorldCoords(imageId, [\n          GraphicData[i],\n          GraphicData[i + 1],\n        ]);\n\n        pointsWorld.push(worldPos);\n      }\n\n      const majorAxisStart = vec3.fromValues(...pointsWorld[0]);\n      const majorAxisEnd = vec3.fromValues(...pointsWorld[1]);\n      const minorAxisStart = vec3.fromValues(...pointsWorld[2]);\n      const minorAxisEnd = vec3.fromValues(...pointsWorld[3]);\n\n      const majorAxisVec = vec3.create();\n      vec3.sub(majorAxisVec, majorAxisEnd, majorAxisStart);\n\n      // normalize majorAxisVec to avoid scaling issues\n      vec3.normalize(majorAxisVec, majorAxisVec);\n\n      const minorAxisVec = vec3.create();\n      vec3.sub(minorAxisVec, minorAxisEnd, minorAxisStart);\n      vec3.normalize(minorAxisVec, minorAxisVec);\n\n      const imagePlaneModule = metaData.get('imagePlaneModule', imageId);\n\n      if (!imagePlaneModule) {\n        throw new Error('imageId does not have imagePlaneModule metadata');\n      }\n\n      const {\n        columnCosines,\n      }: { columnCosines: csTypes.Point3 } = imagePlaneModule;\n\n      // find which axis is parallel to the columnCosines\n      const columnCosinesVec = vec3.fromValues(...columnCosines);\n\n      const projectedMajorAxisOnColVec = Math.abs(\n        vec3.dot(columnCosinesVec, majorAxisVec)\n      );\n      const projectedMinorAxisOnColVec = Math.abs(\n        vec3.dot(columnCosinesVec, minorAxisVec)\n      );\n\n      const absoluteOfMajorDotProduct = Math.abs(projectedMajorAxisOnColVec);\n      const absoluteOfMinorDotProduct = Math.abs(projectedMinorAxisOnColVec);\n\n      renderableData = [];\n      if (Math.abs(absoluteOfMajorDotProduct - 1) < EPSILON) {\n        renderableData = [\n          pointsWorld[0],\n          pointsWorld[1],\n          pointsWorld[2],\n          pointsWorld[3],\n        ];\n      } else if (Math.abs(absoluteOfMinorDotProduct - 1) < EPSILON) {\n        renderableData = [\n          pointsWorld[2],\n          pointsWorld[3],\n          pointsWorld[0],\n          pointsWorld[1],\n        ];\n      } else {\n        console.warn('OBLIQUE ELLIPSE NOT YET SUPPORTED');\n      }\n      break;\n    }\n    default:\n      console.warn('Unsupported GraphicType:', GraphicType);\n  }\n\n  return renderableData;\n}\n","import { adaptersSR } from '@cornerstonejs/adapters';\n\nconst cornerstoneAdapters =\n  adaptersSR.Cornerstone3D.MeasurementReport\n    .CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE;\n\nconst supportedLegacyCornerstoneTags = ['cornerstoneTools@^4.0.0'];\nconst CORNERSTONE_3D_TAG = cornerstoneAdapters.CORNERSTONE_3D_TAG;\n\n/**\n * Checks if the given `displaySet`can be rehydrated into the `measurementService`.\n *\n * @param {object} displaySet The SR `displaySet` to check.\n * @param {object[]} mappings The CornerstoneTools 4 mappings to the `measurementService`.\n * @returns {boolean} True if the SR can be rehydrated into the `measurementService`.\n */\nexport default function isRehydratable(displaySet, mappings) {\n  if (!mappings || !mappings.length) {\n    return false;\n  }\n\n  const mappingDefinitions = mappings.map(m => m.annotationType);\n  const { measurements } = displaySet;\n\n  const adapterKeys = Object.keys(cornerstoneAdapters).filter(\n    adapterKey =>\n      typeof cornerstoneAdapters[adapterKey]\n        .isValidCornerstoneTrackingIdentifier === 'function'\n  );\n\n  const adapters = [];\n\n  adapterKeys.forEach(key => {\n    if (mappingDefinitions.includes(key)) {\n      // Must have both a dcmjs adapter and a measurementService\n      // Definition in order to be a candidate for import.\n      adapters.push(cornerstoneAdapters[key]);\n    }\n  });\n\n  for (let i = 0; i < measurements.length; i++) {\n    const { TrackingIdentifier } = measurements[i] || {};\n    const hydratable = adapters.some(adapter => {\n      let [cornerstoneTag, toolName] = TrackingIdentifier.split(':');\n      if (supportedLegacyCornerstoneTags.includes(cornerstoneTag)) {\n        cornerstoneTag = CORNERSTONE_3D_TAG;\n      }\n\n      const mappedTrackingIdentifier = `${cornerstoneTag}:${toolName}`;\n\n      return adapter.isValidCornerstoneTrackingIdentifier(\n        mappedTrackingIdentifier\n      );\n    });\n\n    if (hydratable) {\n      return true;\n    }\n    console.log(\n      'Measurement is not rehydratable',\n      TrackingIdentifier,\n      measurements[i]\n    );\n  }\n\n  console.log('No measurements found which were rehydratable');\n  return false;\n}\n","import { SOPClassHandlerName, SOPClassHandlerId } from './id';\nimport { utils, classes, DisplaySetService, Types } from '@ohif/core';\nimport addMeasurement from './utils/addMeasurement';\nimport isRehydratable from './utils/isRehydratable';\nimport { adaptersSR } from '@cornerstonejs/adapters';\n\ntype InstanceMetadata = Types.InstanceMetadata;\n\nconst { CodeScheme: Cornerstone3DCodeScheme } = adaptersSR.Cornerstone3D;\n\nconst { ImageSet, MetadataProvider: metadataProvider } = classes;\n\n// TODO ->\n// Add SR thumbnail\n// Make viewport\n// Get stacks from referenced displayInstanceUID and load into wrapped CornerStone viewport.\n\nconst sopClassUids = [\n  '1.2.840.10008.5.1.4.1.1.88.11', //BASIC_TEXT_SR:\n  '1.2.840.10008.5.1.4.1.1.88.22', //ENHANCED_SR:\n  '1.2.840.10008.5.1.4.1.1.88.33', //COMPREHENSIVE_SR:\n  '1.2.840.10008.5.1.4.1.1.88.34', //COMPREHENSIVE_3D_SR:\n];\n\nconst CORNERSTONE_3D_TOOLS_SOURCE_NAME = 'Cornerstone3DTools';\nconst CORNERSTONE_3D_TOOLS_SOURCE_VERSION = '0.1';\n\nconst validateSameStudyUID = (uid: string, instances): void => {\n  instances.forEach(it => {\n    if (it.StudyInstanceUID !== uid) {\n      console.warn('Not all instances have the same UID', uid, it);\n      throw new Error(\n        `Instances ${it.SOPInstanceUID} does not belong to ${uid}`\n      );\n    }\n  });\n};\n\nconst CodeNameCodeSequenceValues = {\n  ImagingMeasurementReport: '126000',\n  ImageLibrary: '111028',\n  ImagingMeasurements: '126010',\n  MeasurementGroup: '125007',\n  ImageLibraryGroup: '126200',\n  TrackingUniqueIdentifier: '112040',\n  TrackingIdentifier: '112039',\n  Finding: '121071',\n  FindingSite: 'G-C0E3', // SRT\n  CornerstoneFreeText: Cornerstone3DCodeScheme.codeValues.CORNERSTONEFREETEXT, //\n};\n\nconst CodingSchemeDesignators = {\n  SRT: 'SRT',\n  CornerstoneCodeSchemes: [\n    Cornerstone3DCodeScheme.CodingSchemeDesignator,\n    'CST4',\n  ],\n};\n\nconst RELATIONSHIP_TYPE = {\n  INFERRED_FROM: 'INFERRED FROM',\n  CONTAINS: 'CONTAINS',\n};\n\nconst CORNERSTONE_FREETEXT_CODE_VALUE = 'CORNERSTONEFREETEXT';\n\n/**\n * Adds instances to the DICOM SR series, rather than creating a new\n * series, so that as SR's are saved, they append to the series, and the\n * key image display set gets updated as well, containing just the new series.\n * @param instances is a list of instances from THIS series that are not\n *     in this DICOM SR Display Set already.\n */\nfunction addInstances(\n  instances: InstanceMetadata[],\n  displaySetService: DisplaySetService\n) {\n  this.instances.push(...instances);\n  utils.sortStudyInstances(this.instances);\n  // The last instance is the newest one, so is the one most interesting.\n  // Eventually, the SR viewer should have the ability to choose which SR\n  // gets loaded, and to navigate among them.\n  this.instance = this.instances[this.instances.length - 1];\n  this.isLoaded = false;\n  return this;\n}\n\n/**\n * DICOM SR SOP Class Handler\n * For all referenced images in the TID 1500/300 sections, add an image to the\n * display.\n * @param instances is a set of instances all from the same series\n * @param servicesManager is the services that can be used for creating\n * @returns The list of display sets created for the given instances object\n */\nfunction _getDisplaySetsFromSeries(\n  instances,\n  servicesManager,\n  extensionManager\n) {\n  // If the series has no instances, stop here\n  if (!instances || !instances.length) {\n    throw new Error('No instances were provided');\n  }\n\n  utils.sortStudyInstances(instances);\n  // The last instance is the newest one, so is the one most interesting.\n  // Eventually, the SR viewer should have the ability to choose which SR\n  // gets loaded, and to navigate among them.\n  const instance = instances[instances.length - 1];\n\n  const {\n    StudyInstanceUID,\n    SeriesInstanceUID,\n    SOPInstanceUID,\n    SeriesDescription,\n    SeriesNumber,\n    SeriesDate,\n    ConceptNameCodeSequence,\n    SOPClassUID,\n  } = instance;\n  validateSameStudyUID(instance.StudyInstanceUID, instances);\n\n  if (\n    !ConceptNameCodeSequence ||\n    ConceptNameCodeSequence.CodeValue !==\n      CodeNameCodeSequenceValues.ImagingMeasurementReport\n  ) {\n    servicesManager.services.uiNotificationService.show({\n      title: 'DICOM SR',\n      message:\n        'OHIF only supports TID1500 Imaging Measurement Report Structured Reports. The SR youre trying to view is not supported.',\n      type: 'warning',\n      duration: 6000,\n    });\n    return [];\n  }\n\n  const displaySet = {\n    //plugin: id,\n    Modality: 'SR',\n    displaySetInstanceUID: utils.guid(),\n    SeriesDescription,\n    SeriesNumber,\n    SeriesDate,\n    SOPInstanceUID,\n    SeriesInstanceUID,\n    StudyInstanceUID,\n    SOPClassHandlerId,\n    SOPClassUID,\n    instances,\n    referencedImages: null,\n    measurements: null,\n    isDerivedDisplaySet: true,\n    isLoaded: false,\n    sopClassUids,\n    instance,\n    addInstances,\n  };\n\n  displaySet.load = () => _load(displaySet, servicesManager, extensionManager);\n\n  return [displaySet];\n}\n\nfunction _load(displaySet, servicesManager, extensionManager) {\n  const { displaySetService, measurementService } = servicesManager.services;\n  const dataSources = extensionManager.getDataSources();\n  const dataSource = dataSources[0];\n\n  const { ContentSequence } = displaySet.instance;\n\n  displaySet.referencedImages = _getReferencedImagesList(ContentSequence);\n  displaySet.measurements = _getMeasurements(ContentSequence);\n\n  const mappings = measurementService.getSourceMappings(\n    CORNERSTONE_3D_TOOLS_SOURCE_NAME,\n    CORNERSTONE_3D_TOOLS_SOURCE_VERSION\n  );\n\n  displaySet.isHydrated = false;\n  displaySet.isRehydratable = isRehydratable(displaySet, mappings);\n  displaySet.isLoaded = true;\n\n  // Check currently added displaySets and add measurements if the sources exist.\n  displaySetService.activeDisplaySets.forEach(activeDisplaySet => {\n    _checkIfCanAddMeasurementsToDisplaySet(\n      displaySet,\n      activeDisplaySet,\n      dataSource\n    );\n  });\n\n  // Subscribe to new displaySets as the source may come in after.\n  displaySetService.subscribe(\n    displaySetService.EVENTS.DISPLAY_SETS_ADDED,\n    data => {\n      const { displaySetsAdded } = data;\n      // If there are still some measurements that have not yet been loaded into cornerstone,\n      // See if we can load them onto any of the new displaySets.\n      displaySetsAdded.forEach(newDisplaySet => {\n        _checkIfCanAddMeasurementsToDisplaySet(\n          displaySet,\n          newDisplaySet,\n          dataSource\n        );\n      });\n    }\n  );\n}\n\nfunction _checkIfCanAddMeasurementsToDisplaySet(\n  srDisplaySet,\n  newDisplaySet,\n  dataSource\n) {\n  let unloadedMeasurements = srDisplaySet.measurements.filter(\n    measurement => measurement.loaded === false\n  );\n\n  if (unloadedMeasurements.length === 0) {\n    // All already loaded!\n    return;\n  }\n\n  if (!newDisplaySet instanceof ImageSet) {\n    // This also filters out _this_ displaySet, as it is not an ImageSet.\n    return;\n  }\n\n  const { sopClassUids, images } = newDisplaySet;\n\n  // Check if any have the newDisplaySet is the correct SOPClass.\n  unloadedMeasurements = unloadedMeasurements.filter(measurement =>\n    measurement.coords.some(coord =>\n      sopClassUids.includes(coord.ReferencedSOPSequence.ReferencedSOPClassUID)\n    )\n  );\n\n  if (unloadedMeasurements.length === 0) {\n    // New displaySet isn't the correct SOPClass, so can't contain the referenced images.\n    return;\n  }\n\n  const SOPInstanceUIDs = [];\n\n  unloadedMeasurements.forEach(measurement => {\n    const { coords } = measurement;\n\n    coords.forEach(coord => {\n      const SOPInstanceUID =\n        coord.ReferencedSOPSequence.ReferencedSOPInstanceUID;\n\n      if (!SOPInstanceUIDs.includes(SOPInstanceUID)) {\n        SOPInstanceUIDs.push(SOPInstanceUID);\n      }\n    });\n  });\n\n  const imageIdsForDisplaySet = dataSource.getImageIdsForDisplaySet(\n    newDisplaySet\n  );\n\n  for (const imageId of imageIdsForDisplaySet) {\n    if (!unloadedMeasurements.length) {\n      // All measurements loaded.\n      return;\n    }\n\n    const { SOPInstanceUID, frameNumber } = metadataProvider.getUIDsFromImageID(\n      imageId\n    );\n\n    if (SOPInstanceUIDs.includes(SOPInstanceUID)) {\n      for (let j = unloadedMeasurements.length - 1; j >= 0; j--) {\n        const measurement = unloadedMeasurements[j];\n        if (\n          _measurementReferencesSOPInstanceUID(\n            measurement,\n            SOPInstanceUID,\n            frameNumber\n          )\n        ) {\n          addMeasurement(\n            measurement,\n            imageId,\n            newDisplaySet.displaySetInstanceUID\n          );\n\n          unloadedMeasurements.splice(j, 1);\n        }\n      }\n    }\n  }\n}\n\nfunction _measurementReferencesSOPInstanceUID(\n  measurement,\n  SOPInstanceUID,\n  frameNumber\n) {\n  const { coords } = measurement;\n\n  // NOTE: The ReferencedFrameNumber can be multiple values according to the DICOM\n  //  Standard. But for now, we will support only one ReferenceFrameNumber.\n  const ReferencedFrameNumber =\n    (measurement.coords[0].ReferencedSOPSequence &&\n      measurement.coords[0].ReferencedSOPSequence[0]?.ReferencedFrameNumber) ||\n    1;\n\n  if (frameNumber && Number(frameNumber) !== Number(ReferencedFrameNumber))\n    return false;\n\n  for (let j = 0; j < coords.length; j++) {\n    const coord = coords[j];\n    const { ReferencedSOPInstanceUID } = coord.ReferencedSOPSequence;\n\n    if (ReferencedSOPInstanceUID === SOPInstanceUID) {\n      return true;\n    }\n  }\n}\n\nfunction getSopClassHandlerModule({ servicesManager, extensionManager }) {\n  const getDisplaySetsFromSeries = instances => {\n    return _getDisplaySetsFromSeries(\n      instances,\n      servicesManager,\n      extensionManager\n    );\n  };\n\n  return [\n    {\n      name: SOPClassHandlerName,\n      sopClassUids,\n      getDisplaySetsFromSeries,\n    },\n  ];\n}\n\nfunction _getMeasurements(ImagingMeasurementReportContentSequence) {\n  const ImagingMeasurements = ImagingMeasurementReportContentSequence.find(\n    item =>\n      item.ConceptNameCodeSequence.CodeValue ===\n      CodeNameCodeSequenceValues.ImagingMeasurements\n  );\n\n  const MeasurementGroups = _getSequenceAsArray(\n    ImagingMeasurements.ContentSequence\n  ).filter(\n    item =>\n      item.ConceptNameCodeSequence.CodeValue ===\n      CodeNameCodeSequenceValues.MeasurementGroup\n  );\n\n  const mergedContentSequencesByTrackingUniqueIdentifiers = _getMergedContentSequencesByTrackingUniqueIdentifiers(\n    MeasurementGroups\n  );\n\n  const measurements = [];\n\n  Object.keys(mergedContentSequencesByTrackingUniqueIdentifiers).forEach(\n    trackingUniqueIdentifier => {\n      const mergedContentSequence =\n        mergedContentSequencesByTrackingUniqueIdentifiers[\n          trackingUniqueIdentifier\n        ];\n\n      const measurement = _processMeasurement(mergedContentSequence);\n\n      if (measurement) {\n        measurements.push(measurement);\n      }\n    }\n  );\n\n  return measurements;\n}\n\nfunction _getMergedContentSequencesByTrackingUniqueIdentifiers(\n  MeasurementGroups\n) {\n  const mergedContentSequencesByTrackingUniqueIdentifiers = {};\n\n  MeasurementGroups.forEach(MeasurementGroup => {\n    const ContentSequence = _getSequenceAsArray(\n      MeasurementGroup.ContentSequence\n    );\n\n    const TrackingUniqueIdentifierItem = ContentSequence.find(\n      item =>\n        item.ConceptNameCodeSequence.CodeValue ===\n        CodeNameCodeSequenceValues.TrackingUniqueIdentifier\n    );\n\n    if (!TrackingUniqueIdentifierItem) {\n      console.warn(\n        'No Tracking Unique Identifier, skipping ambiguous measurement.'\n      );\n    }\n\n    const trackingUniqueIdentifier = TrackingUniqueIdentifierItem.UID;\n\n    if (\n      mergedContentSequencesByTrackingUniqueIdentifiers[\n        trackingUniqueIdentifier\n      ] === undefined\n    ) {\n      // Add the full ContentSequence\n      mergedContentSequencesByTrackingUniqueIdentifiers[\n        trackingUniqueIdentifier\n      ] = [...ContentSequence];\n    } else {\n      // Add the ContentSequence minus the tracking identifier, as we have this\n      // Information in the merged ContentSequence anyway.\n      ContentSequence.forEach(item => {\n        if (\n          item.ConceptNameCodeSequence.CodeValue !==\n          CodeNameCodeSequenceValues.TrackingUniqueIdentifier\n        ) {\n          mergedContentSequencesByTrackingUniqueIdentifiers[\n            trackingUniqueIdentifier\n          ].push(item);\n        }\n      });\n    }\n  });\n\n  return mergedContentSequencesByTrackingUniqueIdentifiers;\n}\n\nfunction _processMeasurement(mergedContentSequence) {\n  if (\n    mergedContentSequence.some(\n      group => group.ValueType === 'SCOORD' || group.ValueType === 'SCOORD3D'\n    )\n  ) {\n    return _processTID1410Measurement(mergedContentSequence);\n  }\n\n  return _processNonGeometricallyDefinedMeasurement(mergedContentSequence);\n}\n\nfunction _processTID1410Measurement(mergedContentSequence) {\n  // Need to deal with TID 1410 style measurements, which will have a SCOORD or SCOORD3D at the top level,\n  // And non-geometric representations where each NUM has \"INFERRED FROM\" SCOORD/SCOORD3D\n\n  const graphicItem = mergedContentSequence.find(\n    group => group.ValueType === 'SCOORD'\n  );\n\n  const UIDREFContentItem = mergedContentSequence.find(\n    group => group.ValueType === 'UIDREF'\n  );\n\n  const TrackingIdentifierContentItem = mergedContentSequence.find(\n    item =>\n      item.ConceptNameCodeSequence.CodeValue ===\n      CodeNameCodeSequenceValues.TrackingIdentifier\n  );\n\n  if (!graphicItem) {\n    console.warn(\n      `graphic ValueType ${graphicItem.ValueType} not currently supported, skipping annotation.`\n    );\n    return;\n  }\n\n  const NUMContentItems = mergedContentSequence.filter(\n    group => group.ValueType === 'NUM'\n  );\n\n  const measurement = {\n    loaded: false,\n    labels: [],\n    coords: [_getCoordsFromSCOORDOrSCOORD3D(graphicItem)],\n    TrackingUniqueIdentifier: UIDREFContentItem.UID,\n    TrackingIdentifier: TrackingIdentifierContentItem.TextValue,\n  };\n\n  NUMContentItems.forEach(item => {\n    const { ConceptNameCodeSequence, MeasuredValueSequence } = item;\n\n    if (MeasuredValueSequence) {\n      measurement.labels.push(\n        _getLabelFromMeasuredValueSequence(\n          ConceptNameCodeSequence,\n          MeasuredValueSequence\n        )\n      );\n    }\n  });\n\n  return measurement;\n}\n\nfunction _processNonGeometricallyDefinedMeasurement(mergedContentSequence) {\n  const NUMContentItems = mergedContentSequence.filter(\n    group => group.ValueType === 'NUM'\n  );\n\n  const UIDREFContentItem = mergedContentSequence.find(\n    group => group.ValueType === 'UIDREF'\n  );\n\n  const TrackingIdentifierContentItem = mergedContentSequence.find(\n    item =>\n      item.ConceptNameCodeSequence.CodeValue ===\n      CodeNameCodeSequenceValues.TrackingIdentifier\n  );\n\n  const finding = mergedContentSequence.find(\n    item =>\n      item.ConceptNameCodeSequence.CodeValue ===\n      CodeNameCodeSequenceValues.Finding\n  );\n\n  const findingSites = mergedContentSequence.filter(\n    item =>\n      item.ConceptNameCodeSequence.CodingSchemeDesignator ===\n        CodingSchemeDesignators.SRT &&\n      item.ConceptNameCodeSequence.CodeValue ===\n        CodeNameCodeSequenceValues.FindingSite\n  );\n\n  const measurement = {\n    loaded: false,\n    labels: [],\n    coords: [],\n    TrackingUniqueIdentifier: UIDREFContentItem.UID,\n    TrackingIdentifier: TrackingIdentifierContentItem.TextValue,\n  };\n\n  if (\n    finding &&\n    CodingSchemeDesignators.CornerstoneCodeSchemes.includes(\n      finding.ConceptCodeSequence.CodingSchemeDesignator\n    ) &&\n    finding.ConceptCodeSequence.CodeValue ===\n      CodeNameCodeSequenceValues.CornerstoneFreeText\n  ) {\n    measurement.labels.push({\n      label: CORNERSTONE_FREETEXT_CODE_VALUE,\n      value: finding.ConceptCodeSequence.CodeMeaning,\n    });\n  }\n\n  // TODO -> Eventually hopefully support SNOMED or some proper code library, just free text for now.\n  if (findingSites.length) {\n    const cornerstoneFreeTextFindingSite = findingSites.find(\n      FindingSite =>\n        CodingSchemeDesignators.CornerstoneCodeSchemes.includes(\n          FindingSite.ConceptCodeSequence.CodingSchemeDesignator\n        ) &&\n        FindingSite.ConceptCodeSequence.CodeValue ===\n          CodeNameCodeSequenceValues.CornerstoneFreeText\n    );\n\n    if (cornerstoneFreeTextFindingSite) {\n      measurement.labels.push({\n        label: CORNERSTONE_FREETEXT_CODE_VALUE,\n        value: cornerstoneFreeTextFindingSite.ConceptCodeSequence.CodeMeaning,\n      });\n    }\n  }\n\n  NUMContentItems.forEach(item => {\n    const {\n      ConceptNameCodeSequence,\n      ContentSequence,\n      MeasuredValueSequence,\n    } = item;\n\n    const { ValueType } = ContentSequence;\n\n    if (!ValueType === 'SCOORD') {\n      console.warn(\n        `Graphic ${ValueType} not currently supported, skipping annotation.`\n      );\n\n      return;\n    }\n\n    const coords = _getCoordsFromSCOORDOrSCOORD3D(ContentSequence);\n\n    if (coords) {\n      measurement.coords.push(coords);\n    }\n\n    if (MeasuredValueSequence) {\n      measurement.labels.push(\n        _getLabelFromMeasuredValueSequence(\n          ConceptNameCodeSequence,\n          MeasuredValueSequence\n        )\n      );\n    }\n  });\n\n  return measurement;\n}\n\nfunction _getCoordsFromSCOORDOrSCOORD3D(item) {\n  const { ValueType, RelationshipType, GraphicType, GraphicData } = item;\n\n  if (\n    !(\n      RelationshipType == RELATIONSHIP_TYPE.INFERRED_FROM ||\n      RelationshipType == RELATIONSHIP_TYPE.CONTAINS\n    )\n  ) {\n    console.warn(\n      `Relationshiptype === ${RelationshipType}. Cannot deal with NON TID-1400 SCOORD group with RelationshipType !== \"INFERRED FROM\" or \"CONTAINS\"`\n    );\n\n    return;\n  }\n\n  const coords = { ValueType, GraphicType, GraphicData };\n\n  // ContentSequence has length of 1 as RelationshipType === 'INFERRED FROM'\n  if (ValueType === 'SCOORD') {\n    const { ReferencedSOPSequence } = item.ContentSequence;\n\n    coords.ReferencedSOPSequence = ReferencedSOPSequence;\n  } else if (ValueType === 'SCOORD3D') {\n    const { ReferencedFrameOfReferenceSequence } = item.ContentSequence;\n\n    coords.ReferencedFrameOfReferenceSequence = ReferencedFrameOfReferenceSequence;\n  }\n\n  return coords;\n}\n\nfunction _getLabelFromMeasuredValueSequence(\n  ConceptNameCodeSequence,\n  MeasuredValueSequence\n) {\n  const { CodeMeaning } = ConceptNameCodeSequence;\n  const { NumericValue, MeasurementUnitsCodeSequence } = MeasuredValueSequence;\n  const { CodeValue } = MeasurementUnitsCodeSequence;\n\n  const formatedNumericValue = NumericValue\n    ? Number(NumericValue).toFixed(2)\n    : '';\n\n  return {\n    label: CodeMeaning,\n    value: `${formatedNumericValue} ${CodeValue}`,\n  }; // E.g. Long Axis: 31.0 mm\n}\n\nfunction _getReferencedImagesList(ImagingMeasurementReportContentSequence) {\n  const ImageLibrary = ImagingMeasurementReportContentSequence.find(\n    item =>\n      item.ConceptNameCodeSequence.CodeValue ===\n      CodeNameCodeSequenceValues.ImageLibrary\n  );\n\n  const ImageLibraryGroup = _getSequenceAsArray(\n    ImageLibrary.ContentSequence\n  ).find(\n    item =>\n      item.ConceptNameCodeSequence.CodeValue ===\n      CodeNameCodeSequenceValues.ImageLibraryGroup\n  );\n\n  const referencedImages = [];\n\n  _getSequenceAsArray(ImageLibraryGroup.ContentSequence).forEach(item => {\n    const { ReferencedSOPSequence } = item;\n    if (!ReferencedSOPSequence) return;\n    for (const ref of _getSequenceAsArray(ReferencedSOPSequence)) {\n      if (ref.ReferencedSOPClassUID) {\n        const { ReferencedSOPClassUID, ReferencedSOPInstanceUID } = ref;\n\n        referencedImages.push({\n          ReferencedSOPClassUID,\n          ReferencedSOPInstanceUID,\n        });\n      }\n    }\n  });\n\n  return referencedImages;\n}\n\nfunction _getSequenceAsArray(sequence) {\n  if (!sequence) return [];\n  return Array.isArray(sequence) ? sequence : [sequence];\n}\n\nexport default getSopClassHandlerModule;\n","import { Types } from '@ohif/core';\n\nconst srProtocol: Types.HangingProtocol.Protocol = {\n  id: '@ohif/sr',\n  // Don't store this hanging protocol as it applies to the currently active\n  // display set by default\n  // cacheId: null,\n  hasUpdatedPriorsInformation: false,\n  name: 'SR Key Images',\n  // Just apply this one when specifically listed\n  protocolMatchingRules: [],\n  toolGroupIds: ['default'],\n  // -1 would be used to indicate active only, whereas other values are\n  // the number of required priors referenced - so 0 means active with\n  // 0 or more priors.\n  numberOfPriorsReferenced: 0,\n  // Default viewport is used to define the viewport when\n  // additional viewports are added using the layout tool\n  defaultViewport: {\n    viewportOptions: {\n      viewportType: 'stack',\n      toolGroupId: 'default',\n      allowUnmatchedView: true,\n    },\n    displaySets: [\n      {\n        id: 'srDisplaySetId',\n        matchedDisplaySetsIndex: -1,\n      },\n    ],\n  },\n  displaySetSelectors: {\n    srDisplaySetId: {\n      seriesMatchingRules: [\n        {\n          attribute: 'Modality',\n          constraint: {\n            equals: 'SR',\n          },\n        },\n      ],\n    },\n  },\n  stages: [\n    {\n      name: 'SR Key Images',\n      viewportStructure: {\n        layoutType: 'grid',\n        properties: {\n          rows: 1,\n          columns: 1,\n        },\n      },\n      viewports: [\n        {\n          viewportOptions: { allowUnmatchedView: true },\n          displaySets: [\n            {\n              id: 'srDisplaySetId',\n            },\n          ],\n        },\n      ],\n    },\n  ],\n};\n\nfunction getHangingProtocolModule() {\n  return [\n    {\n      name: srProtocol.id,\n      protocol: srProtocol,\n    },\n  ];\n}\n\nexport default getHangingProtocolModule;\nexport { srProtocol };\n","import OHIF from '@ohif/core';\nimport { annotation } from '@cornerstonejs/tools';\nconst { log } = OHIF;\n\nfunction getFilteredCornerstoneToolState(\n  measurementData,\n  additionalFindingTypes\n) {\n  const filteredToolState = {};\n\n  function addToFilteredToolState(annotation, toolType) {\n    if (!annotation.metadata?.referencedImageId) {\n      log.warn(\n        `[DICOMSR] No referencedImageId found for ${toolType} ${annotation.id}`\n      );\n      return;\n    }\n\n    const imageId = annotation.metadata.referencedImageId;\n\n    if (!filteredToolState[imageId]) {\n      filteredToolState[imageId] = {};\n    }\n\n    const imageIdSpecificToolState = filteredToolState[imageId];\n\n    if (!imageIdSpecificToolState[toolType]) {\n      imageIdSpecificToolState[toolType] = {\n        data: [],\n      };\n    }\n\n    const measurementDataI = measurementData.find(\n      md => md.uid === annotation.annotationUID\n    );\n    const toolData = imageIdSpecificToolState[toolType].data;\n\n    let { finding } = measurementDataI;\n    const findingSites = [];\n\n    // NOTE -> We use the CORNERSTONEJS coding schemeDesignator which we have\n    // defined in the @cornerstonejs/adapters\n    if (measurementDataI.label) {\n      if (additionalFindingTypes.includes(toolType)) {\n        finding = {\n          CodeValue: 'CORNERSTONEFREETEXT',\n          CodingSchemeDesignator: 'CORNERSTONEJS',\n          CodeMeaning: measurementDataI.label,\n        };\n      } else {\n        findingSites.push({\n          CodeValue: 'CORNERSTONEFREETEXT',\n          CodingSchemeDesignator: 'CORNERSTONEJS',\n          CodeMeaning: measurementDataI.label,\n        });\n      }\n    }\n\n    if (measurementDataI.findingSites) {\n      findingSites.push(...measurementDataI.findingSites);\n    }\n\n    const measurement = Object.assign({}, annotation, {\n      finding,\n      findingSites,\n    });\n\n    toolData.push(measurement);\n  }\n\n  const uidFilter = measurementData.map(md => md.uid);\n  const uids = uidFilter.slice();\n\n  const annotationManager = annotation.state.getAnnotationManager();\n  const framesOfReference = annotationManager.getFramesOfReference();\n\n  for (let i = 0; i < framesOfReference.length; i++) {\n    const frameOfReference = framesOfReference[i];\n\n    const frameOfReferenceAnnotations = annotationManager.getAnnotations(\n      frameOfReference\n    );\n\n    const toolTypes = Object.keys(frameOfReferenceAnnotations);\n\n    for (let j = 0; j < toolTypes.length; j++) {\n      const toolType = toolTypes[j];\n\n      const annotations = frameOfReferenceAnnotations[toolType];\n\n      if (annotations) {\n        for (let k = 0; k < annotations.length; k++) {\n          const annotation = annotations[k];\n          const uidIndex = uids.findIndex(\n            uid => uid === annotation.annotationUID\n          );\n\n          if (uidIndex !== -1) {\n            addToFilteredToolState(annotation, toolType);\n            uids.splice(uidIndex, 1);\n\n            if (!uids.length) {\n              return filteredToolState;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return filteredToolState;\n}\n\nexport default getFilteredCornerstoneToolState;\n","import { metaData, utilities } from '@cornerstonejs/core';\n\nimport OHIF, { DicomMetadataStore } from '@ohif/core';\nimport dcmjs from 'dcmjs';\nimport { adaptersSR } from '@cornerstonejs/adapters';\n\nimport getFilteredCornerstoneToolState from './utils/getFilteredCornerstoneToolState';\n\nconst { MeasurementReport } = adaptersSR.Cornerstone3D;\nconst { log } = OHIF;\n\n/**\n *\n * @param measurementData An array of measurements from the measurements service\n * that you wish to serialize.\n * @param additionalFindingTypes toolTypes that should be stored with labels as Findings\n * @param options Naturalized DICOM JSON headers to merge into the displaySet.\n *\n */\nconst _generateReport = (\n  measurementData,\n  additionalFindingTypes,\n  options = {}\n) => {\n  const filteredToolState = getFilteredCornerstoneToolState(\n    measurementData,\n    additionalFindingTypes\n  );\n\n  const report = MeasurementReport.generateReport(\n    filteredToolState,\n    metaData,\n    utilities.worldToImageCoords,\n    options\n  );\n\n  const { dataset } = report;\n\n  // Set the default character set as UTF-8\n  // https://dicom.innolitics.com/ciods/nm-image/sop-common/00080005\n  if (typeof dataset.SpecificCharacterSet === 'undefined') {\n    dataset.SpecificCharacterSet = 'ISO_IR 192';\n  }\n  return dataset;\n};\n\nconst commandsModule = ({}) => {\n  const actions = {\n    /**\n     *\n     * @param measurementData An array of measurements from the measurements service\n     * @param additionalFindingTypes toolTypes that should be stored with labels as Findings\n     * @param options Naturalized DICOM JSON headers to merge into the displaySet.\n     * as opposed to Finding Sites.\n     * that you wish to serialize.\n     */\n    downloadReport: ({\n      measurementData,\n      additionalFindingTypes,\n      options = {},\n    }) => {\n      const srDataset = actions.generateReport(\n        measurementData,\n        additionalFindingTypes,\n        options\n      );\n      const reportBlob = dcmjs.data.datasetToBlob(srDataset);\n\n      //Create a URL for the binary.\n      var objectUrl = URL.createObjectURL(reportBlob);\n      window.location.assign(objectUrl);\n    },\n\n    /**\n     *\n     * @param measurementData An array of measurements from the measurements service\n     * that you wish to serialize.\n     * @param dataSource The dataSource that you wish to use to persist the data.\n     * @param additionalFindingTypes toolTypes that should be stored with labels as Findings\n     * @param options Naturalized DICOM JSON headers to merge into the displaySet.\n     * @return The naturalized report\n     */\n    storeMeasurements: async ({\n      measurementData,\n      dataSource,\n      additionalFindingTypes,\n      options = {},\n    }) => {\n      // Use the @cornerstonejs adapter for converting to/from DICOM\n      // But it is good enough for now whilst we only have cornerstone as a datasource.\n      log.info('[DICOMSR] storeMeasurements');\n\n      if (!dataSource || !dataSource.store || !dataSource.store.dicom) {\n        log.error(\n          '[DICOMSR] datasource has no dataSource.store.dicom endpoint!'\n        );\n        return Promise.reject({});\n      }\n\n      try {\n        const naturalizedReport = _generateReport(\n          measurementData,\n          additionalFindingTypes,\n          options\n        );\n\n        const { StudyInstanceUID, ContentSequence } = naturalizedReport;\n        // The content sequence has 5 or more elements, of which\n        // the `[4]` element contains the annotation data, so this is\n        // checking that there is some annotation data present.\n        if (!ContentSequence?.[4].ContentSequence?.length) {\n          console.log(\n            'naturalizedReport missing imaging content',\n            naturalizedReport\n          );\n          throw new Error('Invalid report, no content');\n        }\n\n        await dataSource.store.dicom(naturalizedReport);\n\n        if (StudyInstanceUID) {\n          dataSource.deleteStudyMetadataPromise(StudyInstanceUID);\n        }\n\n        // The \"Mode\" route listens for DicomMetadataStore changes\n        // When a new instance is added, it listens and\n        // automatically calls makeDisplaySets\n        DicomMetadataStore.addInstances([naturalizedReport], true);\n\n        return naturalizedReport;\n      } catch (error) {\n        console.warn(error);\n        log.error(\n          `[DICOMSR] Error while saving the measurements: ${error.message}`\n        );\n        throw new Error(\n          error.message || 'Error while saving the measurements.'\n        );\n      }\n    },\n  };\n\n  const definitions = {\n    downloadReport: {\n      commandFn: actions.downloadReport,\n      storeContexts: [],\n      options: {},\n    },\n    storeMeasurements: {\n      commandFn: actions.storeMeasurements,\n      storeContexts: [],\n      options: {},\n    },\n  };\n\n  return {\n    actions,\n    definitions,\n    defaultContext: 'CORNERSTONE_STRUCTURED_REPORT',\n  };\n};\n\nexport default commandsModule;\n","import { addTool } from '@cornerstonejs/tools';\n\nexport default function addToolInstance(\n  name: string,\n  toolClass,\n  configuration?\n): void {\n  class InstanceClass extends toolClass {\n    static toolName = name;\n  }\n  addTool(InstanceClass);\n}\n","import { DisplaySetService, classes } from '@ohif/core';\n\nconst ImageSet = classes.ImageSet;\n\nconst findInstance = (measurement, displaySetService: DisplaySetService) => {\n  const { displaySetInstanceUID, ReferencedSOPInstanceUID: sopUid } =\n    measurement;\n  const referencedDisplaySet = displaySetService.getDisplaySetByUID(\n    displaySetInstanceUID\n  );\n  if (!referencedDisplaySet.images) return;\n  return referencedDisplaySet.images.find(it => it.SOPInstanceUID === sopUid);\n};\n\n/** Finds references to display sets inside the measurements\n * contained within the provided display set.\n * @return an array of instances referenced.\n */\nconst findReferencedInstances = (\n  displaySetService: DisplaySetService,\n  displaySet\n) => {\n  const instances = [];\n  const instanceById = {};\n  for (const measurement of displaySet.measurements) {\n    const { imageId } = measurement;\n    if (!imageId) continue;\n    if (instanceById[imageId]) continue;\n\n    const instance = findInstance(measurement, displaySetService);\n    if (!instance) {\n      console.log('Measurement', measurement, 'had no instances found');\n      continue;\n    }\n\n    instanceById[imageId] = instance;\n    instances.push(instance);\n  }\n  return instances;\n};\n\n/**\n * Creates a new display set containing a single image instance for each\n * referenced image.\n *\n * @param displaySetService\n * @param displaySet - containing measurements referencing images.\n * @returns A new (registered/active) display set containing the referenced images\n */\nconst createReferencedImageDisplaySet = (displaySetService, displaySet) => {\n  const instances = findReferencedInstances(displaySetService, displaySet);\n  // This will be a  member function of the created image set\n  const updateInstances = function() {\n    this.images.splice(\n      0,\n      this.images.length,\n      ...findReferencedInstances(displaySetService, displaySet)\n    );\n    this.numImageFrames = this.images.length;\n  };\n\n  const imageSet = new ImageSet(instances);\n  const instance = instances[0];\n  imageSet.setAttributes({\n    displaySetInstanceUID: imageSet.uid, // create a local alias for the imageSet UID\n    SeriesDate: instance.SeriesDate,\n    SeriesTime: instance.SeriesTime,\n    SeriesInstanceUID: imageSet.uid,\n    StudyInstanceUID: instance.StudyInstanceUID,\n    SeriesNumber: instance.SeriesNumber || 0,\n    SOPClassUID: instance.SOPClassUID,\n    SeriesDescription: `${displaySet.SeriesDescription} KO ${displaySet.instance.SeriesNumber}`,\n    Modality: 'KO',\n    isMultiFrame: false,\n    numImageFrames: instances.length,\n    SOPClassHandlerId: `@ohif/extension-default.sopClassHandlerModule.stack`,\n    isReconstructable: false,\n    // This object is made of multiple instances from other series\n    isCompositeStack: true,\n    madeInClient: true,\n    excludeFromThumbnailBrowser: true,\n    updateInstances,\n  });\n\n  displaySetService.addDisplaySets(imageSet);\n\n  return imageSet;\n};\n\nexport default createReferencedImageDisplaySet;\n","import React from 'react';\nimport getSopClassHandlerModule from './getSopClassHandlerModule';\nimport getHangingProtocolModule, {\n  srProtocol,\n} from './getHangingProtocolModule';\nimport onModeEnter from './onModeEnter';\nimport getCommandsModule from './commandsModule';\nimport preRegistration from './init';\nimport { id } from './id.js';\nimport toolNames from './tools/toolNames';\nimport hydrateStructuredReport from './utils/hydrateStructuredReport';\nimport createReferencedImageDisplaySet from './utils/createReferencedImageDisplaySet';\n\nconst Component = React.lazy(() => {\n  return import(\n    /* webpackPrefetch: true */ './viewports/OHIFCornerstoneSRViewport'\n  );\n});\n\nconst OHIFCornerstoneSRViewport = props => {\n  return (\n    <React.Suspense fallback={<div>Loading...</div>}>\n      <Component {...props} />\n    </React.Suspense>\n  );\n};\n\n/**\n *\n */\nconst dicomSRExtension = {\n  /**\n   * Only required property. Should be a unique value across all extensions.\n   */\n  id,\n  onModeEnter,\n\n  preRegistration,\n\n  /**\n   *\n   *\n   * @param {object} [configuration={}]\n   * @param {object|array} [configuration.csToolsConfig] - Passed directly to `initCornerstoneTools`\n   */\n  getViewportModule({ servicesManager, extensionManager }) {\n    const ExtendedOHIFCornerstoneSRViewport = props => {\n      return (\n        <OHIFCornerstoneSRViewport\n          servicesManager={servicesManager}\n          extensionManager={extensionManager}\n          {...props}\n        />\n      );\n    };\n\n    return [{ name: 'dicom-sr', component: ExtendedOHIFCornerstoneSRViewport }];\n  },\n  getCommandsModule,\n  getSopClassHandlerModule,\n  // Include dynmically computed values such as toolNames not known till instantiation\n  getUtilityModule({ servicesManager }) {\n    return [\n      {\n        name: 'tools',\n        exports: {\n          toolNames,\n        },\n      },\n    ];\n  },\n};\n\nexport default dicomSRExtension;\n\n// Put static exports here so they can be type checked\nexport { hydrateStructuredReport, createReferencedImageDisplaySet, srProtocol };\n","import { SOPClassHandlerId } from './id';\n\nexport default function onModeEnter({ servicesManager }) {\n  const { displaySetService } = servicesManager.services;\n  const displaySetCache = displaySetService.getDisplaySetCache();\n\n  const srDisplaySets = [...displaySetCache.values()].filter(\n    ds => ds.SOPClassHandlerId === SOPClassHandlerId\n  );\n\n  srDisplaySets.forEach(ds => {\n    // New mode route, allow SRs to be hydrated again\n    ds.isHydrated = false;\n  });\n}\n","import {\n  addTool,\n  AngleTool,\n  annotation,\n  ArrowAnnotateTool,\n  BidirectionalTool,\n  CobbAngleTool,\n  EllipticalROITool,\n  CircleROITool,\n  LengthTool,\n  PlanarFreehandROITool,\n} from '@cornerstonejs/tools';\nimport DICOMSRDisplayTool from './tools/DICOMSRDisplayTool';\nimport addToolInstance from './utils/addToolInstance';\nimport { Types } from '@ohif/core';\nimport toolNames from './tools/toolNames';\n\n/**\n * @param {object} configuration\n */\nexport default function init({\n  configuration = {},\n}: Types.Extensions.ExtensionParams): void {\n  addTool(DICOMSRDisplayTool);\n  addToolInstance(toolNames.SRLength, LengthTool, {});\n  addToolInstance(toolNames.SRBidirectional, BidirectionalTool);\n  addToolInstance(toolNames.SREllipticalROI, EllipticalROITool);\n  addToolInstance(toolNames.SRCircleROI, CircleROITool);\n  addToolInstance(toolNames.SRArrowAnnotate, ArrowAnnotateTool);\n  addToolInstance(toolNames.SRAngle, AngleTool);\n  // TODO - fix the SR display of Cobb Angle, as it joins the two lines\n  addToolInstance(toolNames.SRCobbAngle, CobbAngleTool);\n  // TODO - fix the rehydration of Freehand, as it throws an exception\n  // on a missing polyline. The fix is probably in CS3D\n  addToolInstance(toolNames.SRPlanarFreehandROI, PlanarFreehandROITool);\n\n  // Modify annotation tools to use dashed lines on SR\n  const dashedLine = {\n    lineDash: '4,4',\n  };\n  annotation.config.style.setToolGroupToolStyles('SRToolGroup', {\n    SRLength: dashedLine,\n    SRBidirectional: dashedLine,\n    SREllipticalROI: dashedLine,\n    SRCircleROI: dashedLine,\n    SRArrowAnnotate: dashedLine,\n    SRCobbAngle: dashedLine,\n    SRAngle: dashedLine,\n    SRPlanarFreehandROI: dashedLine,\n    global: {},\n  });\n}\n","import { getEnabledElement } from '@cornerstonejs/core';\n\nconst state = {\n  TrackingUniqueIdentifier: null,\n  trackingIdentifiersByViewportId: {},\n};\n\n/**\n * This file is being used to store the per-viewport state of the SR tools,\n * Since, all the toolStates are added to the cornerstoneTools, when displaying the SRTools,\n * if there are two viewports rendering the same imageId, we don't want to show\n * the same SR annotation twice on irrelevant viewport, hence, we are storing the state\n * of the SR tools in state here, so that we can filter them later.\n */\n\nfunction setTrackingUniqueIdentifiersForElement(\n  element,\n  trackingUniqueIdentifiers,\n  activeIndex = 0\n) {\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  state.trackingIdentifiersByViewportId[viewport.id] = {\n    trackingUniqueIdentifiers,\n    activeIndex,\n  };\n}\n\nfunction setActiveTrackingUniqueIdentifierForElement(\n  element,\n  TrackingUniqueIdentifier\n) {\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  const trackingIdentifiersForElement =\n    state.trackingIdentifiersByViewportId[viewport.id];\n\n  if (trackingIdentifiersForElement) {\n    const activeIndex = trackingIdentifiersForElement.trackingUniqueIdentifiers.findIndex(\n      tuid => tuid === TrackingUniqueIdentifier\n    );\n\n    trackingIdentifiersForElement.activeIndex = activeIndex;\n  }\n}\n\nfunction getTrackingUniqueIdentifiersForElement(element) {\n  const enabledElement = getEnabledElement(element);\n  const { viewport } = enabledElement;\n\n  if (state.trackingIdentifiersByViewportId[viewport.id]) {\n    return state.trackingIdentifiersByViewportId[viewport.id];\n  }\n\n  return { trackingUniqueIdentifiers: [] };\n}\n\nexport {\n  setTrackingUniqueIdentifiersForElement,\n  setActiveTrackingUniqueIdentifierForElement,\n  getTrackingUniqueIdentifiersForElement,\n};\n","import { utilities, metaData } from '@cornerstonejs/core';\nimport OHIF, { DicomMetadataStore } from '@ohif/core';\nimport getLabelFromDCMJSImportedToolData from './getLabelFromDCMJSImportedToolData';\nimport { adaptersSR } from '@cornerstonejs/adapters';\n\nconst { guid } = OHIF.utils;\nconst { MeasurementReport, CORNERSTONE_3D_TAG } = adaptersSR.Cornerstone3D;\n\nconst CORNERSTONE_3D_TOOLS_SOURCE_NAME = 'Cornerstone3DTools';\nconst CORNERSTONE_3D_TOOLS_SOURCE_VERSION = '0.1';\n\nconst supportedLegacyCornerstoneTags = ['cornerstoneTools@^4.0.0'];\n\nconst convertCode = (codingValues, code) => {\n  if (!code || code.CodingSchemeDesignator === 'CORNERSTONEJS') return;\n  const ref = `${code.CodingSchemeDesignator}:${code.CodeValue}`;\n  const ret = { ...codingValues[ref], ref, ...code, text: code.CodeMeaning };\n  return ret;\n};\n\nconst convertSites = (codingValues, sites) => {\n  if (!sites || !sites.length) return;\n  const ret = [];\n  // Do as a loop to convert away from Proxy instances\n  for (let i = 0; i < sites.length; i++) {\n    // Deal with irregular conversion from dcmjs\n    const site = convertCode(codingValues, sites[i][0] || sites[i]);\n    if (site) ret.push(site);\n  }\n  return (ret.length && ret) || undefined;\n};\n\n/**\n * Hydrates a structured report, for default viewports.\n *\n */\nexport default function hydrateStructuredReport(\n  { servicesManager, extensionManager },\n  displaySetInstanceUID\n) {\n  const dataSource = extensionManager.getActiveDataSource()[0];\n  const {\n    measurementService,\n    displaySetService,\n    customizationService,\n  } = servicesManager.services;\n\n  const codingValues = customizationService.getCustomization(\n    'codingValues',\n    {}\n  );\n  const displaySet = displaySetService.getDisplaySetByUID(\n    displaySetInstanceUID\n  );\n\n  // TODO -> We should define a strict versioning somewhere.\n  const mappings = measurementService.getSourceMappings(\n    CORNERSTONE_3D_TOOLS_SOURCE_NAME,\n    CORNERSTONE_3D_TOOLS_SOURCE_VERSION\n  );\n\n  if (!mappings || !mappings.length) {\n    throw new Error(\n      `Attempting to hydrate measurements service when no mappings present. This shouldn't be reached.`\n    );\n  }\n\n  const instance = DicomMetadataStore.getInstance(\n    displaySet.StudyInstanceUID,\n    displaySet.SeriesInstanceUID,\n    displaySet.SOPInstanceUID\n  );\n\n  const sopInstanceUIDToImageId = {};\n  const imageIdsForToolState = {};\n\n  displaySet.measurements.forEach(measurement => {\n    const { ReferencedSOPInstanceUID, imageId, frameNumber } = measurement;\n\n    if (!sopInstanceUIDToImageId[ReferencedSOPInstanceUID]) {\n      sopInstanceUIDToImageId[ReferencedSOPInstanceUID] = imageId;\n      imageIdsForToolState[ReferencedSOPInstanceUID] = [];\n    }\n    if (!imageIdsForToolState[ReferencedSOPInstanceUID][frameNumber]) {\n      imageIdsForToolState[ReferencedSOPInstanceUID][frameNumber] = imageId;\n    }\n  });\n\n  const datasetToUse = _mapLegacyDataSet(instance);\n\n  // Use dcmjs to generate toolState.\n  const storedMeasurementByAnnotationType = MeasurementReport.generateToolState(\n    datasetToUse,\n    // NOTE: we need to pass in the imageIds to dcmjs since the we use them\n    // for the imageToWorld transformation. The following assumes that the order\n    // that measurements were added to the display set are the same order as\n    // the measurementGroups in the instance.\n    sopInstanceUIDToImageId,\n    utilities.imageToWorldCoords,\n    metaData\n  );\n\n  // Filter what is found by DICOM SR to measurements we support.\n  const mappingDefinitions = mappings.map(m => m.annotationType);\n  const hydratableMeasurementsInSR = {};\n\n  Object.keys(storedMeasurementByAnnotationType).forEach(key => {\n    if (mappingDefinitions.includes(key)) {\n      hydratableMeasurementsInSR[key] = storedMeasurementByAnnotationType[key];\n    }\n  });\n\n  // Set the series touched as tracked.\n  const imageIds = [];\n\n  // TODO: notification if no hydratable?\n  Object.keys(hydratableMeasurementsInSR).forEach(annotationType => {\n    const toolDataForAnnotationType =\n      hydratableMeasurementsInSR[annotationType];\n\n    toolDataForAnnotationType.forEach(toolData => {\n      // Add the measurement to toolState\n      // dcmjs and Cornerstone3D has structural defect in supporting multi-frame\n      // files, and looking up the imageId from sopInstanceUIDToImageId results\n      // in the wrong value.\n      const frameNumber =\n        (toolData.annotation.data && toolData.annotation.data.frameNumber) || 1;\n      const imageId =\n        imageIdsForToolState[toolData.sopInstanceUid][frameNumber] ||\n        sopInstanceUIDToImageId[toolData.sopInstanceUid];\n\n      if (!imageIds.includes(imageId)) {\n        imageIds.push(imageId);\n      }\n    });\n  });\n\n  let targetStudyInstanceUID;\n  const SeriesInstanceUIDs = [];\n\n  for (let i = 0; i < imageIds.length; i++) {\n    const imageId = imageIds[i];\n    const { SeriesInstanceUID, StudyInstanceUID } = metaData.get(\n      'instance',\n      imageId\n    );\n\n    if (!SeriesInstanceUIDs.includes(SeriesInstanceUID)) {\n      SeriesInstanceUIDs.push(SeriesInstanceUID);\n    }\n\n    if (!targetStudyInstanceUID) {\n      targetStudyInstanceUID = StudyInstanceUID;\n    } else if (targetStudyInstanceUID !== StudyInstanceUID) {\n      console.warn(\n        'NO SUPPORT FOR SRs THAT HAVE MEASUREMENTS FROM MULTIPLE STUDIES.'\n      );\n    }\n  }\n\n  Object.keys(hydratableMeasurementsInSR).forEach(annotationType => {\n    const toolDataForAnnotationType =\n      hydratableMeasurementsInSR[annotationType];\n\n    toolDataForAnnotationType.forEach(toolData => {\n      // Add the measurement to toolState\n      // dcmjs and Cornerstone3D has structural defect in supporting multi-frame\n      // files, and looking up the imageId from sopInstanceUIDToImageId results\n      // in the wrong value.\n      const frameNumber =\n        (toolData.annotation.data && toolData.annotation.data.frameNumber) || 1;\n      const imageId =\n        imageIdsForToolState[toolData.sopInstanceUid][frameNumber] ||\n        sopInstanceUIDToImageId[toolData.sopInstanceUid];\n\n      toolData.uid = guid();\n\n      const instance = metaData.get('instance', imageId);\n      const {\n        FrameOfReferenceUID,\n        // SOPInstanceUID,\n        // SeriesInstanceUID,\n        // StudyInstanceUID,\n      } = instance;\n\n      const annotation = {\n        annotationUID: toolData.annotation.annotationUID,\n        data: toolData.annotation.data,\n        metadata: {\n          toolName: annotationType,\n          referencedImageId: imageId,\n          FrameOfReferenceUID,\n        },\n      };\n\n      const source = measurementService.getSource(\n        CORNERSTONE_3D_TOOLS_SOURCE_NAME,\n        CORNERSTONE_3D_TOOLS_SOURCE_VERSION\n      );\n      annotation.data.label = getLabelFromDCMJSImportedToolData(toolData);\n      annotation.data.finding = convertCode(\n        codingValues,\n        toolData.finding?.[0]\n      );\n      annotation.data.findingSites = convertSites(\n        codingValues,\n        toolData.findingSites\n      );\n      annotation.data.site = annotation.data.findingSites?.[0];\n\n      const matchingMapping = mappings.find(\n        m => m.annotationType === annotationType\n      );\n\n      measurementService.addRawMeasurement(\n        source,\n        annotationType,\n        { annotation },\n        matchingMapping.toMeasurementSchema,\n        dataSource\n      );\n\n      if (!imageIds.includes(imageId)) {\n        imageIds.push(imageId);\n      }\n    });\n  });\n\n  displaySet.isHydrated = true;\n\n  return {\n    StudyInstanceUID: targetStudyInstanceUID,\n    SeriesInstanceUIDs,\n  };\n}\n\nfunction _mapLegacyDataSet(dataset) {\n  const REPORT = 'Imaging Measurements';\n  const GROUP = 'Measurement Group';\n  const TRACKING_IDENTIFIER = 'Tracking Identifier';\n\n  // Identify the Imaging Measurements\n  const imagingMeasurementContent = toArray(dataset.ContentSequence).find(\n    codeMeaningEquals(REPORT)\n  );\n\n  // Retrieve the Measurements themselves\n  const measurementGroups = toArray(\n    imagingMeasurementContent.ContentSequence\n  ).filter(codeMeaningEquals(GROUP));\n\n  // For each of the supported measurement types, compute the measurement data\n  const measurementData = {};\n\n  const cornerstoneToolClasses =\n    MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE;\n\n  const registeredToolClasses = [];\n\n  Object.keys(cornerstoneToolClasses).forEach(key => {\n    registeredToolClasses.push(cornerstoneToolClasses[key]);\n    measurementData[key] = [];\n  });\n\n  measurementGroups.forEach((measurementGroup, index) => {\n    const measurementGroupContentSequence = toArray(\n      measurementGroup.ContentSequence\n    );\n\n    const TrackingIdentifierGroup = measurementGroupContentSequence.find(\n      contentItem =>\n        contentItem.ConceptNameCodeSequence.CodeMeaning === TRACKING_IDENTIFIER\n    );\n\n    const TrackingIdentifier = TrackingIdentifierGroup.TextValue;\n\n    let [cornerstoneTag, toolName] = TrackingIdentifier.split(':');\n    if (supportedLegacyCornerstoneTags.includes(cornerstoneTag)) {\n      cornerstoneTag = CORNERSTONE_3D_TAG;\n    }\n\n    const mappedTrackingIdentifier = `${cornerstoneTag}:${toolName}`;\n\n    TrackingIdentifierGroup.TextValue = mappedTrackingIdentifier;\n  });\n\n  return dataset;\n}\n\nconst toArray = function (x) {\n  return Array.isArray(x) ? x : [x];\n};\n\nconst codeMeaningEquals = codeMeaningName => {\n  return contentItem => {\n    return contentItem.ConceptNameCodeSequence.CodeMeaning === codeMeaningName;\n  };\n};\n","/**\n * Extracts the label from the toolData imported from dcmjs. We need to do this\n * as dcmjs does not depeend on OHIF/the measurementService, it just produces data for cornestoneTools.\n * This optional data is available for the consumer to process if they wish to.\n * @param {object} toolData The tooldata relating to the\n *\n * @returns {string} The extracted label.\n */\nexport default function getLabelFromDCMJSImportedToolData(toolData) {\n  const { findingSites = [], finding } = toolData;\n\n  let freeTextLabel = findingSites.find(\n    fs => fs.CodeValue === 'CORNERSTONEFREETEXT'\n  );\n\n  if (freeTextLabel) {\n    return freeTextLabel.CodeMeaning;\n  }\n\n  if (finding && finding.CodeValue === 'CORNERSTONEFREETEXT') {\n    return finding.CodeMeaning;\n  }\n}\n","const toArray = x => (Array.isArray(x) ? x : [x]);\n\nexport { toArray };\n","/**\n * Returns a function that checks if a given content item's ConceptNameCodeSequence.CodeMeaning\n * matches the provided codeMeaningName.\n * @param codeMeaningName - The CodeMeaning to match against.\n * @returns A function that takes a content item and returns a boolean indicating whether the\n * content item's CodeMeaning matches the provided codeMeaningName.\n */\nconst codeMeaningEquals = (codeMeaningName: string) => {\n    return (contentItem: any) => {\n        return (\n            contentItem.ConceptNameCodeSequence.CodeMeaning === codeMeaningName\n        );\n    };\n};\n\nexport { codeMeaningEquals };\n","import { normalizers, data, utilities, derivations } from \"dcmjs\";\n\nimport { toArray, codeMeaningEquals } from \"../helpers\";\n\nconst { TID1500, addAccessors } = utilities;\n\nconst { StructuredReport } = derivations;\n\nconst { Normalizer } = normalizers;\n\nconst { TID1500MeasurementReport, TID1501MeasurementGroup } = TID1500;\n\nconst { DicomMetaDictionary } = data;\n\nconst FINDING = { CodingSchemeDesignator: \"DCM\", CodeValue: \"121071\" };\nconst FINDING_SITE = { CodingSchemeDesignator: \"SCT\", CodeValue: \"363698007\" };\nconst FINDING_SITE_OLD = { CodingSchemeDesignator: \"SRT\", CodeValue: \"G-C0E3\" };\n\nconst codeValueMatch = (group, code, oldCode) => {\n    const { ConceptNameCodeSequence } = group;\n    if (!ConceptNameCodeSequence) return;\n    const { CodingSchemeDesignator, CodeValue } = ConceptNameCodeSequence;\n    return (\n        (CodingSchemeDesignator == code.CodingSchemeDesignator &&\n            CodeValue == code.CodeValue) ||\n        (oldCode &&\n            CodingSchemeDesignator == oldCode.CodingSchemeDesignator &&\n            CodeValue == oldCode.CodeValue)\n    );\n};\n\nfunction getTID300ContentItem(\n    tool,\n    toolType,\n    ReferencedSOPSequence,\n    toolClass\n) {\n    const args = toolClass.getTID300RepresentationArguments(tool);\n    args.ReferencedSOPSequence = ReferencedSOPSequence;\n\n    const TID300Measurement = new toolClass.TID300Representation(args);\n\n    return TID300Measurement;\n}\n\nfunction getMeasurementGroup(toolType, toolData, ReferencedSOPSequence) {\n    const toolTypeData = toolData[toolType];\n    const toolClass =\n        MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE[toolType];\n    if (\n        !toolTypeData ||\n        !toolTypeData.data ||\n        !toolTypeData.data.length ||\n        !toolClass\n    ) {\n        return;\n    }\n\n    // Loop through the array of tool instances\n    // for this tool\n    const Measurements = toolTypeData.data.map(tool => {\n        return getTID300ContentItem(\n            tool,\n            toolType,\n            ReferencedSOPSequence,\n            toolClass\n        );\n    });\n\n    return new TID1501MeasurementGroup(Measurements);\n}\n\nexport default class MeasurementReport {\n    static getSetupMeasurementData(MeasurementGroup) {\n        const { ContentSequence } = MeasurementGroup;\n\n        const contentSequenceArr = toArray(ContentSequence);\n        const findingGroup = contentSequenceArr.find(group =>\n            codeValueMatch(group, FINDING)\n        );\n        const findingSiteGroups =\n            contentSequenceArr.filter(group =>\n                codeValueMatch(group, FINDING_SITE, FINDING_SITE_OLD)\n            ) || [];\n        const NUMGroup = contentSequenceArr.find(\n            group => group.ValueType === \"NUM\"\n        );\n        const SCOORDGroup = toArray(NUMGroup.ContentSequence).find(\n            group => group.ValueType === \"SCOORD\"\n        );\n        const { ReferencedSOPSequence } = SCOORDGroup.ContentSequence;\n        const { ReferencedSOPInstanceUID, ReferencedFrameNumber } =\n            ReferencedSOPSequence;\n\n        const defaultState = {\n            sopInstanceUid: ReferencedSOPInstanceUID,\n            frameIndex: ReferencedFrameNumber || 1,\n            complete: true,\n            finding: findingGroup\n                ? addAccessors(findingGroup.ConceptCodeSequence)\n                : undefined,\n            findingSites: findingSiteGroups.map(fsg => {\n                return addAccessors(fsg.ConceptCodeSequence);\n            })\n        };\n        if (defaultState.finding) {\n            defaultState.description = defaultState.finding.CodeMeaning;\n        }\n        const findingSite =\n            defaultState.findingSites && defaultState.findingSites[0];\n        if (findingSite) {\n            defaultState.location =\n                (findingSite[0] && findingSite[0].CodeMeaning) ||\n                findingSite.CodeMeaning;\n        }\n        return {\n            defaultState,\n            findingGroup,\n            findingSiteGroups,\n            NUMGroup,\n            SCOORDGroup,\n            ReferencedSOPSequence,\n            ReferencedSOPInstanceUID,\n            ReferencedFrameNumber\n        };\n    }\n\n    static generateReport(toolState, metadataProvider, options) {\n        // ToolState for array of imageIDs to a Report\n        // Assume Cornerstone metadata provider has access to Study / Series / Sop Instance UID\n\n        let allMeasurementGroups = [];\n        const firstImageId = Object.keys(toolState)[0];\n        if (!firstImageId) {\n            throw new Error(\"No measurements provided.\");\n        }\n\n        /* Patient ID\n        Warning - Missing attribute or value that would be needed to build DICOMDIR - Patient ID\n        Warning - Missing attribute or value that would be needed to build DICOMDIR - Study Date\n        Warning - Missing attribute or value that would be needed to build DICOMDIR - Study Time\n        Warning - Missing attribute or value that would be needed to build DICOMDIR - Study ID\n         */\n        const generalSeriesModule = metadataProvider.get(\n            \"generalSeriesModule\",\n            firstImageId\n        );\n\n        //const sopCommonModule = metadataProvider.get('sopCommonModule', firstImageId);\n\n        // NOTE: We are getting the Series and Study UIDs from the first imageId of the toolState\n        // which means that if the toolState is for multiple series, the report will have the incorrect\n        // SeriesInstanceUIDs\n        const { studyInstanceUID, seriesInstanceUID } = generalSeriesModule;\n\n        // Loop through each image in the toolData\n        Object.keys(toolState).forEach(imageId => {\n            const sopCommonModule = metadataProvider.get(\n                \"sopCommonModule\",\n                imageId\n            );\n            const frameNumber = metadataProvider.get(\"frameNumber\", imageId);\n            const toolData = toolState[imageId];\n            const toolTypes = Object.keys(toolData);\n\n            const ReferencedSOPSequence = {\n                ReferencedSOPClassUID: sopCommonModule.sopClassUID,\n                ReferencedSOPInstanceUID: sopCommonModule.sopInstanceUID\n            };\n\n            if (\n                Normalizer.isMultiframeSOPClassUID(sopCommonModule.sopClassUID)\n            ) {\n                ReferencedSOPSequence.ReferencedFrameNumber = frameNumber;\n            }\n\n            // Loop through each tool type for the image\n            const measurementGroups = [];\n\n            toolTypes.forEach(toolType => {\n                const group = getMeasurementGroup(\n                    toolType,\n                    toolData,\n                    ReferencedSOPSequence\n                );\n                if (group) {\n                    measurementGroups.push(group);\n                }\n            });\n\n            allMeasurementGroups =\n                allMeasurementGroups.concat(measurementGroups);\n        });\n\n        const MeasurementReport = new TID1500MeasurementReport(\n            { TID1501MeasurementGroups: allMeasurementGroups },\n            options\n        );\n\n        // TODO: what is the correct metaheader\n        // http://dicom.nema.org/medical/Dicom/current/output/chtml/part10/chapter_7.html\n        // TODO: move meta creation to happen in derivations.js\n        const fileMetaInformationVersionArray = new Uint8Array(2);\n        fileMetaInformationVersionArray[1] = 1;\n\n        const derivationSourceDataset = {\n            StudyInstanceUID: studyInstanceUID,\n            SeriesInstanceUID: seriesInstanceUID\n            //SOPInstanceUID: sopInstanceUID, // TODO: Necessary?\n            //SOPClassUID: sopClassUID,\n        };\n\n        const _meta = {\n            FileMetaInformationVersion: {\n                Value: [fileMetaInformationVersionArray.buffer],\n                vr: \"OB\"\n            },\n            //MediaStorageSOPClassUID\n            //MediaStorageSOPInstanceUID: sopCommonModule.sopInstanceUID,\n            TransferSyntaxUID: {\n                Value: [\"1.2.840.10008.1.2.1\"],\n                vr: \"UI\"\n            },\n            ImplementationClassUID: {\n                Value: [DicomMetaDictionary.uid()], // TODO: could be git hash or other valid id\n                vr: \"UI\"\n            },\n            ImplementationVersionName: {\n                Value: [\"dcmjs\"],\n                vr: \"SH\"\n            }\n        };\n\n        const _vrMap = {\n            PixelData: \"OW\"\n        };\n\n        derivationSourceDataset._meta = _meta;\n        derivationSourceDataset._vrMap = _vrMap;\n\n        const report = new StructuredReport([derivationSourceDataset]);\n\n        const contentItem = MeasurementReport.contentItem(\n            derivationSourceDataset\n        );\n\n        // Merge the derived dataset with the content from the Measurement Report\n        report.dataset = Object.assign(report.dataset, contentItem);\n        report.dataset._meta = _meta;\n\n        return report;\n    }\n\n    /**\n     * Generate Cornerstone tool state from dataset\n     * @param {object} dataset dataset\n     * @param {object} hooks\n     * @param {function} hooks.getToolClass Function to map dataset to a tool class\n     * @returns\n     */\n    static generateToolState(dataset, hooks = {}) {\n        // For now, bail out if the dataset is not a TID1500 SR with length measurements\n        if (dataset.ContentTemplateSequence.TemplateIdentifier !== \"1500\") {\n            throw new Error(\n                \"This package can currently only interpret DICOM SR TID 1500\"\n            );\n        }\n\n        const REPORT = \"Imaging Measurements\";\n        const GROUP = \"Measurement Group\";\n        const TRACKING_IDENTIFIER = \"Tracking Identifier\";\n\n        // Identify the Imaging Measurements\n        const imagingMeasurementContent = toArray(dataset.ContentSequence).find(\n            codeMeaningEquals(REPORT)\n        );\n\n        // Retrieve the Measurements themselves\n        const measurementGroups = toArray(\n            imagingMeasurementContent.ContentSequence\n        ).filter(codeMeaningEquals(GROUP));\n\n        // For each of the supported measurement types, compute the measurement data\n        const measurementData = {};\n\n        const cornerstoneToolClasses =\n            MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE;\n\n        const registeredToolClasses = [];\n\n        Object.keys(cornerstoneToolClasses).forEach(key => {\n            registeredToolClasses.push(cornerstoneToolClasses[key]);\n            measurementData[key] = [];\n        });\n\n        measurementGroups.forEach(measurementGroup => {\n            const measurementGroupContentSequence = toArray(\n                measurementGroup.ContentSequence\n            );\n\n            const TrackingIdentifierGroup =\n                measurementGroupContentSequence.find(\n                    contentItem =>\n                        contentItem.ConceptNameCodeSequence.CodeMeaning ===\n                        TRACKING_IDENTIFIER\n                );\n\n            const TrackingIdentifierValue = TrackingIdentifierGroup.TextValue;\n\n            const toolClass = hooks.getToolClass\n                ? hooks.getToolClass(\n                      measurementGroup,\n                      dataset,\n                      registeredToolClasses\n                  )\n                : registeredToolClasses.find(tc =>\n                      tc.isValidCornerstoneTrackingIdentifier(\n                          TrackingIdentifierValue\n                      )\n                  );\n\n            if (toolClass) {\n                const measurement =\n                    toolClass.getMeasurementData(measurementGroup);\n\n                console.log(`=== ${toolClass.toolType} ===`);\n                console.log(measurement);\n\n                measurementData[toolClass.toolType].push(measurement);\n            }\n        });\n\n        // NOTE: There is no way of knowing the cornerstone imageIds as that could be anything.\n        // That is up to the consumer to derive from the SOPInstanceUIDs.\n        return measurementData;\n    }\n\n    static registerTool(toolClass) {\n        MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE[\n            toolClass.utilityToolType\n        ] = toolClass;\n        MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE[\n            toolClass.toolType\n        ] = toolClass;\n        MeasurementReport.MEASUREMENT_BY_TOOLTYPE[toolClass.toolType] =\n            toolClass.utilityToolType;\n    }\n}\n\nMeasurementReport.MEASUREMENT_BY_TOOLTYPE = {};\nMeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE = {};\nMeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE = {};\n","export default \"cornerstoneTools@^4.0.0\";\n","import { utilities } from \"dcmjs\";\nimport MeasurementReport from \"./MeasurementReport\";\nimport CORNERSTONE_4_TAG from \"./cornerstone4Tag\";\n\nconst { Length: TID300Length } = utilities.TID300;\n\nconst LENGTH = \"Length\";\n\nclass Length {\n    // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n    static getMeasurementData(MeasurementGroup) {\n        const { defaultState, NUMGroup, SCOORDGroup } =\n            MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n\n        const state = {\n            ...defaultState,\n            length: NUMGroup.MeasuredValueSequence.NumericValue,\n            toolType: Length.toolType,\n            handles: {\n                start: {},\n                end: {},\n                textBox: {\n                    hasMoved: false,\n                    movesIndependently: false,\n                    drawnIndependently: true,\n                    allowedOutsideImage: true,\n                    hasBoundingBox: true\n                }\n            }\n        };\n\n        [\n            state.handles.start.x,\n            state.handles.start.y,\n            state.handles.end.x,\n            state.handles.end.y\n        ] = SCOORDGroup.GraphicData;\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool) {\n        const { handles, finding, findingSites } = tool;\n        const point1 = handles.start;\n        const point2 = handles.end;\n        const distance = tool.length;\n\n        const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:Length\";\n\n        return {\n            point1,\n            point2,\n            distance,\n            trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nLength.toolType = LENGTH;\nLength.utilityToolType = LENGTH;\nLength.TID300Representation = TID300Length;\nLength.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n    if (!TrackingIdentifier.includes(\":\")) {\n        return false;\n    }\n\n    const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n\n    if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n        return false;\n    }\n\n    return toolType === LENGTH;\n};\n\nMeasurementReport.registerTool(Length);\n\nexport default Length;\n","import { utilities } from \"dcmjs\";\n\nimport MeasurementReport from \"./MeasurementReport\";\nimport CORNERSTONE_4_TAG from \"./cornerstone4Tag\";\n\nconst { Polyline: TID300Polyline } = utilities.TID300;\n\nclass FreehandRoi {\n    static getMeasurementData(MeasurementGroup) {\n        const { defaultState, SCOORDGroup, NUMGroup } =\n            MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n\n        const state = {\n            ...defaultState,\n            toolType: FreehandRoi.toolType,\n            handles: {\n                points: [],\n                textBox: {\n                    active: false,\n                    hasMoved: false,\n                    movesIndependently: false,\n                    drawnIndependently: true,\n                    allowedOutsideImage: true,\n                    hasBoundingBox: true\n                }\n            },\n            cachedStats: {\n                area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0\n            },\n            color: undefined,\n            invalidated: true\n        };\n        const { GraphicData } = SCOORDGroup;\n        for (let i = 0; i < GraphicData.length; i += 2) {\n            state.handles.points.push({\n                x: GraphicData[i],\n                y: GraphicData[i + 1]\n            });\n        }\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool) {\n        const { handles, finding, findingSites, cachedStats = {} } = tool;\n        const { points } = handles;\n        const { area = 0, perimeter = 0 } = cachedStats;\n\n        const trackingIdentifierTextValue =\n            \"cornerstoneTools@^4.0.0:FreehandRoi\";\n\n        return {\n            points,\n            area,\n            perimeter,\n            trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nFreehandRoi.toolType = \"FreehandRoi\";\nFreehandRoi.utilityToolType = \"FreehandRoi\";\nFreehandRoi.TID300Representation = TID300Polyline;\nFreehandRoi.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n    if (!TrackingIdentifier.includes(\":\")) {\n        return false;\n    }\n\n    const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n\n    if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n        return false;\n    }\n\n    return toolType === FreehandRoi.toolType;\n};\n\nMeasurementReport.registerTool(FreehandRoi);\n\nexport default FreehandRoi;\n","import { utilities } from \"dcmjs\";\nimport MeasurementReport from \"./MeasurementReport\";\nimport CORNERSTONE_4_TAG from \"./cornerstone4Tag\";\nimport { toArray } from \"../helpers\";\n\nconst { Bidirectional: TID300Bidirectional } = utilities.TID300;\n\nconst BIDIRECTIONAL = \"Bidirectional\";\nconst LONG_AXIS = \"Long Axis\";\nconst SHORT_AXIS = \"Short Axis\";\nconst FINDING = \"121071\";\nconst FINDING_SITE = \"G-C0E3\";\n\nclass Bidirectional {\n    // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n    static getMeasurementData(MeasurementGroup) {\n        const { ContentSequence } = MeasurementGroup;\n\n        const findingGroup = toArray(ContentSequence).find(\n            group => group.ConceptNameCodeSequence.CodeValue === FINDING\n        );\n\n        const findingSiteGroups = toArray(ContentSequence).filter(\n            group => group.ConceptNameCodeSequence.CodeValue === FINDING_SITE\n        );\n\n        const longAxisNUMGroup = toArray(ContentSequence).find(\n            group => group.ConceptNameCodeSequence.CodeMeaning === LONG_AXIS\n        );\n\n        const longAxisSCOORDGroup = toArray(\n            longAxisNUMGroup.ContentSequence\n        ).find(group => group.ValueType === \"SCOORD\");\n\n        const shortAxisNUMGroup = toArray(ContentSequence).find(\n            group => group.ConceptNameCodeSequence.CodeMeaning === SHORT_AXIS\n        );\n\n        const shortAxisSCOORDGroup = toArray(\n            shortAxisNUMGroup.ContentSequence\n        ).find(group => group.ValueType === \"SCOORD\");\n\n        const { ReferencedSOPSequence } = longAxisSCOORDGroup.ContentSequence;\n        const { ReferencedSOPInstanceUID, ReferencedFrameNumber } =\n            ReferencedSOPSequence;\n\n        // Long axis\n\n        const longestDiameter = String(\n            longAxisNUMGroup.MeasuredValueSequence.NumericValue\n        );\n\n        const shortestDiameter = String(\n            shortAxisNUMGroup.MeasuredValueSequence.NumericValue\n        );\n\n        const bottomRight = {\n            x: Math.max(\n                longAxisSCOORDGroup.GraphicData[0],\n                longAxisSCOORDGroup.GraphicData[2],\n                shortAxisSCOORDGroup.GraphicData[0],\n                shortAxisSCOORDGroup.GraphicData[2]\n            ),\n            y: Math.max(\n                longAxisSCOORDGroup.GraphicData[1],\n                longAxisSCOORDGroup.GraphicData[3],\n                shortAxisSCOORDGroup.GraphicData[1],\n                shortAxisSCOORDGroup.GraphicData[3]\n            )\n        };\n\n        const state = {\n            sopInstanceUid: ReferencedSOPInstanceUID,\n            frameIndex: ReferencedFrameNumber || 1,\n            toolType: Bidirectional.toolType,\n            active: false,\n            handles: {\n                start: {\n                    x: longAxisSCOORDGroup.GraphicData[0],\n                    y: longAxisSCOORDGroup.GraphicData[1],\n                    drawnIndependently: false,\n                    allowedOutsideImage: false,\n                    active: false,\n                    highlight: false,\n                    index: 0\n                },\n                end: {\n                    x: longAxisSCOORDGroup.GraphicData[2],\n                    y: longAxisSCOORDGroup.GraphicData[3],\n                    drawnIndependently: false,\n                    allowedOutsideImage: false,\n                    active: false,\n                    highlight: false,\n                    index: 1\n                },\n                perpendicularStart: {\n                    x: shortAxisSCOORDGroup.GraphicData[0],\n                    y: shortAxisSCOORDGroup.GraphicData[1],\n                    drawnIndependently: false,\n                    allowedOutsideImage: false,\n                    active: false,\n                    highlight: false,\n                    index: 2\n                },\n                perpendicularEnd: {\n                    x: shortAxisSCOORDGroup.GraphicData[2],\n                    y: shortAxisSCOORDGroup.GraphicData[3],\n                    drawnIndependently: false,\n                    allowedOutsideImage: false,\n                    active: false,\n                    highlight: false,\n                    index: 3\n                },\n                textBox: {\n                    highlight: false,\n                    hasMoved: true,\n                    active: false,\n                    movesIndependently: false,\n                    drawnIndependently: true,\n                    allowedOutsideImage: true,\n                    hasBoundingBox: true,\n                    x: bottomRight.x + 10,\n                    y: bottomRight.y + 10\n                }\n            },\n            invalidated: false,\n            isCreating: false,\n            longestDiameter,\n            shortestDiameter,\n            toolName: \"Bidirectional\",\n            visible: true,\n            finding: findingGroup\n                ? findingGroup.ConceptCodeSequence\n                : undefined,\n            findingSites: findingSiteGroups.map(fsg => fsg.ConceptCodeSequence)\n        };\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool) {\n        const { start, end, perpendicularStart, perpendicularEnd } =\n            tool.handles;\n        const { shortestDiameter, longestDiameter, finding, findingSites } =\n            tool;\n\n        const trackingIdentifierTextValue =\n            \"cornerstoneTools@^4.0.0:Bidirectional\";\n\n        return {\n            longAxis: {\n                point1: start,\n                point2: end\n            },\n            shortAxis: {\n                point1: perpendicularStart,\n                point2: perpendicularEnd\n            },\n            longAxisLength: longestDiameter,\n            shortAxisLength: shortestDiameter,\n            trackingIdentifierTextValue,\n            finding: finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nBidirectional.toolType = BIDIRECTIONAL;\nBidirectional.utilityToolType = BIDIRECTIONAL;\nBidirectional.TID300Representation = TID300Bidirectional;\nBidirectional.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n    if (!TrackingIdentifier.includes(\":\")) {\n        return false;\n    }\n\n    const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n\n    if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n        return false;\n    }\n\n    return toolType === BIDIRECTIONAL;\n};\n\nMeasurementReport.registerTool(Bidirectional);\n\nexport default Bidirectional;\n","import { utilities } from \"dcmjs\";\nimport MeasurementReport from \"./MeasurementReport\";\nimport CORNERSTONE_4_TAG from \"./cornerstone4Tag\";\n\nconst { Ellipse: TID300Ellipse } = utilities.TID300;\n\nconst ELLIPTICALROI = \"EllipticalRoi\";\n\nclass EllipticalRoi {\n    // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n    static getMeasurementData(MeasurementGroup) {\n        const { defaultState, NUMGroup, SCOORDGroup } =\n            MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n\n        const { GraphicData } = SCOORDGroup;\n\n        const majorAxis = [\n            { x: GraphicData[0], y: GraphicData[1] },\n            { x: GraphicData[2], y: GraphicData[3] }\n        ];\n        const minorAxis = [\n            { x: GraphicData[4], y: GraphicData[5] },\n            { x: GraphicData[6], y: GraphicData[7] }\n        ];\n\n        // Calculate two opposite corners of box defined by two axes.\n\n        const minorAxisLength = Math.sqrt(\n            Math.pow(minorAxis[0].x - minorAxis[1].x, 2) +\n                Math.pow(minorAxis[0].y - minorAxis[1].y, 2)\n        );\n\n        const minorAxisDirection = {\n            x: (minorAxis[1].x - minorAxis[0].x) / minorAxisLength,\n            y: (minorAxis[1].y - minorAxis[0].y) / minorAxisLength\n        };\n\n        const halfMinorAxisLength = minorAxisLength / 2;\n\n        // First end point of major axis + half minor axis vector\n        const corner1 = {\n            x: majorAxis[0].x + minorAxisDirection.x * halfMinorAxisLength,\n            y: majorAxis[0].y + minorAxisDirection.y * halfMinorAxisLength\n        };\n\n        // Second end point of major axis - half of minor axis vector\n        const corner2 = {\n            x: majorAxis[1].x - minorAxisDirection.x * halfMinorAxisLength,\n            y: majorAxis[1].y - minorAxisDirection.y * halfMinorAxisLength\n        };\n        const state = {\n            ...defaultState,\n            toolType: EllipticalRoi.toolType,\n            active: false,\n            cachedStats: {\n                area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0\n            },\n            handles: {\n                end: {\n                    x: corner1.x,\n                    y: corner1.y,\n                    highlight: false,\n                    active: false\n                },\n                initialRotation: 0,\n                start: {\n                    x: corner2.x,\n                    y: corner2.y,\n                    highlight: false,\n                    active: false\n                },\n                textBox: {\n                    hasMoved: false,\n                    movesIndependently: false,\n                    drawnIndependently: true,\n                    allowedOutsideImage: true,\n                    hasBoundingBox: true\n                }\n            },\n            invalidated: true,\n            visible: true\n        };\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool) {\n        const { cachedStats = {}, handles, finding, findingSites } = tool;\n        const { start, end } = handles;\n        const { area } = cachedStats;\n\n        const halfXLength = Math.abs(start.x - end.x) / 2;\n        const halfYLength = Math.abs(start.y - end.y) / 2;\n\n        const points = [];\n\n        const center = { x: (start.x + end.x) / 2, y: (start.y + end.y) / 2 };\n\n        if (halfXLength > halfYLength) {\n            // X-axis major\n            // Major axis\n            points.push({ x: center.x - halfXLength, y: center.y });\n            points.push({ x: center.x + halfXLength, y: center.y });\n            // Minor axis\n            points.push({ x: center.x, y: center.y - halfYLength });\n            points.push({ x: center.x, y: center.y + halfYLength });\n        } else {\n            // Y-axis major\n            // Major axis\n            points.push({ x: center.x, y: center.y - halfYLength });\n            points.push({ x: center.x, y: center.y + halfYLength });\n            // Minor axis\n            points.push({ x: center.x - halfXLength, y: center.y });\n            points.push({ x: center.x + halfXLength, y: center.y });\n        }\n\n        const trackingIdentifierTextValue =\n            \"cornerstoneTools@^4.0.0:EllipticalRoi\";\n\n        return {\n            area,\n            points,\n            trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nEllipticalRoi.toolType = ELLIPTICALROI;\nEllipticalRoi.utilityToolType = ELLIPTICALROI;\nEllipticalRoi.TID300Representation = TID300Ellipse;\nEllipticalRoi.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n    if (!TrackingIdentifier.includes(\":\")) {\n        return false;\n    }\n\n    const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n\n    if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n        return false;\n    }\n\n    return toolType === ELLIPTICALROI;\n};\n\nMeasurementReport.registerTool(EllipticalRoi);\n\nexport default EllipticalRoi;\n","import { utilities } from \"dcmjs\";\nimport MeasurementReport from \"./MeasurementReport\";\nimport CORNERSTONE_4_TAG from \"./cornerstone4Tag\";\n\nconst { Circle: TID300Circle } = utilities.TID300;\n\nconst CIRCLEROI = \"CircleRoi\";\n\nclass CircleRoi {\n    /** Gets the measurement data for cornerstone, given DICOM SR measurement data. */\n    static getMeasurementData(MeasurementGroup) {\n        const { defaultState, NUMGroup, SCOORDGroup } =\n            MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n\n        const { GraphicData } = SCOORDGroup;\n\n        const center = { x: GraphicData[0], y: GraphicData[1] };\n        const end = { x: GraphicData[2], y: GraphicData[3] };\n\n        const state = {\n            ...defaultState,\n            toolType: CircleRoi.toolType,\n            active: false,\n            cachedStats: {\n                area: NUMGroup\n                    ? NUMGroup.MeasuredValueSequence.NumericValue\n                    : 0,\n                // Dummy values to be updated by cornerstone\n                radius: 0,\n                perimeter: 0\n            },\n            handles: {\n                end: {\n                    ...end,\n                    highlight: false,\n                    active: false\n                },\n                initialRotation: 0,\n                start: {\n                    ...center,\n                    highlight: false,\n                    active: false\n                },\n                textBox: {\n                    hasMoved: false,\n                    movesIndependently: false,\n                    drawnIndependently: true,\n                    allowedOutsideImage: true,\n                    hasBoundingBox: true\n                }\n            },\n            invalidated: true,\n            visible: true\n        };\n\n        return state;\n    }\n\n    /**\n     * Gets the TID 300 representation of a circle, given the cornerstone representation.\n     *\n     * @param {Object} tool\n     * @returns\n     */\n    static getTID300RepresentationArguments(tool) {\n        const { cachedStats = {}, handles, finding, findingSites } = tool;\n        const { start: center, end } = handles;\n        const { area, radius } = cachedStats;\n\n        const perimeter = 2 * Math.PI * radius;\n        const points = [];\n\n        points.push(center);\n        points.push(end);\n\n        const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:CircleRoi\";\n\n        return {\n            area,\n            perimeter,\n            radius,\n            points,\n            trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nCircleRoi.toolType = CIRCLEROI;\nCircleRoi.utilityToolType = CIRCLEROI;\nCircleRoi.TID300Representation = TID300Circle;\nCircleRoi.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n    if (!TrackingIdentifier.includes(\":\")) {\n        return false;\n    }\n\n    const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n\n    if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n        return false;\n    }\n\n    return toolType === CIRCLEROI;\n};\n\nMeasurementReport.registerTool(CircleRoi);\n\nexport default CircleRoi;\n","import { utilities } from \"dcmjs\";\n\nimport MeasurementReport from \"./MeasurementReport\";\nimport CORNERSTONE_4_TAG from \"./cornerstone4Tag\";\n\nconst { Point: TID300Point } = utilities.TID300;\n\nconst ARROW_ANNOTATE = \"ArrowAnnotate\";\nconst CORNERSTONEFREETEXT = \"CORNERSTONEFREETEXT\";\n\nclass ArrowAnnotate {\n    static getMeasurementData(MeasurementGroup) {\n        const { defaultState, SCOORDGroup, findingGroup } =\n            MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n\n        const text = findingGroup.ConceptCodeSequence.CodeMeaning;\n\n        const { GraphicData } = SCOORDGroup;\n\n        const state = {\n            ...defaultState,\n            toolType: ArrowAnnotate.toolType,\n            active: false,\n            handles: {\n                start: {\n                    x: GraphicData[0],\n                    y: GraphicData[1],\n                    highlight: true,\n                    active: false\n                },\n                // Use a generic offset if the stored data doesn't have the endpoint, otherwise\n                // use the actual endpoint.\n                end: {\n                    x:\n                        GraphicData.length == 4\n                            ? GraphicData[2]\n                            : GraphicData[0] + 20,\n                    y:\n                        GraphicData.length == 4\n                            ? GraphicData[3]\n                            : GraphicData[1] + 20,\n                    highlight: true,\n                    active: false\n                },\n                textBox: {\n                    hasMoved: false,\n                    movesIndependently: false,\n                    drawnIndependently: true,\n                    allowedOutsideImage: true,\n                    hasBoundingBox: true\n                }\n            },\n            invalidated: true,\n            text,\n            visible: true\n        };\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool) {\n        const points = [tool.handles.start, tool.handles.end];\n\n        let { finding, findingSites } = tool;\n\n        const TID300RepresentationArguments = {\n            points,\n            trackingIdentifierTextValue: `cornerstoneTools@^4.0.0:ArrowAnnotate`,\n            findingSites: findingSites || []\n        };\n\n        // If freetext finding isn't present, add it from the tool text.\n        if (!finding || finding.CodeValue !== CORNERSTONEFREETEXT) {\n            finding = {\n                CodeValue: CORNERSTONEFREETEXT,\n                CodingSchemeDesignator: \"CST4\",\n                CodeMeaning: tool.text\n            };\n        }\n\n        TID300RepresentationArguments.finding = finding;\n\n        return TID300RepresentationArguments;\n    }\n}\n\nArrowAnnotate.toolType = ARROW_ANNOTATE;\nArrowAnnotate.utilityToolType = ARROW_ANNOTATE;\nArrowAnnotate.TID300Representation = TID300Point;\nArrowAnnotate.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n    if (!TrackingIdentifier.includes(\":\")) {\n        return false;\n    }\n\n    const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n\n    if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n        return false;\n    }\n\n    return toolType === ARROW_ANNOTATE;\n};\n\nMeasurementReport.registerTool(ArrowAnnotate);\n\nexport default ArrowAnnotate;\n","import { utilities } from \"dcmjs\";\nimport MeasurementReport from \"./MeasurementReport\";\nimport CORNERSTONE_4_TAG from \"./cornerstone4Tag\";\n\nconst { CobbAngle: TID300CobbAngle } = utilities.TID300;\n\nconst COBB_ANGLE = \"CobbAngle\";\n\nclass CobbAngle {\n    // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n    static getMeasurementData(MeasurementGroup) {\n        const { defaultState, NUMGroup, SCOORDGroup } =\n            MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n\n        const state = {\n            ...defaultState,\n            rAngle: NUMGroup.MeasuredValueSequence.NumericValue,\n            toolType: CobbAngle.toolType,\n            handles: {\n                start: {},\n                end: {},\n                start2: {\n                    highlight: true,\n                    drawnIndependently: true\n                },\n                end2: {\n                    highlight: true,\n                    drawnIndependently: true\n                },\n                textBox: {\n                    hasMoved: false,\n                    movesIndependently: false,\n                    drawnIndependently: true,\n                    allowedOutsideImage: true,\n                    hasBoundingBox: true\n                }\n            }\n        };\n\n        [\n            state.handles.start.x,\n            state.handles.start.y,\n            state.handles.end.x,\n            state.handles.end.y,\n            state.handles.start2.x,\n            state.handles.start2.y,\n            state.handles.end2.x,\n            state.handles.end2.y\n        ] = SCOORDGroup.GraphicData;\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool) {\n        const { handles, finding, findingSites } = tool;\n        const point1 = handles.start;\n        const point2 = handles.end;\n        const point3 = handles.start2;\n        const point4 = handles.end2;\n        const rAngle = tool.rAngle;\n\n        const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:CobbAngle\";\n\n        return {\n            point1,\n            point2,\n            point3,\n            point4,\n            rAngle,\n            trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nCobbAngle.toolType = COBB_ANGLE;\nCobbAngle.utilityToolType = COBB_ANGLE;\nCobbAngle.TID300Representation = TID300CobbAngle;\nCobbAngle.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n    if (!TrackingIdentifier.includes(\":\")) {\n        return false;\n    }\n\n    const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n\n    if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n        return false;\n    }\n\n    return toolType === COBB_ANGLE;\n};\n\nMeasurementReport.registerTool(CobbAngle);\n\nexport default CobbAngle;\n","import { utilities } from \"dcmjs\";\n\nimport MeasurementReport from \"./MeasurementReport\";\nimport CORNERSTONE_4_TAG from \"./cornerstone4Tag\";\n\nconst { Angle: TID300Angle } = utilities.TID300;\n\nconst ANGLE = \"Angle\";\n\nclass Angle {\n    /**\n     * Generate TID300 measurement data for a plane angle measurement - use a Angle, but label it as Angle\n     */\n    static getMeasurementData(MeasurementGroup) {\n        const { defaultState, NUMGroup, SCOORDGroup } =\n            MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n\n        const state = {\n            ...defaultState,\n            rAngle: NUMGroup.MeasuredValueSequence.NumericValue,\n            toolType: Angle.toolType,\n            handles: {\n                start: {},\n                middle: {},\n                end: {},\n                textBox: {\n                    hasMoved: false,\n                    movesIndependently: false,\n                    drawnIndependently: true,\n                    allowedOutsideImage: true,\n                    hasBoundingBox: true\n                }\n            }\n        };\n\n        [\n            state.handles.start.x,\n            state.handles.start.y,\n            state.handles.middle.x,\n            state.handles.middle.y,\n            state.handles.middle.x,\n            state.handles.middle.y,\n            state.handles.end.x,\n            state.handles.end.y\n        ] = SCOORDGroup.GraphicData;\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool) {\n        const { handles, finding, findingSites } = tool;\n        const point1 = handles.start;\n        const point2 = handles.middle;\n        const point3 = handles.middle;\n        const point4 = handles.end;\n        const rAngle = tool.rAngle;\n\n        const trackingIdentifierTextValue = \"cornerstoneTools@^4.0.0:Angle\";\n\n        return {\n            point1,\n            point2,\n            point3,\n            point4,\n            rAngle,\n            trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nAngle.toolType = ANGLE;\nAngle.utilityToolType = ANGLE;\nAngle.TID300Representation = TID300Angle;\nAngle.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n    if (!TrackingIdentifier.includes(\":\")) {\n        return false;\n    }\n\n    const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n\n    if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n        return false;\n    }\n\n    return toolType === ANGLE;\n};\n\nMeasurementReport.registerTool(Angle);\n\nexport default Angle;\n","import { utilities } from \"dcmjs\";\nimport MeasurementReport from \"./MeasurementReport\";\nimport CORNERSTONE_4_TAG from \"./cornerstone4Tag\";\n\nconst { Polyline: TID300Polyline } = utilities.TID300;\n\nclass RectangleRoi {\n    static getMeasurementData(MeasurementGroup) {\n        const { defaultState, SCOORDGroup, NUMGroup } =\n            MeasurementReport.getSetupMeasurementData(MeasurementGroup);\n\n        const state = {\n            ...defaultState,\n            toolType: RectangleRoi.toolType,\n            handles: {\n                start: {},\n                end: {},\n                textBox: {\n                    active: false,\n                    hasMoved: false,\n                    movesIndependently: false,\n                    drawnIndependently: true,\n                    allowedOutsideImage: true,\n                    hasBoundingBox: true\n                },\n                initialRotation: 0\n            },\n            cachedStats: {\n                area: NUMGroup ? NUMGroup.MeasuredValueSequence.NumericValue : 0\n            },\n            color: undefined,\n            invalidated: true\n        };\n        const intermediate = {};\n\n        [\n            state.handles.start.x,\n            state.handles.start.y,\n            intermediate.x,\n            intermediate.y,\n            state.handles.end.x,\n            state.handles.end.y\n        ] = SCOORDGroup.GraphicData;\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool) {\n        const { finding, findingSites, cachedStats = {}, handles } = tool;\n        const { start, end } = handles;\n        const points = [\n            start,\n            { x: start.x, y: end.y },\n            end,\n            { x: end.x, y: start.y }\n        ];\n        const { area, perimeter } = cachedStats;\n\n        const trackingIdentifierTextValue =\n            \"cornerstoneTools@^4.0.0:RectangleRoi\";\n\n        return {\n            points,\n            area,\n            perimeter,\n            trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nRectangleRoi.toolType = \"RectangleRoi\";\nRectangleRoi.utilityToolType = \"RectangleRoi\";\nRectangleRoi.TID300Representation = TID300Polyline;\nRectangleRoi.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n    if (!TrackingIdentifier.includes(\":\")) {\n        return false;\n    }\n\n    const [cornerstone4Tag, toolType] = TrackingIdentifier.split(\":\");\n\n    if (cornerstone4Tag !== CORNERSTONE_4_TAG) {\n        return false;\n    }\n\n    return toolType === RectangleRoi.toolType;\n};\n\nMeasurementReport.registerTool(RectangleRoi);\n\nexport default RectangleRoi;\n","import { log, utilities, normalizers, derivations } from \"dcmjs\";\nimport ndarray from \"ndarray\";\n\nconst {\n    rotateDirectionCosinesInPlane,\n    flipImageOrientationPatient: flipIOP,\n    flipMatrix2D,\n    rotateMatrix902D\n} = utilities.orientation;\n\nconst { datasetToBlob, BitArray, DicomMessage, DicomMetaDictionary } =\n    utilities;\n\nconst { Normalizer } = normalizers;\nconst { Segmentation: SegmentationDerivation } = derivations;\n\nconst Segmentation = {\n    generateSegmentation,\n    generateToolState\n};\n\nexport default Segmentation;\n\n/**\n *\n * @typedef {Object} BrushData\n * @property {Object} toolState - The cornerstoneTools global toolState.\n * @property {Object[]} segments - The cornerstoneTools segment metadata that corresponds to the\n *                                 seriesInstanceUid.\n */\n\n/**\n * generateSegmentation - Generates cornerstoneTools brush data, given a stack of\n * imageIds, images and the cornerstoneTools brushData.\n *\n * @param  {object[]} images    An array of the cornerstone image objects.\n * @param  {BrushData} brushData and object containing the brushData.\n * @returns {type}           description\n */\nfunction generateSegmentation(\n    images,\n    brushData,\n    options = { includeSliceSpacing: true }\n) {\n    const { toolState, segments } = brushData;\n\n    // Calculate the dimensions of the data cube.\n    const image0 = images[0];\n\n    const dims = {\n        x: image0.columns,\n        y: image0.rows,\n        z: images.length\n    };\n\n    dims.xy = dims.x * dims.y;\n\n    const numSegments = _getSegCount(seg, segments);\n\n    if (!numSegments) {\n        throw new Error(\"No segments to export!\");\n    }\n\n    const isMultiframe = image0.imageId.includes(\"?frame\");\n    const seg = _createSegFromImages(images, isMultiframe, options);\n\n    const { referencedFramesPerSegment, segmentIndicies } =\n        _getNumberOfFramesPerSegment(toolState, images, segments);\n\n    let NumberOfFrames = 0;\n\n    for (let i = 0; i < referencedFramesPerSegment.length; i++) {\n        NumberOfFrames += referencedFramesPerSegment[i].length;\n    }\n\n    seg.setNumberOfFrames(NumberOfFrames);\n\n    for (let i = 0; i < segmentIndicies.length; i++) {\n        const segmentIndex = segmentIndicies[i];\n        const referencedFrameIndicies = referencedFramesPerSegment[i];\n\n        // Frame numbers start from 1.\n        const referencedFrameNumbers = referencedFrameIndicies.map(element => {\n            return element + 1;\n        });\n\n        const segment = segments[segmentIndex];\n\n        seg.addSegment(\n            segment,\n            _extractCornerstoneToolsPixelData(\n                segmentIndex,\n                referencedFrameIndicies,\n                toolState,\n                images,\n                dims\n            ),\n            referencedFrameNumbers\n        );\n    }\n\n    seg.bitPackPixelData();\n\n    const segBlob = datasetToBlob(seg.dataset);\n\n    return segBlob;\n}\n\nfunction _extractCornerstoneToolsPixelData(\n    segmentIndex,\n    referencedFrames,\n    toolState,\n    images,\n    dims\n) {\n    const pixelData = new Uint8Array(dims.xy * referencedFrames.length);\n\n    let pixelDataIndex = 0;\n\n    for (let i = 0; i < referencedFrames.length; i++) {\n        const frame = referencedFrames[i];\n\n        const imageId = images[frame].imageId;\n        const imageIdSpecificToolState = toolState[imageId];\n\n        const brushPixelData =\n            imageIdSpecificToolState.brush.data[segmentIndex].pixelData;\n\n        for (let p = 0; p < brushPixelData.length; p++) {\n            pixelData[pixelDataIndex] = brushPixelData[p];\n            pixelDataIndex++;\n        }\n    }\n\n    return pixelData;\n}\n\nfunction _getNumberOfFramesPerSegment(toolState, images, segments) {\n    const segmentIndicies = [];\n    const referencedFramesPerSegment = [];\n\n    for (let i = 0; i < segments.length; i++) {\n        if (segments[i]) {\n            segmentIndicies.push(i);\n            referencedFramesPerSegment.push([]);\n        }\n    }\n\n    for (let z = 0; z < images.length; z++) {\n        const imageId = images[z].imageId;\n        const imageIdSpecificToolState = toolState[imageId];\n\n        for (let i = 0; i < segmentIndicies.length; i++) {\n            const segIdx = segmentIndicies[i];\n\n            if (\n                imageIdSpecificToolState &&\n                imageIdSpecificToolState.brush &&\n                imageIdSpecificToolState.brush.data &&\n                imageIdSpecificToolState.brush.data[segIdx] &&\n                imageIdSpecificToolState.brush.data[segIdx].pixelData\n            ) {\n                referencedFramesPerSegment[i].push(z);\n            }\n        }\n    }\n\n    return {\n        referencedFramesPerSegment,\n        segmentIndicies\n    };\n}\n\nfunction _getSegCount(seg, segments) {\n    let numSegments = 0;\n\n    for (let i = 0; i < segments.length; i++) {\n        if (segments[i]) {\n            numSegments++;\n        }\n    }\n\n    return numSegments;\n}\n\n/**\n * _createSegFromImages - description\n *\n * @param  {Object[]} images    An array of the cornerstone image objects.\n * @param  {Boolean} isMultiframe Whether the images are multiframe.\n * @returns {Object}              The Seg derived dataSet.\n */\nfunction _createSegFromImages(images, isMultiframe, options) {\n    const datasets = [];\n\n    if (isMultiframe) {\n        const image = images[0];\n        const arrayBuffer = image.data.byteArray.buffer;\n\n        const dicomData = DicomMessage.readFile(arrayBuffer);\n        const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\n\n        dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n\n        datasets.push(dataset);\n    } else {\n        for (let i = 0; i < images.length; i++) {\n            const image = images[i];\n            const arrayBuffer = image.data.byteArray.buffer;\n            const dicomData = DicomMessage.readFile(arrayBuffer);\n            const dataset = DicomMetaDictionary.naturalizeDataset(\n                dicomData.dict\n            );\n\n            dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n            datasets.push(dataset);\n        }\n    }\n\n    const multiframe = Normalizer.normalizeToDataset(datasets);\n\n    return new SegmentationDerivation([multiframe], options);\n}\n\n/**\n * generateToolState - Given a set of cornrstoneTools imageIds and a Segmentation buffer,\n * derive cornerstoneTools toolState and brush metadata.\n *\n * @param  {string[]} imageIds    An array of the imageIds.\n * @param  {ArrayBuffer} arrayBuffer The SEG arrayBuffer.\n * @param {*} metadataProvider\n * @returns {Object}  The toolState and an object from which the\n *                    segment metadata can be derived.\n */\nfunction generateToolState(imageIds, arrayBuffer, metadataProvider) {\n    const dicomData = DicomMessage.readFile(arrayBuffer);\n    const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\n    dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n    const multiframe = Normalizer.normalizeToDataset([dataset]);\n\n    const imagePlaneModule = metadataProvider.get(\n        \"imagePlaneModule\",\n        imageIds[0]\n    );\n\n    if (!imagePlaneModule) {\n        console.warn(\"Insufficient metadata, imagePlaneModule missing.\");\n    }\n\n    const ImageOrientationPatient = Array.isArray(imagePlaneModule.rowCosines)\n        ? [...imagePlaneModule.rowCosines, ...imagePlaneModule.columnCosines]\n        : [\n              imagePlaneModule.rowCosines.x,\n              imagePlaneModule.rowCosines.y,\n              imagePlaneModule.rowCosines.z,\n              imagePlaneModule.columnCosines.x,\n              imagePlaneModule.columnCosines.y,\n              imagePlaneModule.columnCosines.z\n          ];\n\n    // Get IOP from ref series, compute supported orientations:\n    const validOrientations = getValidOrientations(ImageOrientationPatient);\n\n    const SharedFunctionalGroupsSequence =\n        multiframe.SharedFunctionalGroupsSequence;\n\n    const sharedImageOrientationPatient =\n        SharedFunctionalGroupsSequence.PlaneOrientationSequence\n            ? SharedFunctionalGroupsSequence.PlaneOrientationSequence\n                  .ImageOrientationPatient\n            : undefined;\n\n    const sliceLength = multiframe.Columns * multiframe.Rows;\n    const segMetadata = getSegmentMetadata(multiframe);\n    const pixelData = unpackPixelData(multiframe);\n\n    const PerFrameFunctionalGroupsSequence =\n        multiframe.PerFrameFunctionalGroupsSequence;\n\n    const toolState = {};\n\n    let inPlane = true;\n\n    for (let i = 0; i < PerFrameFunctionalGroupsSequence.length; i++) {\n        const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[i];\n\n        const ImageOrientationPatientI =\n            sharedImageOrientationPatient ||\n            PerFrameFunctionalGroups.PlaneOrientationSequence\n                .ImageOrientationPatient;\n\n        const pixelDataI2D = ndarray(\n            new Uint8Array(pixelData.buffer, i * sliceLength, sliceLength),\n            [multiframe.Rows, multiframe.Columns]\n        );\n\n        const alignedPixelDataI = alignPixelDataWithSourceData(\n            pixelDataI2D,\n            ImageOrientationPatientI,\n            validOrientations\n        );\n\n        if (!alignedPixelDataI) {\n            console.warn(\n                \"This segmentation object is not in-plane with the source data. Bailing out of IO. It'd be better to render this with vtkjs. \"\n            );\n            inPlane = false;\n            break;\n        }\n\n        const segmentIndex =\n            PerFrameFunctionalGroups.SegmentIdentificationSequence\n                .ReferencedSegmentNumber - 1;\n\n        let SourceImageSequence;\n        if (\n            SharedFunctionalGroupsSequence.DerivationImageSequence &&\n            SharedFunctionalGroupsSequence.DerivationImageSequence\n                .SourceImageSequence\n        ) {\n            SourceImageSequence =\n                SharedFunctionalGroupsSequence.DerivationImageSequence\n                    .SourceImageSequence[i];\n        } else {\n            SourceImageSequence =\n                PerFrameFunctionalGroups.DerivationImageSequence\n                    .SourceImageSequence;\n        }\n\n        const imageId = getImageIdOfSourceImage(\n            SourceImageSequence,\n            imageIds,\n            metadataProvider\n        );\n\n        addImageIdSpecificBrushToolState(\n            toolState,\n            imageId,\n            segmentIndex,\n            alignedPixelDataI\n        );\n    }\n\n    if (!inPlane) {\n        return;\n    }\n\n    return { toolState, segMetadata };\n}\n\n/**\n * unpackPixelData - Unpacks bitpacked pixelData if the Segmentation is BINARY.\n *\n * @param  {Object} multiframe The multiframe dataset.\n * @return {Uint8Array}      The unpacked pixelData.\n */\nfunction unpackPixelData(multiframe) {\n    const segType = multiframe.SegmentationType;\n\n    if (segType === \"BINARY\") {\n        return BitArray.unpack(multiframe.PixelData);\n    }\n\n    const pixelData = new Uint8Array(multiframe.PixelData);\n\n    const max = multiframe.MaximumFractionalValue;\n    const onlyMaxAndZero =\n        pixelData.find(element => element !== 0 && element !== max) ===\n        undefined;\n\n    if (!onlyMaxAndZero) {\n        log.warn(\n            \"This is a fractional segmentation, which is not currently supported.\"\n        );\n        return;\n    }\n\n    log.warn(\n        \"This segmentation object is actually binary... processing as such.\"\n    );\n\n    return pixelData;\n}\n\n/**\n * addImageIdSpecificBrushToolState - Adds brush pixel data to cornerstoneTools\n * formatted toolState object.\n *\n * @param  {Object} toolState    The toolState object to modify\n * @param  {String} imageId      The imageId of the toolState to add the data.\n * @param  {Number} segmentIndex The index of the segment data being added.\n * @param  {Ndarray} pixelData2D  The pixelData in Ndarry 2D format.\n */\nfunction addImageIdSpecificBrushToolState(\n    toolState,\n    imageId,\n    segmentIndex,\n    pixelData2D\n) {\n    if (!toolState[imageId]) {\n        toolState[imageId] = {};\n        toolState[imageId].brush = {};\n        toolState[imageId].brush.data = [];\n    } else if (!toolState[imageId].brush) {\n        toolState[imageId].brush = {};\n        toolState[imageId].brush.data = [];\n    } else if (!toolState[imageId].brush.data) {\n        toolState[imageId].brush.data = [];\n    }\n\n    toolState[imageId].brush.data[segmentIndex] = {};\n\n    const brushDataI = toolState[imageId].brush.data[segmentIndex];\n\n    brushDataI.pixelData = new Uint8Array(pixelData2D.data.length);\n\n    const cToolsPixelData = brushDataI.pixelData;\n\n    for (let p = 0; p < cToolsPixelData.length; p++) {\n        if (pixelData2D.data[p]) {\n            cToolsPixelData[p] = 1;\n        } else {\n            cToolsPixelData[p] = 0;\n        }\n    }\n}\n\n/**\n * getImageIdOfSourceImage - Returns the Cornerstone imageId of the source image.\n *\n * @param  {Object} SourceImageSequence Sequence describing the source image.\n * @param  {String[]} imageIds          A list of imageIds.\n * @param  {Object} metadataProvider    A Cornerstone metadataProvider to query\n *                                      metadata from imageIds.\n * @return {String}                     The corresponding imageId.\n */\nfunction getImageIdOfSourceImage(\n    SourceImageSequence,\n    imageIds,\n    metadataProvider\n) {\n    const { ReferencedSOPInstanceUID, ReferencedFrameNumber } =\n        SourceImageSequence;\n\n    return ReferencedFrameNumber\n        ? getImageIdOfReferencedFrame(\n              ReferencedSOPInstanceUID,\n              ReferencedFrameNumber,\n              imageIds,\n              metadataProvider\n          )\n        : getImageIdOfReferencedSingleFramedSOPInstance(\n              ReferencedSOPInstanceUID,\n              imageIds,\n              metadataProvider\n          );\n}\n\n/**\n * getImageIdOfReferencedSingleFramedSOPInstance - Returns the imageId\n * corresponding to the specified sopInstanceUid for single-frame images.\n *\n * @param  {String} sopInstanceUid   The sopInstanceUid of the desired image.\n * @param  {String[]} imageIds         The list of imageIds.\n * @param  {Object} metadataProvider The metadataProvider to obtain sopInstanceUids\n *                                 from the cornerstone imageIds.\n * @return {String}                  The imageId that corresponds to the sopInstanceUid.\n */\nfunction getImageIdOfReferencedSingleFramedSOPInstance(\n    sopInstanceUid,\n    imageIds,\n    metadataProvider\n) {\n    return imageIds.find(imageId => {\n        const sopCommonModule = metadataProvider.get(\n            \"sopCommonModule\",\n            imageId\n        );\n        if (!sopCommonModule) {\n            return;\n        }\n\n        return sopCommonModule.sopInstanceUID === sopInstanceUid;\n    });\n}\n\n/**\n * getImageIdOfReferencedFrame - Returns the imageId corresponding to the\n * specified sopInstanceUid and frameNumber for multi-frame images.\n *\n * @param  {String} sopInstanceUid   The sopInstanceUid of the desired image.\n * @param  {Number} frameNumber      The frame number.\n * @param  {String} imageIds         The list of imageIds.\n * @param  {Object} metadataProvider The metadataProvider to obtain sopInstanceUids\n *                                   from the cornerstone imageIds.\n * @return {String}                  The imageId that corresponds to the sopInstanceUid.\n */\nfunction getImageIdOfReferencedFrame(\n    sopInstanceUid,\n    frameNumber,\n    imageIds,\n    metadataProvider\n) {\n    const imageId = imageIds.find(imageId => {\n        const sopCommonModule = metadataProvider.get(\n            \"sopCommonModule\",\n            imageId\n        );\n        if (!sopCommonModule) {\n            return;\n        }\n\n        const imageIdFrameNumber = Number(imageId.split(\"frame=\")[1]);\n\n        return (\n            //frameNumber is zero indexed for cornerstoneDICOMImageLoader image Ids.\n            sopCommonModule.sopInstanceUID === sopInstanceUid &&\n            imageIdFrameNumber === frameNumber - 1\n        );\n    });\n\n    return imageId;\n}\n\n/**\n * getValidOrientations - returns an array of valid orientations.\n *\n * @param  iop - The row (0..2) an column (3..5) direction cosines.\n * @return  An array of valid orientations.\n */\nfunction getValidOrientations(iop) {\n    const orientations = [];\n\n    // [0,  1,  2]: 0,   0hf,   0vf\n    // [3,  4,  5]: 90,  90hf,  90vf\n    // [6, 7]:      180, 270\n\n    orientations[0] = iop;\n    orientations[1] = flipIOP.h(iop);\n    orientations[2] = flipIOP.v(iop);\n\n    const iop90 = rotateDirectionCosinesInPlane(iop, Math.PI / 2);\n\n    orientations[3] = iop90;\n    orientations[4] = flipIOP.h(iop90);\n    orientations[5] = flipIOP.v(iop90);\n\n    orientations[6] = rotateDirectionCosinesInPlane(iop, Math.PI);\n    orientations[7] = rotateDirectionCosinesInPlane(iop, 1.5 * Math.PI);\n\n    return orientations;\n}\n\n/**\n * alignPixelDataWithSourceData -\n *\n * @param pixelData2D - The data to align.\n * @param iop - The orientation of the image slice.\n * @param orientations - An array of valid imageOrientationPatient values.\n * @return The aligned pixelData.\n */\nfunction alignPixelDataWithSourceData(pixelData2D, iop, orientations) {\n    if (compareIOP(iop, orientations[0])) {\n        //Same orientation.\n        return pixelData2D;\n    } else if (compareIOP(iop, orientations[1])) {\n        //Flipped vertically.\n        return flipMatrix2D.v(pixelData2D);\n    } else if (compareIOP(iop, orientations[2])) {\n        //Flipped horizontally.\n        return flipMatrix2D.h(pixelData2D);\n    } else if (compareIOP(iop, orientations[3])) {\n        //Rotated 90 degrees.\n        return rotateMatrix902D(pixelData2D);\n    } else if (compareIOP(iop, orientations[4])) {\n        //Rotated 90 degrees and fliped horizontally.\n        return flipMatrix2D.h(rotateMatrix902D(pixelData2D));\n    } else if (compareIOP(iop, orientations[5])) {\n        //Rotated 90 degrees and fliped vertically.\n        return flipMatrix2D.v(rotateMatrix902D(pixelData2D));\n    } else if (compareIOP(iop, orientations[6])) {\n        //Rotated 180 degrees. // TODO -> Do this more effeciently, there is a 1:1 mapping like 90 degree rotation.\n        return rotateMatrix902D(rotateMatrix902D(pixelData2D));\n    } else if (compareIOP(iop, orientations[7])) {\n        //Rotated 270 degrees.  // TODO -> Do this more effeciently, there is a 1:1 mapping like 90 degree rotation.\n        return rotateMatrix902D(\n            rotateMatrix902D(rotateMatrix902D(pixelData2D))\n        );\n    }\n}\n\nconst dx = 1e-5;\n\n/**\n * compareIOP - Returns true if iop1 and iop2 are equal\n * within a tollerance, dx.\n *\n * @param  iop1 - An ImageOrientationPatient array.\n * @param  iop2 - An ImageOrientationPatient array.\n * @return True if iop1 and iop2 are equal.\n */\nfunction compareIOP(iop1, iop2) {\n    return (\n        Math.abs(iop1[0] - iop2[0]) < dx &&\n        Math.abs(iop1[1] - iop2[1]) < dx &&\n        Math.abs(iop1[2] - iop2[2]) < dx &&\n        Math.abs(iop1[3] - iop2[3]) < dx &&\n        Math.abs(iop1[4] - iop2[4]) < dx &&\n        Math.abs(iop1[5] - iop2[5]) < dx\n    );\n}\n\nfunction getSegmentMetadata(multiframe) {\n    const data = [];\n\n    const segmentSequence = multiframe.SegmentSequence;\n\n    if (Array.isArray(segmentSequence)) {\n        for (let segIdx = 0; segIdx < segmentSequence.length; segIdx++) {\n            data.push(segmentSequence[segIdx]);\n        }\n    } else {\n        // Only one segment, will be stored as an object.\n        data.push(segmentSequence);\n    }\n\n    return {\n        seriesInstanceUid:\n            multiframe.ReferencedSeriesSequence.SeriesInstanceUID,\n        data\n    };\n}\n","/**\n * Cornerstone adapters events\n */\nenum Events {\n    /**\n     * Cornerstone segmentation load progress event\n     */\n    SEGMENTATION_LOAD_PROGRESS = \"CORNERSTONE_ADAPTER_SEGMENTATION_LOAD_PROGRESS\"\n}\n\nexport default Events;\n","import {\n    log,\n    data as dcmjsData,\n    utilities,\n    normalizers,\n    derivations\n} from \"dcmjs\";\nimport ndarray from \"ndarray\";\nimport cloneDeep from \"lodash.clonedeep\";\nimport { Buffer } from \"buffer\";\n\nimport { Events } from \"../enums\";\n\nconst {\n    rotateDirectionCosinesInPlane,\n    flipImageOrientationPatient: flipIOP,\n    flipMatrix2D,\n    rotateMatrix902D,\n    nearlyEqual\n} = utilities.orientation;\n\nconst { datasetToDict, BitArray, DicomMessage, DicomMetaDictionary } =\n    dcmjsData;\n\nconst { Normalizer } = normalizers;\nconst { Segmentation: SegmentationDerivation } = derivations;\n\nconst { encode, decode } = utilities.compression;\n\n/**\n *\n * @typedef {Object} BrushData\n * @property {Object} toolState - The cornerstoneTools global toolState.\n * @property {Object[]} segments - The cornerstoneTools segment metadata that corresponds to the\n *                                 seriesInstanceUid.\n */\nconst generateSegmentationDefaultOptions = {\n    includeSliceSpacing: true,\n    rleEncode: false\n};\n\n/**\n * generateSegmentation - Generates cornerstoneTools brush data, given a stack of\n * imageIds, images and the cornerstoneTools brushData.\n *\n * @param  {object[]} images An array of cornerstone images that contain the source\n *                           data under `image.data.byteArray.buffer`.\n * @param  {Object|Object[]} inputLabelmaps3D The cornerstone `Labelmap3D` object, or an array of objects.\n * @param  {Object} userOptions Options to pass to the segmentation derivation and `fillSegmentation`.\n * @returns {Blob}\n */\nfunction generateSegmentation(images, inputLabelmaps3D, userOptions = {}) {\n    const isMultiframe = images[0].imageId.includes(\"?frame\");\n    const segmentation = _createSegFromImages(\n        images,\n        isMultiframe,\n        userOptions\n    );\n\n    return fillSegmentation(segmentation, inputLabelmaps3D, userOptions);\n}\n\n/**\n * fillSegmentation - Fills a derived segmentation dataset with cornerstoneTools `LabelMap3D` data.\n *\n * @param  {object[]} segmentation An empty segmentation derived dataset.\n * @param  {Object|Object[]} inputLabelmaps3D The cornerstone `Labelmap3D` object, or an array of objects.\n * @param  {Object} userOptions Options object to override default options.\n * @returns {Blob}           description\n */\nfunction fillSegmentation(segmentation, inputLabelmaps3D, userOptions = {}) {\n    const options = Object.assign(\n        {},\n        generateSegmentationDefaultOptions,\n        userOptions\n    );\n\n    // Use another variable so we don't redefine labelmaps3D.\n    const labelmaps3D = Array.isArray(inputLabelmaps3D)\n        ? inputLabelmaps3D\n        : [inputLabelmaps3D];\n\n    let numberOfFrames = 0;\n    const referencedFramesPerLabelmap = [];\n\n    for (\n        let labelmapIndex = 0;\n        labelmapIndex < labelmaps3D.length;\n        labelmapIndex++\n    ) {\n        const labelmap3D = labelmaps3D[labelmapIndex];\n        const { labelmaps2D, metadata } = labelmap3D;\n\n        const referencedFramesPerSegment = [];\n\n        for (let i = 1; i < metadata.length; i++) {\n            if (metadata[i]) {\n                referencedFramesPerSegment[i] = [];\n            }\n        }\n\n        for (let i = 0; i < labelmaps2D.length; i++) {\n            const labelmap2D = labelmaps2D[i];\n\n            if (labelmaps2D[i]) {\n                const { segmentsOnLabelmap } = labelmap2D;\n\n                segmentsOnLabelmap.forEach(segmentIndex => {\n                    if (segmentIndex !== 0) {\n                        referencedFramesPerSegment[segmentIndex].push(i);\n                        numberOfFrames++;\n                    }\n                });\n            }\n        }\n\n        referencedFramesPerLabelmap[labelmapIndex] = referencedFramesPerSegment;\n    }\n\n    segmentation.setNumberOfFrames(numberOfFrames);\n\n    for (\n        let labelmapIndex = 0;\n        labelmapIndex < labelmaps3D.length;\n        labelmapIndex++\n    ) {\n        const referencedFramesPerSegment =\n            referencedFramesPerLabelmap[labelmapIndex];\n\n        const labelmap3D = labelmaps3D[labelmapIndex];\n        const { metadata } = labelmap3D;\n\n        for (\n            let segmentIndex = 1;\n            segmentIndex < referencedFramesPerSegment.length;\n            segmentIndex++\n        ) {\n            const referencedFrameIndicies =\n                referencedFramesPerSegment[segmentIndex];\n\n            if (referencedFrameIndicies) {\n                // Frame numbers start from 1.\n                const referencedFrameNumbers = referencedFrameIndicies.map(\n                    element => {\n                        return element + 1;\n                    }\n                );\n                const segmentMetadata = metadata[segmentIndex];\n                const labelmaps = _getLabelmapsFromReferencedFrameIndicies(\n                    labelmap3D,\n                    referencedFrameIndicies\n                );\n\n                segmentation.addSegmentFromLabelmap(\n                    segmentMetadata,\n                    labelmaps,\n                    segmentIndex,\n                    referencedFrameNumbers\n                );\n            }\n        }\n    }\n    if (options.rleEncode) {\n        const rleEncodedFrames = encode(\n            segmentation.dataset.PixelData,\n            numberOfFrames,\n            segmentation.dataset.Rows,\n            segmentation.dataset.Columns\n        );\n\n        // Must use fractional now to RLE encode, as the DICOM standard only allows BitStored && BitsAllocated\n        // to be 1 for BINARY. This is not ideal and there should be a better format for compression in this manner\n        // added to the standard.\n        segmentation.assignToDataset({\n            BitsAllocated: \"8\",\n            BitsStored: \"8\",\n            HighBit: \"7\",\n            SegmentationType: \"FRACTIONAL\",\n            SegmentationFractionalType: \"PROBABILITY\",\n            MaximumFractionalValue: \"255\"\n        });\n\n        segmentation.dataset._meta.TransferSyntaxUID = {\n            Value: [\"1.2.840.10008.1.2.5\"],\n            vr: \"UI\"\n        };\n        segmentation.dataset._vrMap.PixelData = \"OB\";\n        segmentation.dataset.PixelData = rleEncodedFrames;\n    } else {\n        // If no rleEncoding, at least bitpack the data.\n        segmentation.bitPackPixelData();\n    }\n\n    const buffer = Buffer.from(datasetToDict(segmentation.dataset).write());\n    const segBlob = new Blob([buffer], { type: \"application/dicom\" });\n\n    return segBlob;\n}\n\nfunction _getLabelmapsFromReferencedFrameIndicies(\n    labelmap3D,\n    referencedFrameIndicies\n) {\n    const { labelmaps2D } = labelmap3D;\n\n    const labelmaps = [];\n\n    for (let i = 0; i < referencedFrameIndicies.length; i++) {\n        const frame = referencedFrameIndicies[i];\n\n        labelmaps.push(labelmaps2D[frame].pixelData);\n    }\n\n    return labelmaps;\n}\n\n/**\n * _createSegFromImages - description\n *\n * @param  {Object[]} images    An array of the cornerstone image objects.\n * @param  {Boolean} isMultiframe Whether the images are multiframe.\n * @returns {Object}              The Seg derived dataSet.\n */\nfunction _createSegFromImages(images, isMultiframe, options) {\n    const datasets = [];\n\n    if (isMultiframe) {\n        const image = images[0];\n        const arrayBuffer = image.data.byteArray.buffer;\n\n        const dicomData = DicomMessage.readFile(arrayBuffer);\n        const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\n\n        dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n\n        datasets.push(dataset);\n    } else {\n        for (let i = 0; i < images.length; i++) {\n            const image = images[i];\n            const arrayBuffer = image.data.byteArray.buffer;\n            const dicomData = DicomMessage.readFile(arrayBuffer);\n            const dataset = DicomMetaDictionary.naturalizeDataset(\n                dicomData.dict\n            );\n\n            dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n            datasets.push(dataset);\n        }\n    }\n\n    const multiframe = Normalizer.normalizeToDataset(datasets);\n\n    return new SegmentationDerivation([multiframe], options);\n}\n\n/**\n * generateToolState - Given a set of cornrstoneTools imageIds and a Segmentation buffer,\n * derive cornerstoneTools toolState and brush metadata.\n *\n * @param  {string[]} imageIds - An array of the imageIds.\n * @param  {ArrayBuffer} arrayBuffer - The SEG arrayBuffer.\n * @param  {*} metadataProvider.\n * @param  {obj} options - Options object.\n *\n * @return {[]ArrayBuffer}a list of array buffer for each labelMap\n * @return {Object} an object from which the segment metadata can be derived\n * @return {[][][]} 2D list containing the track of segments per frame\n * @return {[][][]} 3D list containing the track of segments per frame for each labelMap\n *                  (available only for the overlapping case).\n */\nasync function generateToolState(\n    imageIds,\n    arrayBuffer,\n    metadataProvider,\n    options\n) {\n    const {\n        skipOverlapping = false,\n        tolerance = 1e-3,\n        TypedArrayConstructor = Uint8Array,\n        maxBytesPerChunk = 199000000,\n        eventTarget,\n        triggerEvent\n    } = options;\n    const dicomData = DicomMessage.readFile(arrayBuffer);\n    const dataset = DicomMetaDictionary.naturalizeDataset(dicomData.dict);\n    dataset._meta = DicomMetaDictionary.namifyDataset(dicomData.meta);\n    const multiframe = Normalizer.normalizeToDataset([dataset]);\n\n    const imagePlaneModule = metadataProvider.get(\n        \"imagePlaneModule\",\n        imageIds[0]\n    );\n\n    const generalSeriesModule = metadataProvider.get(\n        \"generalSeriesModule\",\n        imageIds[0]\n    );\n\n    const SeriesInstanceUID = generalSeriesModule.seriesInstanceUID;\n\n    if (!imagePlaneModule) {\n        console.warn(\"Insufficient metadata, imagePlaneModule missing.\");\n    }\n\n    const ImageOrientationPatient = Array.isArray(imagePlaneModule.rowCosines)\n        ? [...imagePlaneModule.rowCosines, ...imagePlaneModule.columnCosines]\n        : [\n              imagePlaneModule.rowCosines.x,\n              imagePlaneModule.rowCosines.y,\n              imagePlaneModule.rowCosines.z,\n              imagePlaneModule.columnCosines.x,\n              imagePlaneModule.columnCosines.y,\n              imagePlaneModule.columnCosines.z\n          ];\n\n    // Get IOP from ref series, compute supported orientations:\n    const validOrientations = getValidOrientations(ImageOrientationPatient);\n\n    const sliceLength = multiframe.Columns * multiframe.Rows;\n    const segMetadata = getSegmentMetadata(multiframe, SeriesInstanceUID);\n\n    const TransferSyntaxUID = multiframe._meta.TransferSyntaxUID.Value[0];\n\n    let pixelData;\n    let pixelDataChunks;\n\n    if (TransferSyntaxUID === \"1.2.840.10008.1.2.5\") {\n        const rleEncodedFrames = Array.isArray(multiframe.PixelData)\n            ? multiframe.PixelData\n            : [multiframe.PixelData];\n\n        pixelData = decode(\n            rleEncodedFrames,\n            multiframe.Rows,\n            multiframe.Columns\n        );\n\n        if (multiframe.BitsStored === 1) {\n            console.warn(\"No implementation for rle + bitbacking.\");\n\n            return;\n        }\n\n        // Todo: need to test this with rle data\n        pixelDataChunks = [pixelData];\n    } else {\n        pixelDataChunks = unpackPixelData(multiframe, { maxBytesPerChunk });\n\n        if (!pixelDataChunks) {\n            throw new Error(\"Fractional segmentations are not yet supported\");\n        }\n    }\n\n    const orientation = checkOrientation(\n        multiframe,\n        validOrientations,\n        [imagePlaneModule.rows, imagePlaneModule.columns, imageIds.length],\n        tolerance\n    );\n\n    // Pre-compute the sop UID to imageId index map so that in the for loop\n    // we don't have to call metadataProvider.get() for each imageId over\n    // and over again.\n    const sopUIDImageIdIndexMap = imageIds.reduce((acc, imageId) => {\n        const { sopInstanceUid } = metadataProvider.get(\n            \"generalImageModule\",\n            imageId\n        );\n        acc[sopInstanceUid] = imageId;\n        return acc;\n    }, {});\n\n    let overlapping = false;\n    if (!skipOverlapping) {\n        overlapping = checkSEGsOverlapping(\n            pixelDataChunks,\n            multiframe,\n            imageIds,\n            validOrientations,\n            metadataProvider,\n            tolerance,\n            TypedArrayConstructor,\n            sopUIDImageIdIndexMap\n        );\n    }\n\n    let insertFunction;\n\n    switch (orientation) {\n        case \"Planar\":\n            if (overlapping) {\n                insertFunction = insertOverlappingPixelDataPlanar;\n            } else {\n                insertFunction = insertPixelDataPlanar;\n            }\n            break;\n        case \"Perpendicular\":\n            //insertFunction = insertPixelDataPerpendicular;\n            throw new Error(\n                \"Segmentations orthogonal to the acquisition plane of the source data are not yet supported.\"\n            );\n        case \"Oblique\":\n            throw new Error(\n                \"Segmentations oblique to the acquisition plane of the source data are not yet supported.\"\n            );\n    }\n\n    /* if SEGs are overlapping:\n    1) the labelmapBuffer will contain M volumes which have non-overlapping segments;\n    2) segmentsOnFrame will have M * numberOfFrames values to track in which labelMap are the segments;\n    3) insertFunction will return the number of LabelMaps\n    4) generateToolState return is an array*/\n\n    const segmentsOnFrameArray = [];\n    segmentsOnFrameArray[0] = [];\n    const segmentsOnFrame = [];\n\n    const arrayBufferLength =\n        sliceLength * imageIds.length * TypedArrayConstructor.BYTES_PER_ELEMENT;\n    const labelmapBufferArray = [];\n    labelmapBufferArray[0] = new ArrayBuffer(arrayBufferLength);\n\n    // Precompute the indices and metadata so that we don't have to call\n    // a function for each imageId in the for loop.\n    const imageIdMaps = imageIds.reduce(\n        (acc, curr, index) => {\n            acc.indices[curr] = index;\n            acc.metadata[curr] = metadataProvider.get(\"instance\", curr);\n            return acc;\n        },\n        { indices: {}, metadata: {} }\n    );\n\n    // This is the centroid calculation for each segment Index, the data structure\n    // is a Map with key = segmentIndex and value = {imageIdIndex: centroid, ...}\n    // later on we will use this data structure to calculate the centroid of the\n    // segment in the labelmapBuffer\n    const segmentsPixelIndices = new Map();\n\n    await insertFunction(\n        segmentsOnFrame,\n        segmentsOnFrameArray,\n        labelmapBufferArray,\n        pixelDataChunks,\n        multiframe,\n        imageIds,\n        validOrientations,\n        metadataProvider,\n        tolerance,\n        TypedArrayConstructor,\n        segmentsPixelIndices,\n        sopUIDImageIdIndexMap,\n        imageIdMaps,\n        eventTarget,\n        triggerEvent\n    );\n\n    // calculate the centroid of each segment\n    const centroidXYZ = new Map();\n\n    segmentsPixelIndices.forEach((imageIdIndexBufferIndex, segmentIndex) => {\n        const { xAcc, yAcc, zAcc, count } = calculateCentroid(\n            imageIdIndexBufferIndex,\n            multiframe\n        );\n\n        centroidXYZ.set(segmentIndex, {\n            x: Math.floor(xAcc / count),\n            y: Math.floor(yAcc / count),\n            z: Math.floor(zAcc / count)\n        });\n    });\n\n    return {\n        labelmapBufferArray,\n        segMetadata,\n        segmentsOnFrame,\n        segmentsOnFrameArray,\n        centroids: centroidXYZ\n    };\n}\n\n// function insertPixelDataPerpendicular(\n//     segmentsOnFrame,\n//     labelmapBuffer,\n//     pixelData,\n//     multiframe,\n//     imageIds,\n//     validOrientations,\n//     metadataProvider\n// ) {\n//     const {\n//         SharedFunctionalGroupsSequence,\n//         PerFrameFunctionalGroupsSequence,\n//         Rows,\n//         Columns\n//     } = multiframe;\n\n//     const firstImagePlaneModule = metadataProvider.get(\n//         \"imagePlaneModule\",\n//         imageIds[0]\n//     );\n\n//     const lastImagePlaneModule = metadataProvider.get(\n//         \"imagePlaneModule\",\n//         imageIds[imageIds.length - 1]\n//     );\n\n//     console.log(firstImagePlaneModule);\n//     console.log(lastImagePlaneModule);\n\n//     const corners = [\n//         ...getCorners(firstImagePlaneModule),\n//         ...getCorners(lastImagePlaneModule)\n//     ];\n\n//     console.log(`corners:`);\n//     console.log(corners);\n\n//     const indexToWorld = mat4.create();\n\n//     const ippFirstFrame = firstImagePlaneModule.imagePositionPatient;\n//     const rowCosines = Array.isArray(firstImagePlaneModule.rowCosines)\n//         ? [...firstImagePlaneModule.rowCosines]\n//         : [\n//               firstImagePlaneModule.rowCosines.x,\n//               firstImagePlaneModule.rowCosines.y,\n//               firstImagePlaneModule.rowCosines.z\n//           ];\n\n//     const columnCosines = Array.isArray(firstImagePlaneModule.columnCosines)\n//         ? [...firstImagePlaneModule.columnCosines]\n//         : [\n//               firstImagePlaneModule.columnCosines.x,\n//               firstImagePlaneModule.columnCosines.y,\n//               firstImagePlaneModule.columnCosines.z\n//           ];\n\n//     const { pixelSpacing } = firstImagePlaneModule;\n\n//     mat4.set(\n//         indexToWorld,\n//         // Column 1\n//         0,\n//         0,\n//         0,\n//         ippFirstFrame[0],\n//         // Column 2\n//         0,\n//         0,\n//         0,\n//         ippFirstFrame[1],\n//         // Column 3\n//         0,\n//         0,\n//         0,\n//         ippFirstFrame[2],\n//         // Column 4\n//         0,\n//         0,\n//         0,\n//         1\n//     );\n\n//     // TODO -> Get origin and (x,y,z) increments to build a translation matrix:\n//     // TODO -> Equation C.7.6.2.1-1\n\n//     // | cx*di rx* Xx 0 |  |x|\n//     // | cy*di ry Xy 0 |  |y|\n//     // | cz*di rz Xz 0 |  |z|\n//     // | tx ty tz 1 |  |1|\n\n//     // const [\n//     //     0, 0 , 0 , 0,\n//     //     0, 0 , 0 , 0,\n//     //     0, 0 , 0 , 0,\n//     //     ipp[0], ipp[1] , ipp[2] , 1,\n//     // ]\n\n//     // Each frame:\n\n//     // Find which corner the first voxel lines up with (one of 8 corners.)\n\n//     // Find how i,j,k orient with respect to source volume.\n//     // Go through each frame, find location in source to start, and whether to increment +/ix,+/-y,+/-z\n//     //   through each voxel.\n\n//     // [1,0,0,0,1,0]\n\n//     // const [\n\n//     // ]\n\n//     // Invert transformation matrix to get worldToIndex\n\n//     // Apply world to index on each point to fill up the matrix.\n\n//     // const sharedImageOrientationPatient = SharedFunctionalGroupsSequence.PlaneOrientationSequence\n//     //     ? SharedFunctionalGroupsSequence.PlaneOrientationSequence\n//     //           .ImageOrientationPatient\n//     //     : undefined;\n//     // const sliceLength = Columns * Rows;\n// }\n\n// function getCorners(imagePlaneModule) {\n//     // console.log(imagePlaneModule);\n\n//     const {\n//         rows,\n//         columns,\n//         rowCosines,\n//         columnCosines,\n//         imagePositionPatient: ipp,\n//         rowPixelSpacing,\n//         columnPixelSpacing\n//     } = imagePlaneModule;\n\n//     const rowLength = columns * columnPixelSpacing;\n//     const columnLength = rows * rowPixelSpacing;\n\n//     const entireRowVector = [\n//         rowLength * columnCosines[0],\n//         rowLength * columnCosines[1],\n//         rowLength * columnCosines[2]\n//     ];\n\n//     const entireColumnVector = [\n//         columnLength * rowCosines[0],\n//         columnLength * rowCosines[1],\n//         columnLength * rowCosines[2]\n//     ];\n\n//     const topLeft = [ipp[0], ipp[1], ipp[2]];\n//     const topRight = [\n//         topLeft[0] + entireRowVector[0],\n//         topLeft[1] + entireRowVector[1],\n//         topLeft[2] + entireRowVector[2]\n//     ];\n//     const bottomLeft = [\n//         topLeft[0] + entireColumnVector[0],\n//         topLeft[1] + entireColumnVector[1],\n//         topLeft[2] + entireColumnVector[2]\n//     ];\n\n//     const bottomRight = [\n//         bottomLeft[0] + entireRowVector[0],\n//         bottomLeft[1] + entireRowVector[1],\n//         bottomLeft[2] + entireRowVector[2]\n//     ];\n\n//     return [topLeft, topRight, bottomLeft, bottomRight];\n// }\n\n/**\n * Find the reference frame of the segmentation frame in the source data.\n *\n * @param  {Object}      multiframe        dicom metadata\n * @param  {Int}         frameSegment      frame dicom index\n * @param  {String[]}    imageIds          A list of imageIds.\n * @param  {Object}      sopUIDImageIdIndexMap  A map of SOPInstanceUID to imageId\n * @param  {Float}       tolerance         The tolerance parameter\n *\n * @returns {String}     Returns the imageId\n */\nfunction findReferenceSourceImageId(\n    multiframe,\n    frameSegment,\n    imageIds,\n    metadataProvider,\n    tolerance,\n    sopUIDImageIdIndexMap\n) {\n    let imageId = undefined;\n\n    if (!multiframe) {\n        return imageId;\n    }\n\n    const {\n        FrameOfReferenceUID,\n        PerFrameFunctionalGroupsSequence,\n        SourceImageSequence,\n        ReferencedSeriesSequence\n    } = multiframe;\n\n    if (\n        !PerFrameFunctionalGroupsSequence ||\n        PerFrameFunctionalGroupsSequence.length === 0\n    ) {\n        return imageId;\n    }\n\n    const PerFrameFunctionalGroup =\n        PerFrameFunctionalGroupsSequence[frameSegment];\n\n    if (!PerFrameFunctionalGroup) {\n        return imageId;\n    }\n\n    let frameSourceImageSequence = undefined;\n    if (SourceImageSequence && SourceImageSequence.length !== 0) {\n        frameSourceImageSequence = SourceImageSequence[frameSegment];\n    } else if (PerFrameFunctionalGroup.DerivationImageSequence) {\n        let DerivationImageSequence =\n            PerFrameFunctionalGroup.DerivationImageSequence;\n        if (Array.isArray(DerivationImageSequence)) {\n            if (DerivationImageSequence.length !== 0) {\n                DerivationImageSequence = DerivationImageSequence[0];\n            } else {\n                DerivationImageSequence = undefined;\n            }\n        }\n\n        if (DerivationImageSequence) {\n            frameSourceImageSequence =\n                DerivationImageSequence.SourceImageSequence;\n            if (Array.isArray(frameSourceImageSequence)) {\n                if (frameSourceImageSequence.length !== 0) {\n                    frameSourceImageSequence = frameSourceImageSequence[0];\n                } else {\n                    frameSourceImageSequence = undefined;\n                }\n            }\n        }\n    }\n\n    if (frameSourceImageSequence) {\n        imageId = getImageIdOfSourceImageBySourceImageSequence(\n            frameSourceImageSequence,\n            sopUIDImageIdIndexMap\n        );\n    }\n\n    if (imageId === undefined && ReferencedSeriesSequence) {\n        const referencedSeriesSequence = Array.isArray(ReferencedSeriesSequence)\n            ? ReferencedSeriesSequence[0]\n            : ReferencedSeriesSequence;\n        const ReferencedSeriesInstanceUID =\n            referencedSeriesSequence.SeriesInstanceUID;\n\n        imageId = getImageIdOfSourceImagebyGeometry(\n            ReferencedSeriesInstanceUID,\n            FrameOfReferenceUID,\n            PerFrameFunctionalGroup,\n            imageIds,\n            metadataProvider,\n            tolerance\n        );\n    }\n\n    return imageId;\n}\n\n/**\n * Checks if there is any overlapping segmentations.\n *  @returns {boolean} Returns a flag if segmentations overlapping\n */\n\nfunction checkSEGsOverlapping(\n    pixelData,\n    multiframe,\n    imageIds,\n    validOrientations,\n    metadataProvider,\n    tolerance,\n    TypedArrayConstructor,\n    sopUIDImageIdIndexMap\n) {\n    const {\n        SharedFunctionalGroupsSequence,\n        PerFrameFunctionalGroupsSequence,\n        SegmentSequence,\n        Rows,\n        Columns\n    } = multiframe;\n\n    let numberOfSegs = SegmentSequence.length;\n    if (numberOfSegs < 2) {\n        return false;\n    }\n\n    const sharedImageOrientationPatient =\n        SharedFunctionalGroupsSequence.PlaneOrientationSequence\n            ? SharedFunctionalGroupsSequence.PlaneOrientationSequence\n                  .ImageOrientationPatient\n            : undefined;\n    const sliceLength = Columns * Rows;\n    const groupsLen = PerFrameFunctionalGroupsSequence.length;\n\n    /** sort groupsLen to have all the segments for each frame in an array\n     * frame 2 : 1, 2\n     * frame 4 : 1, 3\n     * frame 5 : 4\n     */\n\n    let frameSegmentsMapping = new Map();\n    for (let frameSegment = 0; frameSegment < groupsLen; ++frameSegment) {\n        const segmentIndex = getSegmentIndex(multiframe, frameSegment);\n        if (segmentIndex === undefined) {\n            console.warn(\n                \"Could not retrieve the segment index for frame segment \" +\n                    frameSegment +\n                    \", skipping this frame.\"\n            );\n            continue;\n        }\n\n        const imageId = findReferenceSourceImageId(\n            multiframe,\n            frameSegment,\n            imageIds,\n            metadataProvider,\n            tolerance,\n            sopUIDImageIdIndexMap\n        );\n\n        if (!imageId) {\n            console.warn(\n                \"Image not present in stack, can't import frame : \" +\n                    frameSegment +\n                    \".\"\n            );\n            continue;\n        }\n\n        const imageIdIndex = imageIds.findIndex(element => element === imageId);\n\n        if (frameSegmentsMapping.has(imageIdIndex)) {\n            let segmentArray = frameSegmentsMapping.get(imageIdIndex);\n            if (!segmentArray.includes(frameSegment)) {\n                segmentArray.push(frameSegment);\n                frameSegmentsMapping.set(imageIdIndex, segmentArray);\n            }\n        } else {\n            frameSegmentsMapping.set(imageIdIndex, [frameSegment]);\n        }\n    }\n\n    for (let [, role] of frameSegmentsMapping.entries()) {\n        let temp2DArray = new TypedArrayConstructor(sliceLength).fill(0);\n\n        for (let i = 0; i < role.length; ++i) {\n            const frameSegment = role[i];\n\n            const PerFrameFunctionalGroups =\n                PerFrameFunctionalGroupsSequence[frameSegment];\n\n            const ImageOrientationPatientI =\n                sharedImageOrientationPatient ||\n                PerFrameFunctionalGroups.PlaneOrientationSequence\n                    .ImageOrientationPatient;\n\n            const view = readFromUnpackedChunks(\n                pixelData,\n                frameSegment * sliceLength,\n                sliceLength\n            );\n\n            const pixelDataI2D = ndarray(view, [Rows, Columns]);\n\n            const alignedPixelDataI = alignPixelDataWithSourceData(\n                pixelDataI2D,\n                ImageOrientationPatientI,\n                validOrientations,\n                tolerance\n            );\n\n            if (!alignedPixelDataI) {\n                console.warn(\n                    \"Individual SEG frames are out of plane with respect to the first SEG frame, this is not yet supported, skipping this frame.\"\n                );\n                continue;\n            }\n\n            const data = alignedPixelDataI.data;\n            for (let j = 0, len = data.length; j < len; ++j) {\n                if (data[j] !== 0) {\n                    temp2DArray[j]++;\n                    if (temp2DArray[j] > 1) {\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n\n    return false;\n}\n\nfunction insertOverlappingPixelDataPlanar(\n    segmentsOnFrame,\n    segmentsOnFrameArray,\n    labelmapBufferArray,\n    pixelData,\n    multiframe,\n    imageIds,\n    validOrientations,\n    metadataProvider,\n    tolerance,\n    TypedArrayConstructor,\n    segmentsPixelIndices,\n    sopUIDImageIdIndexMap\n) {\n    const {\n        SharedFunctionalGroupsSequence,\n        PerFrameFunctionalGroupsSequence,\n        Rows,\n        Columns\n    } = multiframe;\n\n    const sharedImageOrientationPatient =\n        SharedFunctionalGroupsSequence.PlaneOrientationSequence\n            ? SharedFunctionalGroupsSequence.PlaneOrientationSequence\n                  .ImageOrientationPatient\n            : undefined;\n    const sliceLength = Columns * Rows;\n    const arrayBufferLength =\n        sliceLength * imageIds.length * TypedArrayConstructor.BYTES_PER_ELEMENT;\n    // indicate the number of labelMaps\n    let M = 1;\n\n    // indicate the current labelMap array index;\n    let m = 0;\n\n    // temp array for checking overlaps\n    let tempBuffer = labelmapBufferArray[m].slice(0);\n\n    // temp list for checking overlaps\n    let tempSegmentsOnFrame = cloneDeep(segmentsOnFrameArray[m]);\n\n    /** split overlapping SEGs algorithm for each segment:\n     *  A) copy the labelmapBuffer in the array with index 0\n     *  B) add the segment pixel per pixel on the copied buffer from (A)\n     *  C) if no overlap, copy the results back on the orignal array from (A)\n     *  D) if overlap, repeat increasing the index m up to M (if out of memory, add new buffer in the array and M++);\n     */\n\n    let numberOfSegs = multiframe.SegmentSequence.length;\n    for (\n        let segmentIndexToProcess = 1;\n        segmentIndexToProcess <= numberOfSegs;\n        ++segmentIndexToProcess\n    ) {\n        for (\n            let i = 0, groupsLen = PerFrameFunctionalGroupsSequence.length;\n            i < groupsLen;\n            ++i\n        ) {\n            const PerFrameFunctionalGroups =\n                PerFrameFunctionalGroupsSequence[i];\n\n            const segmentIndex = getSegmentIndex(multiframe, i);\n            if (segmentIndex === undefined) {\n                throw new Error(\n                    \"Could not retrieve the segment index. Aborting segmentation loading.\"\n                );\n            }\n\n            if (segmentIndex !== segmentIndexToProcess) {\n                continue;\n            }\n\n            const ImageOrientationPatientI =\n                sharedImageOrientationPatient ||\n                PerFrameFunctionalGroups.PlaneOrientationSequence\n                    .ImageOrientationPatient;\n\n            // Since we moved to the chunks approach, we need to read the data\n            // and handle scenarios where the portion of data is in one chunk\n            // and the other portion is in another chunk\n            const view = readFromUnpackedChunks(\n                pixelData,\n                i * sliceLength,\n                sliceLength\n            );\n\n            const pixelDataI2D = ndarray(view, [Rows, Columns]);\n\n            const alignedPixelDataI = alignPixelDataWithSourceData(\n                pixelDataI2D,\n                ImageOrientationPatientI,\n                validOrientations,\n                tolerance\n            );\n\n            if (!alignedPixelDataI) {\n                throw new Error(\n                    \"Individual SEG frames are out of plane with respect to the first SEG frame. \" +\n                        \"This is not yet supported. Aborting segmentation loading.\"\n                );\n            }\n\n            const imageId = findReferenceSourceImageId(\n                multiframe,\n                i,\n                imageIds,\n                metadataProvider,\n                tolerance,\n                sopUIDImageIdIndexMap\n            );\n\n            if (!imageId) {\n                console.warn(\n                    \"Image not present in stack, can't import frame : \" +\n                        i +\n                        \".\"\n                );\n                continue;\n            }\n\n            const sourceImageMetadata = metadataProvider.get(\n                \"instance\",\n                imageId\n            );\n            if (\n                Rows !== sourceImageMetadata.Rows ||\n                Columns !== sourceImageMetadata.Columns\n            ) {\n                throw new Error(\n                    \"Individual SEG frames have different geometry dimensions (Rows and Columns) \" +\n                        \"respect to the source image reference frame. This is not yet supported. \" +\n                        \"Aborting segmentation loading. \"\n                );\n            }\n\n            const imageIdIndex = imageIds.findIndex(\n                element => element === imageId\n            );\n            const byteOffset =\n                sliceLength *\n                imageIdIndex *\n                TypedArrayConstructor.BYTES_PER_ELEMENT;\n\n            const labelmap2DView = new TypedArrayConstructor(\n                tempBuffer,\n                byteOffset,\n                sliceLength\n            );\n\n            const data = alignedPixelDataI.data;\n\n            let segmentOnFrame = false;\n            for (let j = 0, len = alignedPixelDataI.data.length; j < len; ++j) {\n                if (data[j]) {\n                    if (labelmap2DView[j] !== 0) {\n                        m++;\n                        if (m >= M) {\n                            labelmapBufferArray[m] = new ArrayBuffer(\n                                arrayBufferLength\n                            );\n                            segmentsOnFrameArray[m] = [];\n                            M++;\n                        }\n                        tempBuffer = labelmapBufferArray[m].slice(0);\n                        tempSegmentsOnFrame = cloneDeep(\n                            segmentsOnFrameArray[m]\n                        );\n\n                        i = 0;\n                        break;\n                    } else {\n                        labelmap2DView[j] = segmentIndex;\n                        segmentOnFrame = true;\n                    }\n                }\n            }\n\n            if (segmentOnFrame) {\n                if (!tempSegmentsOnFrame[imageIdIndex]) {\n                    tempSegmentsOnFrame[imageIdIndex] = [];\n                }\n\n                tempSegmentsOnFrame[imageIdIndex].push(segmentIndex);\n\n                if (!segmentsOnFrame[imageIdIndex]) {\n                    segmentsOnFrame[imageIdIndex] = [];\n                }\n\n                segmentsOnFrame[imageIdIndex].push(segmentIndex);\n            }\n        }\n\n        labelmapBufferArray[m] = tempBuffer.slice(0);\n        segmentsOnFrameArray[m] = cloneDeep(tempSegmentsOnFrame);\n\n        // reset temp variables/buffers for new segment\n        m = 0;\n        tempBuffer = labelmapBufferArray[m].slice(0);\n        tempSegmentsOnFrame = cloneDeep(segmentsOnFrameArray[m]);\n    }\n}\n\nconst getSegmentIndex = (multiframe, frame) => {\n    const { PerFrameFunctionalGroupsSequence, SharedFunctionalGroupsSequence } =\n        multiframe;\n    const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[frame];\n    return PerFrameFunctionalGroups &&\n        PerFrameFunctionalGroups.SegmentIdentificationSequence\n        ? PerFrameFunctionalGroups.SegmentIdentificationSequence\n              .ReferencedSegmentNumber\n        : SharedFunctionalGroupsSequence.SegmentIdentificationSequence\n        ? SharedFunctionalGroupsSequence.SegmentIdentificationSequence\n              .ReferencedSegmentNumber\n        : undefined;\n};\n\nfunction insertPixelDataPlanar(\n    segmentsOnFrame,\n    segmentsOnFrameArray,\n    labelmapBufferArray,\n    pixelData,\n    multiframe,\n    imageIds,\n    validOrientations,\n    metadataProvider,\n    tolerance,\n    TypedArrayConstructor,\n    segmentsPixelIndices,\n    sopUIDImageIdIndexMap,\n    imageIdMaps,\n    eventTarget,\n    triggerEvent\n) {\n    const {\n        SharedFunctionalGroupsSequence,\n        PerFrameFunctionalGroupsSequence,\n        Rows,\n        Columns\n    } = multiframe;\n\n    const sharedImageOrientationPatient =\n        SharedFunctionalGroupsSequence.PlaneOrientationSequence\n            ? SharedFunctionalGroupsSequence.PlaneOrientationSequence\n                  .ImageOrientationPatient\n            : undefined;\n    const sliceLength = Columns * Rows;\n\n    let i = 0;\n    const groupsLen = PerFrameFunctionalGroupsSequence.length;\n    const chunkSize = Math.ceil(groupsLen / 10); // 10% of total length\n\n    const shouldTriggerEvent = triggerEvent && eventTarget;\n\n    // Below, we chunk the processing of the frames to avoid blocking the main thread\n    // if the segmentation is large. We also use a promise to allow the caller to\n    // wait for the processing to finish.\n    return new Promise(resolve => {\n        function processInChunks() {\n            // process one chunk\n            for (let end = Math.min(i + chunkSize, groupsLen); i < end; ++i) {\n                const PerFrameFunctionalGroups =\n                    PerFrameFunctionalGroupsSequence[i];\n\n                const ImageOrientationPatientI =\n                    sharedImageOrientationPatient ||\n                    PerFrameFunctionalGroups.PlaneOrientationSequence\n                        .ImageOrientationPatient;\n\n                const view = readFromUnpackedChunks(\n                    pixelData,\n                    i * sliceLength,\n                    sliceLength\n                );\n\n                const pixelDataI2D = ndarray(view, [Rows, Columns]);\n\n                const alignedPixelDataI = alignPixelDataWithSourceData(\n                    pixelDataI2D,\n                    ImageOrientationPatientI,\n                    validOrientations,\n                    tolerance\n                );\n\n                if (!alignedPixelDataI) {\n                    throw new Error(\n                        \"Individual SEG frames are out of plane with respect to the first SEG frame. \" +\n                            \"This is not yet supported. Aborting segmentation loading.\"\n                    );\n                }\n\n                const segmentIndex = getSegmentIndex(multiframe, i);\n\n                if (segmentIndex === undefined) {\n                    throw new Error(\n                        \"Could not retrieve the segment index. Aborting segmentation loading.\"\n                    );\n                }\n\n                if (!segmentsPixelIndices.has(segmentIndex)) {\n                    segmentsPixelIndices.set(segmentIndex, {});\n                }\n\n                const imageId = findReferenceSourceImageId(\n                    multiframe,\n                    i,\n                    imageIds,\n                    metadataProvider,\n                    tolerance,\n                    sopUIDImageIdIndexMap\n                );\n\n                if (!imageId) {\n                    console.warn(\n                        \"Image not present in stack, can't import frame : \" +\n                            i +\n                            \".\"\n                    );\n                    continue;\n                }\n\n                const sourceImageMetadata = imageIdMaps.metadata[imageId];\n                if (\n                    Rows !== sourceImageMetadata.Rows ||\n                    Columns !== sourceImageMetadata.Columns\n                ) {\n                    throw new Error(\n                        \"Individual SEG frames have different geometry dimensions (Rows and Columns) \" +\n                            \"respect to the source image reference frame. This is not yet supported. \" +\n                            \"Aborting segmentation loading. \"\n                    );\n                }\n\n                const imageIdIndex = imageIdMaps.indices[imageId];\n\n                const byteOffset =\n                    sliceLength *\n                    imageIdIndex *\n                    TypedArrayConstructor.BYTES_PER_ELEMENT;\n\n                const labelmap2DView = new TypedArrayConstructor(\n                    labelmapBufferArray[0],\n                    byteOffset,\n                    sliceLength\n                );\n\n                const data = alignedPixelDataI.data;\n\n                const indexCache = [];\n                for (\n                    let j = 0, len = alignedPixelDataI.data.length;\n                    j < len;\n                    ++j\n                ) {\n                    if (data[j]) {\n                        for (let x = j; x < len; ++x) {\n                            if (data[x]) {\n                                labelmap2DView[x] = segmentIndex;\n                                indexCache.push(x);\n                            }\n                        }\n\n                        if (!segmentsOnFrame[imageIdIndex]) {\n                            segmentsOnFrame[imageIdIndex] = [];\n                        }\n\n                        segmentsOnFrame[imageIdIndex].push(segmentIndex);\n\n                        break;\n                    }\n                }\n\n                const segmentIndexObject =\n                    segmentsPixelIndices.get(segmentIndex);\n                segmentIndexObject[imageIdIndex] = indexCache;\n                segmentsPixelIndices.set(segmentIndex, segmentIndexObject);\n            }\n\n            // trigger an event after each chunk\n            if (shouldTriggerEvent) {\n                const percentComplete = Math.round((i / groupsLen) * 100);\n                triggerEvent(eventTarget, Events.SEGMENTATION_LOAD_PROGRESS, {\n                    percentComplete\n                });\n            }\n\n            // schedule next chunk\n            if (i < groupsLen) {\n                setTimeout(processInChunks, 0);\n            } else {\n                // resolve the Promise when all chunks have been processed\n                resolve();\n            }\n        }\n\n        processInChunks();\n    });\n}\n\nfunction checkOrientation(\n    multiframe,\n    validOrientations,\n    sourceDataDimensions,\n    tolerance\n) {\n    const { SharedFunctionalGroupsSequence, PerFrameFunctionalGroupsSequence } =\n        multiframe;\n\n    const sharedImageOrientationPatient =\n        SharedFunctionalGroupsSequence.PlaneOrientationSequence\n            ? SharedFunctionalGroupsSequence.PlaneOrientationSequence\n                  .ImageOrientationPatient\n            : undefined;\n\n    // Check if in plane.\n    const PerFrameFunctionalGroups = PerFrameFunctionalGroupsSequence[0];\n\n    const iop =\n        sharedImageOrientationPatient ||\n        PerFrameFunctionalGroups.PlaneOrientationSequence\n            .ImageOrientationPatient;\n\n    const inPlane = validOrientations.some(operation =>\n        compareArrays(iop, operation, tolerance)\n    );\n\n    if (inPlane) {\n        return \"Planar\";\n    }\n\n    if (\n        checkIfPerpendicular(iop, validOrientations[0], tolerance) &&\n        sourceDataDimensions.includes(multiframe.Rows) &&\n        sourceDataDimensions.includes(multiframe.Columns)\n    ) {\n        // Perpendicular and fits on same grid.\n        return \"Perpendicular\";\n    }\n\n    return \"Oblique\";\n}\n\n/**\n * checkIfPerpendicular - Returns true if iop1 and iop2 are perpendicular\n * within a tolerance.\n *\n * @param  {Number[6]} iop1 An ImageOrientationPatient array.\n * @param  {Number[6]} iop2 An ImageOrientationPatient array.\n * @param  {Number} tolerance.\n * @return {Boolean} True if iop1 and iop2 are equal.\n */\nfunction checkIfPerpendicular(iop1, iop2, tolerance) {\n    const absDotColumnCosines = Math.abs(\n        iop1[0] * iop2[0] + iop1[1] * iop2[1] + iop1[2] * iop2[2]\n    );\n    const absDotRowCosines = Math.abs(\n        iop1[3] * iop2[3] + iop1[4] * iop2[4] + iop1[5] * iop2[5]\n    );\n\n    return (\n        (absDotColumnCosines < tolerance ||\n            Math.abs(absDotColumnCosines - 1) < tolerance) &&\n        (absDotRowCosines < tolerance ||\n            Math.abs(absDotRowCosines - 1) < tolerance)\n    );\n}\n\n/**\n * unpackPixelData - Unpacks bit packed pixelData if the Segmentation is BINARY.\n *\n * @param  {Object} multiframe The multiframe dataset.\n * @param  {Object} options    Options for the unpacking.\n * @return {Uint8Array}      The unpacked pixelData.\n */\nfunction unpackPixelData(multiframe, options) {\n    const segType = multiframe.SegmentationType;\n\n    let data;\n    if (Array.isArray(multiframe.PixelData)) {\n        data = multiframe.PixelData[0];\n    } else {\n        data = multiframe.PixelData;\n    }\n\n    if (data === undefined) {\n        log.error(\"This segmentation pixeldata is undefined.\");\n    }\n\n    if (segType === \"BINARY\") {\n        // For extreme big data, we can't unpack the data at once and we need to\n        // chunk it and unpack each chunk separately.\n        // MAX 2GB is the limit right now to allocate a buffer\n        return getUnpackedChunks(data, options.maxBytesPerChunk);\n    }\n\n    const pixelData = new Uint8Array(data);\n\n    const max = multiframe.MaximumFractionalValue;\n    const onlyMaxAndZero =\n        pixelData.find(element => element !== 0 && element !== max) ===\n        undefined;\n\n    if (!onlyMaxAndZero) {\n        // This is a fractional segmentation, which is not currently supported.\n        return;\n    }\n\n    log.warn(\n        \"This segmentation object is actually binary... processing as such.\"\n    );\n\n    return pixelData;\n}\n\nfunction getUnpackedChunks(data, maxBytesPerChunk) {\n    var bitArray = new Uint8Array(data);\n    var chunks = [];\n\n    var maxBitsPerChunk = maxBytesPerChunk * 8;\n    var numberOfChunks = Math.ceil((bitArray.length * 8) / maxBitsPerChunk);\n\n    for (var i = 0; i < numberOfChunks; i++) {\n        var startBit = i * maxBitsPerChunk;\n        var endBit = Math.min(startBit + maxBitsPerChunk, bitArray.length * 8);\n\n        var startByte = Math.floor(startBit / 8);\n        var endByte = Math.ceil(endBit / 8);\n\n        var chunk = bitArray.slice(startByte, endByte);\n        var unpackedChunk = BitArray.unpack(chunk);\n\n        chunks.push(unpackedChunk);\n    }\n\n    return chunks;\n}\n\n/**\n * getImageIdOfSourceImageBySourceImageSequence - Returns the Cornerstone imageId of the source image.\n *\n * @param  {Object}   SourceImageSequence  Sequence describing the source image.\n * @param  {String[]} imageIds             A list of imageIds.\n * @param  {Object}   sopUIDImageIdIndexMap A map of SOPInstanceUIDs to imageIds.\n * @return {String}                        The corresponding imageId.\n */\nfunction getImageIdOfSourceImageBySourceImageSequence(\n    SourceImageSequence,\n    sopUIDImageIdIndexMap\n) {\n    const { ReferencedSOPInstanceUID, ReferencedFrameNumber } =\n        SourceImageSequence;\n\n    return ReferencedFrameNumber\n        ? getImageIdOfReferencedFrame(\n              ReferencedSOPInstanceUID,\n              ReferencedFrameNumber,\n              sopUIDImageIdIndexMap\n          )\n        : sopUIDImageIdIndexMap[ReferencedSOPInstanceUID];\n}\n\n/**\n * getImageIdOfSourceImagebyGeometry - Returns the Cornerstone imageId of the source image.\n *\n * @param  {String}    ReferencedSeriesInstanceUID    Referenced series of the source image.\n * @param  {String}    FrameOfReferenceUID            Frame of reference.\n * @param  {Object}    PerFrameFunctionalGroup        Sequence describing segmentation reference attributes per frame.\n * @param  {String[]}  imageIds                       A list of imageIds.\n * @param  {Object}    sopUIDImageIdIndexMap          A map of SOPInstanceUIDs to imageIds.\n * @param  {Float}     tolerance                      The tolerance parameter\n *\n * @return {String}                                   The corresponding imageId.\n */\nfunction getImageIdOfSourceImagebyGeometry(\n    ReferencedSeriesInstanceUID,\n    FrameOfReferenceUID,\n    PerFrameFunctionalGroup,\n    imageIds,\n    metadataProvider,\n    tolerance\n) {\n    if (\n        ReferencedSeriesInstanceUID === undefined ||\n        PerFrameFunctionalGroup.PlanePositionSequence === undefined ||\n        PerFrameFunctionalGroup.PlanePositionSequence[0] === undefined ||\n        PerFrameFunctionalGroup.PlanePositionSequence[0]\n            .ImagePositionPatient === undefined\n    ) {\n        return undefined;\n    }\n\n    for (\n        let imageIdsIndexc = 0;\n        imageIdsIndexc < imageIds.length;\n        ++imageIdsIndexc\n    ) {\n        const sourceImageMetadata = metadataProvider.get(\n            \"instance\",\n            imageIds[imageIdsIndexc]\n        );\n\n        if (\n            sourceImageMetadata === undefined ||\n            sourceImageMetadata.ImagePositionPatient === undefined ||\n            sourceImageMetadata.FrameOfReferenceUID !== FrameOfReferenceUID ||\n            sourceImageMetadata.SeriesInstanceUID !==\n                ReferencedSeriesInstanceUID\n        ) {\n            continue;\n        }\n\n        if (\n            compareArrays(\n                PerFrameFunctionalGroup.PlanePositionSequence[0]\n                    .ImagePositionPatient,\n                sourceImageMetadata.ImagePositionPatient,\n                tolerance\n            )\n        ) {\n            return imageIds[imageIdsIndexc];\n        }\n    }\n}\n\n/**\n * getImageIdOfReferencedFrame - Returns the imageId corresponding to the\n * specified sopInstanceUid and frameNumber for multi-frame images.\n *\n * @param  {String} sopInstanceUid   The sopInstanceUid of the desired image.\n * @param  {Number} frameNumber      The frame number.\n * @param  {String} imageIds         The list of imageIds.\n * @param  {Object} sopUIDImageIdIndexMap A map of SOPInstanceUIDs to imageIds.\n * @return {String}                  The imageId that corresponds to the sopInstanceUid.\n */\nfunction getImageIdOfReferencedFrame(\n    sopInstanceUid,\n    frameNumber,\n    sopUIDImageIdIndexMap\n) {\n    const imageId = sopUIDImageIdIndexMap[sopInstanceUid];\n\n    if (!imageId) {\n        return;\n    }\n\n    const imageIdFrameNumber = Number(imageId.split(\"frame=\")[1]);\n\n    return imageIdFrameNumber === frameNumber - 1 ? imageId : undefined;\n}\n\n/**\n * getValidOrientations - returns an array of valid orientations.\n *\n * @param  {Number[6]} iop The row (0..2) an column (3..5) direction cosines.\n * @return {Number[8][6]} An array of valid orientations.\n */\nfunction getValidOrientations(iop) {\n    const orientations = [];\n\n    // [0,  1,  2]: 0,   0hf,   0vf\n    // [3,  4,  5]: 90,  90hf,  90vf\n    // [6, 7]:      180, 270\n\n    orientations[0] = iop;\n    orientations[1] = flipIOP.h(iop);\n    orientations[2] = flipIOP.v(iop);\n\n    const iop90 = rotateDirectionCosinesInPlane(iop, Math.PI / 2);\n\n    orientations[3] = iop90;\n    orientations[4] = flipIOP.h(iop90);\n    orientations[5] = flipIOP.v(iop90);\n\n    orientations[6] = rotateDirectionCosinesInPlane(iop, Math.PI);\n    orientations[7] = rotateDirectionCosinesInPlane(iop, 1.5 * Math.PI);\n\n    return orientations;\n}\n\n/**\n * alignPixelDataWithSourceData -\n *\n * @param {Ndarray} pixelData2D - The data to align.\n * @param {Number[6]} iop - The orientation of the image slice.\n * @param {Number[8][6]} orientations - An array of valid imageOrientationPatient values.\n * @param {Number} tolerance.\n * @return {Ndarray} The aligned pixelData.\n */\nfunction alignPixelDataWithSourceData(\n    pixelData2D,\n    iop,\n    orientations,\n    tolerance\n) {\n    if (compareArrays(iop, orientations[0], tolerance)) {\n        return pixelData2D;\n    } else if (compareArrays(iop, orientations[1], tolerance)) {\n        // Flipped vertically.\n\n        // Undo Flip\n        return flipMatrix2D.v(pixelData2D);\n    } else if (compareArrays(iop, orientations[2], tolerance)) {\n        // Flipped horizontally.\n\n        // Unfo flip\n        return flipMatrix2D.h(pixelData2D);\n    } else if (compareArrays(iop, orientations[3], tolerance)) {\n        //Rotated 90 degrees\n\n        // Rotate back\n        return rotateMatrix902D(pixelData2D);\n    } else if (compareArrays(iop, orientations[4], tolerance)) {\n        //Rotated 90 degrees and fliped horizontally.\n\n        // Undo flip and rotate back.\n        return rotateMatrix902D(flipMatrix2D.h(pixelData2D));\n    } else if (compareArrays(iop, orientations[5], tolerance)) {\n        // Rotated 90 degrees and fliped vertically\n\n        // Unfo flip and rotate back.\n        return rotateMatrix902D(flipMatrix2D.v(pixelData2D));\n    } else if (compareArrays(iop, orientations[6], tolerance)) {\n        // Rotated 180 degrees. // TODO -> Do this more effeciently, there is a 1:1 mapping like 90 degree rotation.\n\n        return rotateMatrix902D(rotateMatrix902D(pixelData2D));\n    } else if (compareArrays(iop, orientations[7], tolerance)) {\n        // Rotated 270 degrees\n\n        // Rotate back.\n        return rotateMatrix902D(\n            rotateMatrix902D(rotateMatrix902D(pixelData2D))\n        );\n    }\n}\n\n/**\n * compareArrays - Returns true if array1 and array2 are equal\n * within a tolerance.\n *\n * @param  {Number[]} array1 - An array.\n * @param  {Number[]} array2 - An array.\n * @param {Number} tolerance.\n * @return {Boolean} True if array1 and array2 are equal.\n */\nfunction compareArrays(array1, array2, tolerance) {\n    if (array1.length != array2.length) {\n        return false;\n    }\n\n    for (let i = 0; i < array1.length; ++i) {\n        if (!nearlyEqual(array1[i], array2[i], tolerance)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfunction getSegmentMetadata(multiframe, seriesInstanceUid) {\n    const segmentSequence = multiframe.SegmentSequence;\n    let data = [];\n\n    if (Array.isArray(segmentSequence)) {\n        data = [undefined, ...segmentSequence];\n    } else {\n        // Only one segment, will be stored as an object.\n        data = [undefined, segmentSequence];\n    }\n\n    return {\n        seriesInstanceUid,\n        data\n    };\n}\n\n/**\n * Reads a range of bytes from an array of ArrayBuffer chunks and\n * aggregate them into a new Uint8Array.\n *\n * @param {ArrayBuffer[]} chunks - An array of ArrayBuffer chunks.\n * @param {number} offset - The offset of the first byte to read.\n * @param {number} length - The number of bytes to read.\n * @returns {Uint8Array} A new Uint8Array containing the requested bytes.\n */\nfunction readFromUnpackedChunks(chunks, offset, length) {\n    const mapping = getUnpackedOffsetAndLength(chunks, offset, length);\n\n    // If all the data is in one chunk, we can just slice that chunk\n    if (mapping.start.chunkIndex === mapping.end.chunkIndex) {\n        return new Uint8Array(\n            chunks[mapping.start.chunkIndex].buffer,\n            mapping.start.offset,\n            length\n        );\n    } else {\n        // If the data spans multiple chunks, we need to create a new Uint8Array and copy the data from each chunk\n        let result = new Uint8Array(length);\n        let resultOffset = 0;\n\n        for (\n            let i = mapping.start.chunkIndex;\n            i <= mapping.end.chunkIndex;\n            i++\n        ) {\n            let start =\n                i === mapping.start.chunkIndex ? mapping.start.offset : 0;\n            let end =\n                i === mapping.end.chunkIndex\n                    ? mapping.end.offset\n                    : chunks[i].length;\n\n            result.set(\n                new Uint8Array(chunks[i].buffer, start, end - start),\n                resultOffset\n            );\n            resultOffset += end - start;\n        }\n\n        return result;\n    }\n}\n\nfunction getUnpackedOffsetAndLength(chunks, offset, length) {\n    var totalBytes = chunks.reduce((total, chunk) => total + chunk.length, 0);\n\n    if (offset < 0 || offset + length > totalBytes) {\n        throw new Error(\"Offset and length out of bounds\");\n    }\n\n    var startChunkIndex = 0;\n    var startOffsetInChunk = offset;\n\n    while (startOffsetInChunk >= chunks[startChunkIndex].length) {\n        startOffsetInChunk -= chunks[startChunkIndex].length;\n        startChunkIndex++;\n    }\n\n    var endChunkIndex = startChunkIndex;\n    var endOffsetInChunk = startOffsetInChunk + length;\n\n    while (endOffsetInChunk > chunks[endChunkIndex].length) {\n        endOffsetInChunk -= chunks[endChunkIndex].length;\n        endChunkIndex++;\n    }\n\n    return {\n        start: { chunkIndex: startChunkIndex, offset: startOffsetInChunk },\n        end: { chunkIndex: endChunkIndex, offset: endOffsetInChunk }\n    };\n}\n\nfunction calculateCentroid(imageIdIndexBufferIndex, multiframe) {\n    let xAcc = 0;\n    let yAcc = 0;\n    let zAcc = 0;\n    let count = 0;\n\n    for (const [imageIdIndex, bufferIndices] of Object.entries(\n        imageIdIndexBufferIndex\n    )) {\n        const z = Number(imageIdIndex);\n\n        if (!bufferIndices || bufferIndices.length === 0) {\n            continue;\n        }\n\n        for (const bufferIndex of bufferIndices) {\n            const y = Math.floor(bufferIndex / multiframe.Rows);\n            const x = bufferIndex % multiframe.Rows;\n\n            xAcc += x;\n            yAcc += y;\n            zAcc += z;\n\n            count++;\n        }\n    }\n\n    return { xAcc, yAcc, zAcc, count };\n}\n\nconst Segmentation = {\n    generateSegmentation,\n    generateToolState,\n    fillSegmentation\n};\n\nexport default Segmentation;\nexport { fillSegmentation, generateSegmentation, generateToolState };\n","import MeasurementReport from \"./MeasurementReport\";\nimport Length from \"./Length\";\nimport FreehandRoi from \"./FreehandRoi\";\nimport Bidirectional from \"./Bidirectional\";\nimport EllipticalRoi from \"./EllipticalRoi\";\nimport CircleRoi from \"./CircleRoi\";\nimport ArrowAnnotate from \"./ArrowAnnotate\";\nimport CobbAngle from \"./CobbAngle\";\nimport Angle from \"./Angle\";\nimport RectangleRoi from \"./RectangleRoi\";\n// Segmentation\nimport Segmentation from \"./Segmentation\";\n\nconst CornerstoneSR = {\n    Length,\n    FreehandRoi,\n    Bidirectional,\n    EllipticalRoi,\n    CircleRoi,\n    ArrowAnnotate,\n    MeasurementReport,\n    CobbAngle,\n    Angle,\n    RectangleRoi\n};\n\nconst CornerstoneSEG = {\n    Segmentation\n};\n\nexport { CornerstoneSR, CornerstoneSEG };\n","import Segmentation_3X from \"./Segmentation_3X\";\nimport Segmentation_4X from \"./Segmentation_4X\";\n\nconst Segmentation = {\n    generateSegmentation,\n    generateToolState,\n    fillSegmentation\n};\n\nexport default Segmentation;\n\n/**\n * generateSegmentation - Generates a DICOM Segmentation object given cornerstoneTools data.\n *\n * @param  {object[]} images    An array of the cornerstone image objects.\n * @param  {Object|Object[]} labelmaps3DorBrushData For 4.X: The cornerstone `Labelmap3D` object, or an array of objects.\n *                                                  For 3.X: the BrushData.\n * @param  {number} cornerstoneToolsVersion The cornerstoneTools major version to map against.\n * @returns {Object}\n */\nfunction generateSegmentation(\n    images,\n    labelmaps3DorBrushData,\n    options = { includeSliceSpacing: true },\n    cornerstoneToolsVersion = 4\n) {\n    if (cornerstoneToolsVersion === 4) {\n        return Segmentation_4X.generateSegmentation(\n            images,\n            labelmaps3DorBrushData,\n            options\n        );\n    }\n\n    if (cornerstoneToolsVersion === 3) {\n        return Segmentation_3X.generateSegmentation(\n            images,\n            labelmaps3DorBrushData,\n            options\n        );\n    }\n\n    console.warn(\n        `No generateSegmentation adapater for cornerstone version ${cornerstoneToolsVersion}, exiting.`\n    );\n}\n\n/**\n * generateToolState - Given a set of cornrstoneTools imageIds and a Segmentation buffer,\n * derive cornerstoneTools toolState and brush metadata.\n *\n * @param  {string[]} imageIds    An array of the imageIds.\n * @param  {ArrayBuffer} arrayBuffer The SEG arrayBuffer.\n * @param {*} metadataProvider\n * @param  {bool} skipOverlapping - skip checks for overlapping segs, default value false.\n * @param  {number} tolerance - default value 1.e-3.\n * @param  {number} cornerstoneToolsVersion - default value 4.\n *\n * @returns {Object}  The toolState and an object from which the\n *                    segment metadata can be derived.\n */\nfunction generateToolState(\n    imageIds,\n    arrayBuffer,\n    metadataProvider,\n    skipOverlapping = false,\n    tolerance = 1e-3,\n    cornerstoneToolsVersion = 4\n) {\n    if (cornerstoneToolsVersion === 4) {\n        return Segmentation_4X.generateToolState(\n            imageIds,\n            arrayBuffer,\n            metadataProvider,\n            skipOverlapping,\n            tolerance\n        );\n    }\n\n    if (cornerstoneToolsVersion === 3) {\n        return Segmentation_3X.generateToolState(\n            imageIds,\n            arrayBuffer,\n            metadataProvider\n        );\n    }\n\n    console.warn(\n        `No generateToolState adapater for cornerstone version ${cornerstoneToolsVersion}, exiting.`\n    );\n}\n\n/**\n * fillSegmentation - Fills a derived segmentation dataset with cornerstoneTools `LabelMap3D` data.\n *\n * @param  {object[]} segmentation An empty segmentation derived dataset.\n * @param  {Object|Object[]} inputLabelmaps3D The cornerstone `Labelmap3D` object, or an array of objects.\n * @param  {Object} userOptions Options object to override default options.\n * @returns {Blob}           description\n */\nfunction fillSegmentation(\n    segmentation,\n    inputLabelmaps3D,\n    options = { includeSliceSpacing: true },\n    cornerstoneToolsVersion = 4\n) {\n    if (cornerstoneToolsVersion === 4) {\n        return Segmentation_4X.fillSegmentation(\n            segmentation,\n            inputLabelmaps3D,\n            options\n        );\n    }\n\n    console.warn(\n        `No generateSegmentation adapater for cornerstone version ${cornerstoneToolsVersion}, exiting.`\n    );\n}\n","/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.push(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.push(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n","export default \"Cornerstone3DTools@^0.1.0\";\n","// This is a custom coding scheme defined to store some annotations from Cornerstone.\n// Note: CodeMeaning is VR type LO, which means we only actually support 64 characters\n// here this is fine for most labels, but may be problematic at some point.\nconst CORNERSTONEFREETEXT = \"CORNERSTONEFREETEXT\";\n\n// Cornerstone specified coding scheme for storing findings\nconst CodingSchemeDesignator = \"CORNERSTONEJS\";\n\nconst CodingScheme = {\n    CodingSchemeDesignator,\n    codeValues: {\n        CORNERSTONEFREETEXT\n    }\n};\n\nexport default CodingScheme;\n","import { normalizers, data, utilities, derivations } from \"dcmjs\";\n\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\nimport { toArray, codeMeaningEquals } from \"../helpers\";\nimport Cornerstone3DCodingScheme from \"./CodingScheme\";\n\nconst { TID1500, addAccessors } = utilities;\n\nconst { StructuredReport } = derivations;\n\nconst { Normalizer } = normalizers;\n\nconst { TID1500MeasurementReport, TID1501MeasurementGroup } = TID1500;\n\nconst { DicomMetaDictionary } = data;\n\nconst FINDING = { CodingSchemeDesignator: \"DCM\", CodeValue: \"121071\" };\nconst FINDING_SITE = { CodingSchemeDesignator: \"SCT\", CodeValue: \"363698007\" };\nconst FINDING_SITE_OLD = { CodingSchemeDesignator: \"SRT\", CodeValue: \"G-C0E3\" };\n\nconst codeValueMatch = (group, code, oldCode?) => {\n    const { ConceptNameCodeSequence } = group;\n    if (!ConceptNameCodeSequence) return;\n    const { CodingSchemeDesignator, CodeValue } = ConceptNameCodeSequence;\n    return (\n        (CodingSchemeDesignator == code.CodingSchemeDesignator &&\n            CodeValue == code.CodeValue) ||\n        (oldCode &&\n            CodingSchemeDesignator == oldCode.CodingSchemeDesignator &&\n            CodeValue == oldCode.CodeValue)\n    );\n};\n\nfunction getTID300ContentItem(\n    tool,\n    toolType,\n    ReferencedSOPSequence,\n    toolClass,\n    worldToImageCoords\n) {\n    const args = toolClass.getTID300RepresentationArguments(\n        tool,\n        worldToImageCoords\n    );\n    args.ReferencedSOPSequence = ReferencedSOPSequence;\n\n    const TID300Measurement = new toolClass.TID300Representation(args);\n\n    return TID300Measurement;\n}\n\nfunction getMeasurementGroup(\n    toolType,\n    toolData,\n    ReferencedSOPSequence,\n    worldToImageCoords\n) {\n    const toolTypeData = toolData[toolType];\n    const toolClass =\n        MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE[toolType];\n    if (\n        !toolTypeData ||\n        !toolTypeData.data ||\n        !toolTypeData.data.length ||\n        !toolClass\n    ) {\n        return;\n    }\n\n    // Loop through the array of tool instances\n    // for this tool\n    const Measurements = toolTypeData.data.map(tool => {\n        return getTID300ContentItem(\n            tool,\n            toolType,\n            ReferencedSOPSequence,\n            toolClass,\n            worldToImageCoords\n        );\n    });\n\n    return new TID1501MeasurementGroup(Measurements);\n}\n\nexport default class MeasurementReport {\n    public static CORNERSTONE_3D_TAG = CORNERSTONE_3D_TAG;\n    public static MEASUREMENT_BY_TOOLTYPE = {};\n    public static CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE = {};\n    public static CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE = {};\n\n    static getCornerstoneLabelFromDefaultState(defaultState) {\n        const { findingSites = [], finding } = defaultState;\n\n        const cornersoneFreeTextCodingValue =\n            Cornerstone3DCodingScheme.codeValues.CORNERSTONEFREETEXT;\n\n        const freeTextLabel = findingSites.find(\n            fs => fs.CodeValue === cornersoneFreeTextCodingValue\n        );\n\n        if (freeTextLabel) {\n            return freeTextLabel.CodeMeaning;\n        }\n\n        if (finding && finding.CodeValue === cornersoneFreeTextCodingValue) {\n            return finding.CodeMeaning;\n        }\n    }\n\n    static generateDatasetMeta() {\n        // TODO: what is the correct metaheader\n        // http://dicom.nema.org/medical/Dicom/current/output/chtml/part10/chapter_7.html\n        // TODO: move meta creation to happen in derivations.js\n        const fileMetaInformationVersionArray = new Uint8Array(2);\n        fileMetaInformationVersionArray[1] = 1;\n\n        const _meta = {\n            FileMetaInformationVersion: {\n                Value: [fileMetaInformationVersionArray.buffer],\n                vr: \"OB\"\n            },\n            //MediaStorageSOPClassUID\n            //MediaStorageSOPInstanceUID: sopCommonModule.sopInstanceUID,\n            TransferSyntaxUID: {\n                Value: [\"1.2.840.10008.1.2.1\"],\n                vr: \"UI\"\n            },\n            ImplementationClassUID: {\n                Value: [DicomMetaDictionary.uid()], // TODO: could be git hash or other valid id\n                vr: \"UI\"\n            },\n            ImplementationVersionName: {\n                Value: [\"dcmjs\"],\n                vr: \"SH\"\n            }\n        };\n\n        return _meta;\n    }\n\n    static generateDerivationSourceDataset = instance => {\n        const _vrMap = {\n            PixelData: \"OW\"\n        };\n\n        const _meta = MeasurementReport.generateDatasetMeta();\n\n        const derivationSourceDataset = {\n            ...instance,\n            _meta: _meta,\n            _vrMap: _vrMap\n        };\n\n        return derivationSourceDataset;\n    };\n\n    static getSetupMeasurementData(\n        MeasurementGroup,\n        sopInstanceUIDToImageIdMap,\n        metadata,\n        toolType\n    ) {\n        const { ContentSequence } = MeasurementGroup;\n\n        const contentSequenceArr = toArray(ContentSequence);\n        const findingGroup = contentSequenceArr.find(group =>\n            codeValueMatch(group, FINDING)\n        );\n        const findingSiteGroups =\n            contentSequenceArr.filter(group =>\n                codeValueMatch(group, FINDING_SITE, FINDING_SITE_OLD)\n            ) || [];\n        const NUMGroup = contentSequenceArr.find(\n            group => group.ValueType === \"NUM\"\n        );\n        const SCOORDGroup = toArray(NUMGroup.ContentSequence).find(\n            group => group.ValueType === \"SCOORD\"\n        );\n        const { ReferencedSOPSequence } = SCOORDGroup.ContentSequence;\n        const { ReferencedSOPInstanceUID, ReferencedFrameNumber } =\n            ReferencedSOPSequence;\n\n        const referencedImageId =\n            sopInstanceUIDToImageIdMap[ReferencedSOPInstanceUID];\n        const imagePlaneModule = metadata.get(\n            \"imagePlaneModule\",\n            referencedImageId\n        );\n\n        const finding = findingGroup\n            ? addAccessors(findingGroup.ConceptCodeSequence)\n            : undefined;\n        const findingSites = findingSiteGroups.map(fsg => {\n            return addAccessors(fsg.ConceptCodeSequence);\n        });\n\n        const defaultState = {\n            description: undefined,\n            sopInstanceUid: ReferencedSOPInstanceUID,\n            annotation: {\n                annotationUID: DicomMetaDictionary.uid(),\n                metadata: {\n                    toolName: toolType,\n                    referencedImageId,\n                    FrameOfReferenceUID: imagePlaneModule.frameOfReferenceUID,\n                    label: \"\"\n                },\n                data: undefined\n            },\n            finding,\n            findingSites\n        };\n        if (defaultState.finding) {\n            defaultState.description = defaultState.finding.CodeMeaning;\n        }\n\n        defaultState.annotation.metadata.label =\n            MeasurementReport.getCornerstoneLabelFromDefaultState(defaultState);\n\n        return {\n            defaultState,\n            NUMGroup,\n            SCOORDGroup,\n            ReferencedSOPSequence,\n            ReferencedSOPInstanceUID,\n            ReferencedFrameNumber\n        };\n    }\n\n    static generateReport(\n        toolState,\n        metadataProvider,\n        worldToImageCoords,\n        options\n    ) {\n        // ToolState for array of imageIDs to a Report\n        // Assume Cornerstone metadata provider has access to Study / Series / Sop Instance UID\n        let allMeasurementGroups = [];\n\n        /* Patient ID\n        Warning - Missing attribute or value that would be needed to build DICOMDIR - Patient ID\n        Warning - Missing attribute or value that would be needed to build DICOMDIR - Study Date\n        Warning - Missing attribute or value that would be needed to build DICOMDIR - Study Time\n        Warning - Missing attribute or value that would be needed to build DICOMDIR - Study ID\n        */\n\n        const sopInstanceUIDsToSeriesInstanceUIDMap = {};\n        const derivationSourceDatasets = [];\n\n        const _meta = MeasurementReport.generateDatasetMeta();\n\n        // Loop through each image in the toolData\n        Object.keys(toolState).forEach(imageId => {\n            const sopCommonModule = metadataProvider.get(\n                \"sopCommonModule\",\n                imageId\n            );\n            const instance = metadataProvider.get(\"instance\", imageId);\n\n            const { sopInstanceUID, sopClassUID } = sopCommonModule;\n            const { SeriesInstanceUID: seriesInstanceUID } = instance;\n\n            sopInstanceUIDsToSeriesInstanceUIDMap[sopInstanceUID] =\n                seriesInstanceUID;\n\n            if (\n                !derivationSourceDatasets.find(\n                    dsd => dsd.SeriesInstanceUID === seriesInstanceUID\n                )\n            ) {\n                // Entry not present for series, create one.\n                const derivationSourceDataset =\n                    MeasurementReport.generateDerivationSourceDataset(instance);\n\n                derivationSourceDatasets.push(derivationSourceDataset);\n            }\n\n            const frameNumber = metadataProvider.get(\"frameNumber\", imageId);\n            const toolData = toolState[imageId];\n            const toolTypes = Object.keys(toolData);\n\n            const ReferencedSOPSequence = {\n                ReferencedSOPClassUID: sopClassUID,\n                ReferencedSOPInstanceUID: sopInstanceUID,\n                ReferencedFrameNumber: undefined\n            };\n\n            if (\n                (instance &&\n                    instance.NumberOfFrames &&\n                    instance.NumberOfFrames > 1) ||\n                Normalizer.isMultiframeSOPClassUID(sopClassUID)\n            ) {\n                ReferencedSOPSequence.ReferencedFrameNumber = frameNumber;\n            }\n\n            // Loop through each tool type for the image\n            const measurementGroups = [];\n\n            toolTypes.forEach(toolType => {\n                const group = getMeasurementGroup(\n                    toolType,\n                    toolData,\n                    ReferencedSOPSequence,\n                    worldToImageCoords\n                );\n                if (group) {\n                    measurementGroups.push(group);\n                }\n            });\n\n            allMeasurementGroups =\n                allMeasurementGroups.concat(measurementGroups);\n        });\n\n        const tid1500MeasurementReport = new TID1500MeasurementReport(\n            { TID1501MeasurementGroups: allMeasurementGroups },\n            options\n        );\n\n        const report = new StructuredReport(derivationSourceDatasets, options);\n\n        const contentItem = tid1500MeasurementReport.contentItem(\n            derivationSourceDatasets,\n            { ...options, sopInstanceUIDsToSeriesInstanceUIDMap }\n        );\n\n        // Merge the derived dataset with the content from the Measurement Report\n        report.dataset = Object.assign(report.dataset, contentItem);\n        report.dataset._meta = _meta;\n\n        return report;\n    }\n\n    /**\n     * Generate Cornerstone tool state from dataset\n     */\n    static generateToolState(\n        dataset,\n        sopInstanceUIDToImageIdMap,\n        imageToWorldCoords,\n        metadata,\n        hooks\n    ) {\n        // For now, bail out if the dataset is not a TID1500 SR with length measurements\n        if (dataset.ContentTemplateSequence.TemplateIdentifier !== \"1500\") {\n            throw new Error(\n                \"This package can currently only interpret DICOM SR TID 1500\"\n            );\n        }\n\n        const REPORT = \"Imaging Measurements\";\n        const GROUP = \"Measurement Group\";\n        const TRACKING_IDENTIFIER = \"Tracking Identifier\";\n\n        // Identify the Imaging Measurements\n        const imagingMeasurementContent = toArray(dataset.ContentSequence).find(\n            codeMeaningEquals(REPORT)\n        );\n\n        // Retrieve the Measurements themselves\n        const measurementGroups = toArray(\n            imagingMeasurementContent.ContentSequence\n        ).filter(codeMeaningEquals(GROUP));\n\n        // For each of the supported measurement types, compute the measurement data\n        const measurementData = {};\n\n        const cornerstoneToolClasses =\n            MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE;\n\n        const registeredToolClasses = [];\n\n        Object.keys(cornerstoneToolClasses).forEach(key => {\n            registeredToolClasses.push(cornerstoneToolClasses[key]);\n            measurementData[key] = [];\n        });\n\n        measurementGroups.forEach(measurementGroup => {\n            try {\n                const measurementGroupContentSequence = toArray(\n                    measurementGroup.ContentSequence\n                );\n\n                const TrackingIdentifierGroup =\n                    measurementGroupContentSequence.find(\n                        contentItem =>\n                            contentItem.ConceptNameCodeSequence.CodeMeaning ===\n                            TRACKING_IDENTIFIER\n                    );\n\n                const TrackingIdentifierValue =\n                    TrackingIdentifierGroup.TextValue;\n\n                const toolClass =\n                    hooks?.getToolClass?.(\n                        measurementGroup,\n                        dataset,\n                        registeredToolClasses\n                    ) ||\n                    registeredToolClasses.find(tc =>\n                        tc.isValidCornerstoneTrackingIdentifier(\n                            TrackingIdentifierValue\n                        )\n                    );\n\n                if (toolClass) {\n                    const measurement = toolClass.getMeasurementData(\n                        measurementGroup,\n                        sopInstanceUIDToImageIdMap,\n                        imageToWorldCoords,\n                        metadata\n                    );\n\n                    console.log(`=== ${toolClass.toolType} ===`);\n                    console.log(measurement);\n\n                    measurementData[toolClass.toolType].push(measurement);\n                }\n            } catch (e) {\n                console.warn(\n                    \"Unable to generate tool state for\",\n                    measurementGroup,\n                    e\n                );\n            }\n        });\n\n        // NOTE: There is no way of knowing the cornerstone imageIds as that could be anything.\n        // That is up to the consumer to derive from the SOPInstanceUIDs.\n        return measurementData;\n    }\n\n    /**\n     * Register a new tool type.\n     * @param toolClass to perform I/O to DICOM for this tool\n     */\n    public static registerTool(toolClass) {\n        MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE[\n            toolClass.utilityToolType\n        ] = toolClass;\n        MeasurementReport.CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE[\n            toolClass.toolType\n        ] = toolClass;\n        MeasurementReport.MEASUREMENT_BY_TOOLTYPE[toolClass.toolType] =\n            toolClass.utilityToolType;\n    }\n}\n","import MeasurementReport from \"./MeasurementReport\";\nimport { utilities } from \"dcmjs\";\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\nimport CodingScheme from \"./CodingScheme\";\n\nconst { Point: TID300Point } = utilities.TID300;\n\nconst ARROW_ANNOTATE = \"ArrowAnnotate\";\nconst trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${ARROW_ANNOTATE}`;\n\nconst { codeValues, CodingSchemeDesignator } = CodingScheme;\n\nclass ArrowAnnotate {\n    static getMeasurementData(\n        MeasurementGroup,\n        sopInstanceUIDToImageIdMap,\n        imageToWorldCoords,\n        metadata\n    ) {\n        const { defaultState, SCOORDGroup, ReferencedFrameNumber } =\n            MeasurementReport.getSetupMeasurementData(\n                MeasurementGroup,\n                sopInstanceUIDToImageIdMap,\n                metadata,\n                ArrowAnnotate.toolType\n            );\n\n        const referencedImageId =\n            defaultState.annotation.metadata.referencedImageId;\n\n        const text = defaultState.annotation.metadata.label;\n\n        const { GraphicData } = SCOORDGroup;\n\n        const worldCoords = [];\n        for (let i = 0; i < GraphicData.length; i += 2) {\n            const point = imageToWorldCoords(referencedImageId, [\n                GraphicData[i],\n                GraphicData[i + 1]\n            ]);\n            worldCoords.push(point);\n        }\n\n        // Since the arrowAnnotate measurement is just a point, to generate the tool state\n        // we derive the second point based on the image size relative to the first point.\n        if (worldCoords.length === 1) {\n            const imagePixelModule = metadata.get(\n                \"imagePixelModule\",\n                referencedImageId\n            );\n\n            let xOffset = 10;\n            let yOffset = 10;\n\n            if (imagePixelModule) {\n                const { columns, rows } = imagePixelModule;\n                xOffset = columns / 10;\n                yOffset = rows / 10;\n            }\n\n            const secondPoint = imageToWorldCoords(referencedImageId, [\n                GraphicData[0] + xOffset,\n                GraphicData[1] + yOffset\n            ]);\n\n            worldCoords.push(secondPoint);\n        }\n\n        const state = defaultState;\n\n        state.annotation.data = {\n            text,\n            handles: {\n                arrowFirst: true,\n                points: [worldCoords[0], worldCoords[1]],\n                activeHandleIndex: 0,\n                textBox: {\n                    hasMoved: false\n                }\n            },\n            frameNumber: ReferencedFrameNumber\n        };\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool, worldToImageCoords) {\n        const { data, metadata } = tool;\n        let { finding, findingSites } = tool;\n        const { referencedImageId } = metadata;\n\n        if (!referencedImageId) {\n            throw new Error(\n                \"ArrowAnnotate.getTID300RepresentationArguments: referencedImageId is not defined\"\n            );\n        }\n\n        const { points, arrowFirst } = data.handles;\n\n        let point;\n\n        if (arrowFirst) {\n            point = points[0];\n        } else {\n            point = points[1];\n        }\n\n        const pointImage = worldToImageCoords(referencedImageId, point);\n\n        const TID300RepresentationArguments = {\n            points: [\n                {\n                    x: pointImage[0],\n                    y: pointImage[1]\n                }\n            ],\n            trackingIdentifierTextValue,\n            findingSites: findingSites || []\n        };\n\n        // If freetext finding isn't present, add it from the tool text.\n        if (!finding || finding.CodeValue !== codeValues.CORNERSTONEFREETEXT) {\n            finding = {\n                CodeValue: codeValues.CORNERSTONEFREETEXT,\n                CodingSchemeDesignator,\n                CodeMeaning: data.text\n            };\n        }\n\n        TID300RepresentationArguments.finding = finding;\n\n        return TID300RepresentationArguments;\n    }\n}\n\nArrowAnnotate.toolType = ARROW_ANNOTATE;\nArrowAnnotate.utilityToolType = ARROW_ANNOTATE;\nArrowAnnotate.TID300Representation = TID300Point;\nArrowAnnotate.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n    if (!TrackingIdentifier.includes(\":\")) {\n        return false;\n    }\n\n    const [cornerstone3DTag, toolType] = TrackingIdentifier.split(\":\");\n\n    if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\n        return false;\n    }\n\n    return toolType === ARROW_ANNOTATE;\n};\n\nMeasurementReport.registerTool(ArrowAnnotate);\n\nexport default ArrowAnnotate;\n","import { utilities } from \"dcmjs\";\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\nimport MeasurementReport from \"./MeasurementReport\";\nimport { toArray } from \"../helpers\";\n\nconst { Bidirectional: TID300Bidirectional } = utilities.TID300;\n\nconst BIDIRECTIONAL = \"Bidirectional\";\nconst LONG_AXIS = \"Long Axis\";\nconst SHORT_AXIS = \"Short Axis\";\nconst trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${BIDIRECTIONAL}`;\n\nclass Bidirectional {\n    public static toolType = BIDIRECTIONAL;\n    public static utilityToolType = BIDIRECTIONAL;\n    public static TID300Representation = TID300Bidirectional;\n    public static isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n        if (!TrackingIdentifier.includes(\":\")) {\n            return false;\n        }\n\n        const [cornerstone3DTag, toolType] = TrackingIdentifier.split(\":\");\n\n        if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\n            return false;\n        }\n\n        return toolType === BIDIRECTIONAL;\n    };\n\n    public static getMeasurementData(\n        MeasurementGroup,\n        sopInstanceUIDToImageIdMap,\n        imageToWorldCoords,\n        metadata\n    ) {\n        const { defaultState, ReferencedFrameNumber } =\n            MeasurementReport.getSetupMeasurementData(\n                MeasurementGroup,\n                sopInstanceUIDToImageIdMap,\n                metadata,\n                Bidirectional.toolType\n            );\n\n        const referencedImageId =\n            defaultState.annotation.metadata.referencedImageId;\n        const { ContentSequence } = MeasurementGroup;\n\n        const longAxisNUMGroup = toArray(ContentSequence).find(\n            group => group.ConceptNameCodeSequence.CodeMeaning === LONG_AXIS\n        );\n\n        const longAxisSCOORDGroup = toArray(\n            longAxisNUMGroup.ContentSequence\n        ).find(group => group.ValueType === \"SCOORD\");\n\n        const shortAxisNUMGroup = toArray(ContentSequence).find(\n            group => group.ConceptNameCodeSequence.CodeMeaning === SHORT_AXIS\n        );\n\n        const shortAxisSCOORDGroup = toArray(\n            shortAxisNUMGroup.ContentSequence\n        ).find(group => group.ValueType === \"SCOORD\");\n\n        const worldCoords = [];\n\n        [longAxisSCOORDGroup, shortAxisSCOORDGroup].forEach(group => {\n            const { GraphicData } = group;\n            for (let i = 0; i < GraphicData.length; i += 2) {\n                const point = imageToWorldCoords(referencedImageId, [\n                    GraphicData[i],\n                    GraphicData[i + 1]\n                ]);\n                worldCoords.push(point);\n            }\n        });\n\n        const state = defaultState;\n\n        state.annotation.data = {\n            handles: {\n                points: [\n                    worldCoords[0],\n                    worldCoords[1],\n                    worldCoords[2],\n                    worldCoords[3]\n                ],\n                activeHandleIndex: 0,\n                textBox: {\n                    hasMoved: false\n                }\n            },\n            cachedStats: {\n                [`imageId:${referencedImageId}`]: {\n                    length: longAxisNUMGroup.MeasuredValueSequence.NumericValue,\n                    width: shortAxisNUMGroup.MeasuredValueSequence.NumericValue\n                }\n            },\n            frameNumber: ReferencedFrameNumber\n        };\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool, worldToImageCoords) {\n        const { data, finding, findingSites, metadata } = tool;\n        const { cachedStats = {}, handles } = data;\n\n        const { referencedImageId } = metadata;\n\n        if (!referencedImageId) {\n            throw new Error(\n                \"Bidirectional.getTID300RepresentationArguments: referencedImageId is not defined\"\n            );\n        }\n\n        const { length, width } =\n            cachedStats[`imageId:${referencedImageId}`] || {};\n        const { points } = handles;\n\n        // Find the length and width point pairs by comparing the distances of the points at 0,1 to points at 2,3\n        const firstPointPairs = [points[0], points[1]];\n        const secondPointPairs = [points[2], points[3]];\n\n        const firstPointPairsDistance = Math.sqrt(\n            Math.pow(firstPointPairs[0][0] - firstPointPairs[1][0], 2) +\n                Math.pow(firstPointPairs[0][1] - firstPointPairs[1][1], 2) +\n                Math.pow(firstPointPairs[0][2] - firstPointPairs[1][2], 2)\n        );\n\n        const secondPointPairsDistance = Math.sqrt(\n            Math.pow(secondPointPairs[0][0] - secondPointPairs[1][0], 2) +\n                Math.pow(secondPointPairs[0][1] - secondPointPairs[1][1], 2) +\n                Math.pow(secondPointPairs[0][2] - secondPointPairs[1][2], 2)\n        );\n\n        let shortAxisPoints;\n        let longAxisPoints;\n        if (firstPointPairsDistance > secondPointPairsDistance) {\n            shortAxisPoints = firstPointPairs;\n            longAxisPoints = secondPointPairs;\n        } else {\n            shortAxisPoints = secondPointPairs;\n            longAxisPoints = firstPointPairs;\n        }\n\n        const longAxisStartImage = worldToImageCoords(\n            referencedImageId,\n            shortAxisPoints[0]\n        );\n        const longAxisEndImage = worldToImageCoords(\n            referencedImageId,\n            shortAxisPoints[1]\n        );\n        const shortAxisStartImage = worldToImageCoords(\n            referencedImageId,\n            longAxisPoints[0]\n        );\n        const shortAxisEndImage = worldToImageCoords(\n            referencedImageId,\n            longAxisPoints[1]\n        );\n\n        return {\n            longAxis: {\n                point1: {\n                    x: longAxisStartImage[0],\n                    y: longAxisStartImage[1]\n                },\n                point2: {\n                    x: longAxisEndImage[0],\n                    y: longAxisEndImage[1]\n                }\n            },\n            shortAxis: {\n                point1: {\n                    x: shortAxisStartImage[0],\n                    y: shortAxisStartImage[1]\n                },\n                point2: {\n                    x: shortAxisEndImage[0],\n                    y: shortAxisEndImage[1]\n                }\n            },\n            longAxisLength: length,\n            shortAxisLength: width,\n            trackingIdentifierTextValue,\n            finding: finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nMeasurementReport.registerTool(Bidirectional);\n\nexport default Bidirectional;\n","import { utilities } from \"dcmjs\";\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\nimport MeasurementReport from \"./MeasurementReport\";\n\nconst { CobbAngle: TID300CobbAngle } = utilities.TID300;\n\nconst MEASUREMENT_TYPE = \"Angle\";\nconst trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${MEASUREMENT_TYPE}`;\n\nclass Angle {\n    public static toolType = MEASUREMENT_TYPE;\n    public static utilityToolType = MEASUREMENT_TYPE;\n    public static TID300Representation = TID300CobbAngle;\n    public static isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n        if (!TrackingIdentifier.includes(\":\")) {\n            return false;\n        }\n\n        const [cornerstone3DTag, toolType] = TrackingIdentifier.split(\":\");\n\n        if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\n            return false;\n        }\n\n        return toolType === MEASUREMENT_TYPE;\n    };\n\n    // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n    public static getMeasurementData(\n        MeasurementGroup,\n        sopInstanceUIDToImageIdMap,\n        imageToWorldCoords,\n        metadata\n    ) {\n        const { defaultState, NUMGroup, SCOORDGroup, ReferencedFrameNumber } =\n            MeasurementReport.getSetupMeasurementData(\n                MeasurementGroup,\n                sopInstanceUIDToImageIdMap,\n                metadata,\n                Angle.toolType\n            );\n\n        const referencedImageId =\n            defaultState.annotation.metadata.referencedImageId;\n\n        const { GraphicData } = SCOORDGroup;\n        const worldCoords = [];\n        for (let i = 0; i < GraphicData.length; i += 2) {\n            const point = imageToWorldCoords(referencedImageId, [\n                GraphicData[i],\n                GraphicData[i + 1]\n            ]);\n            worldCoords.push(point);\n        }\n\n        const state = defaultState;\n\n        state.annotation.data = {\n            handles: {\n                points: [worldCoords[0], worldCoords[1], worldCoords[3]],\n                activeHandleIndex: 0,\n                textBox: {\n                    hasMoved: false\n                }\n            },\n            cachedStats: {\n                [`imageId:${referencedImageId}`]: {\n                    angle: NUMGroup\n                        ? NUMGroup.MeasuredValueSequence.NumericValue\n                        : null\n                }\n            },\n            frameNumber: ReferencedFrameNumber\n        };\n\n        return state;\n    }\n\n    public static getTID300RepresentationArguments(tool, worldToImageCoords) {\n        const { data, finding, findingSites, metadata } = tool;\n        const { cachedStats = {}, handles } = data;\n\n        const { referencedImageId } = metadata;\n\n        if (!referencedImageId) {\n            throw new Error(\n                \"Angle.getTID300RepresentationArguments: referencedImageId is not defined\"\n            );\n        }\n\n        const start1 = worldToImageCoords(referencedImageId, handles.points[0]);\n        const middle = worldToImageCoords(referencedImageId, handles.points[1]);\n\n        const end = worldToImageCoords(referencedImageId, handles.points[2]);\n\n        const point1 = { x: start1[0], y: start1[1] };\n        const point2 = { x: middle[0], y: middle[1] };\n        const point3 = point2;\n        const point4 = { x: end[0], y: end[1] };\n\n        const { angle } = cachedStats[`imageId:${referencedImageId}`] || {};\n\n        // Represented as a cobb angle\n        return {\n            point1,\n            point2,\n            point3,\n            point4,\n            rAngle: angle,\n            trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nMeasurementReport.registerTool(Angle);\n\nexport default Angle;\n","import { utilities } from \"dcmjs\";\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\nimport MeasurementReport from \"./MeasurementReport\";\n\nconst { CobbAngle: TID300CobbAngle } = utilities.TID300;\n\nconst MEASUREMENT_TYPE = \"CobbAngle\";\nconst trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${MEASUREMENT_TYPE}`;\n\nclass CobbAngle {\n    public static toolType = MEASUREMENT_TYPE;\n    public static utilityToolType = MEASUREMENT_TYPE;\n    public static TID300Representation = TID300CobbAngle;\n    public static isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n        if (!TrackingIdentifier.includes(\":\")) {\n            return false;\n        }\n\n        const [cornerstone3DTag, toolType] = TrackingIdentifier.split(\":\");\n\n        if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\n            return false;\n        }\n\n        return toolType === MEASUREMENT_TYPE;\n    };\n\n    // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n    public static getMeasurementData(\n        MeasurementGroup,\n        sopInstanceUIDToImageIdMap,\n        imageToWorldCoords,\n        metadata\n    ) {\n        const { defaultState, NUMGroup, SCOORDGroup, ReferencedFrameNumber } =\n            MeasurementReport.getSetupMeasurementData(\n                MeasurementGroup,\n                sopInstanceUIDToImageIdMap,\n                metadata,\n                CobbAngle.toolType\n            );\n\n        const referencedImageId =\n            defaultState.annotation.metadata.referencedImageId;\n\n        const { GraphicData } = SCOORDGroup;\n        const worldCoords = [];\n        for (let i = 0; i < GraphicData.length; i += 2) {\n            const point = imageToWorldCoords(referencedImageId, [\n                GraphicData[i],\n                GraphicData[i + 1]\n            ]);\n            worldCoords.push(point);\n        }\n\n        const state = defaultState;\n\n        state.annotation.data = {\n            handles: {\n                points: [\n                    worldCoords[0],\n                    worldCoords[1],\n                    worldCoords[2],\n                    worldCoords[3]\n                ],\n                activeHandleIndex: 0,\n                textBox: {\n                    hasMoved: false\n                }\n            },\n            cachedStats: {\n                [`imageId:${referencedImageId}`]: {\n                    angle: NUMGroup\n                        ? NUMGroup.MeasuredValueSequence.NumericValue\n                        : null\n                }\n            },\n            frameNumber: ReferencedFrameNumber\n        };\n\n        return state;\n    }\n\n    public static getTID300RepresentationArguments(tool, worldToImageCoords) {\n        const { data, finding, findingSites, metadata } = tool;\n        const { cachedStats = {}, handles } = data;\n\n        const { referencedImageId } = metadata;\n\n        if (!referencedImageId) {\n            throw new Error(\n                \"CobbAngle.getTID300RepresentationArguments: referencedImageId is not defined\"\n            );\n        }\n\n        const start1 = worldToImageCoords(referencedImageId, handles.points[0]);\n        const end1 = worldToImageCoords(referencedImageId, handles.points[1]);\n\n        const start2 = worldToImageCoords(referencedImageId, handles.points[2]);\n        const end2 = worldToImageCoords(referencedImageId, handles.points[3]);\n\n        const point1 = { x: start1[0], y: start1[1] };\n        const point2 = { x: end1[0], y: end1[1] };\n        const point3 = { x: start2[0], y: start2[1] };\n        const point4 = { x: end2[0], y: end2[1] };\n\n        const { angle } = cachedStats[`imageId:${referencedImageId}`] || {};\n\n        return {\n            point1,\n            point2,\n            point3,\n            point4,\n            rAngle: angle,\n            trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nMeasurementReport.registerTool(CobbAngle);\n\nexport default CobbAngle;\n","import CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\n\nexport default function isValidCornerstoneTrackingIdentifier(\n    trackingIdentifier: string\n): boolean {\n    if (!trackingIdentifier.includes(\":\")) {\n        return false;\n    }\n\n    const [cornerstone3DTag, toolType] = trackingIdentifier.split(\":\");\n\n    if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\n        return false;\n    }\n\n    // The following is needed since the new cornerstone3D has changed\n    // case names such as EllipticalRoi to EllipticalROI\n    return toolType.toLowerCase() === this.toolType.toLowerCase();\n}\n","import { utilities } from \"dcmjs\";\nimport MeasurementReport from \"./MeasurementReport\";\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\nimport isValidCornerstoneTrackingIdentifier from \"./isValidCornerstoneTrackingIdentifier\";\n\nconst { Circle: TID300Circle } = utilities.TID300;\n\nconst CIRCLEROI = \"CircleROI\";\n\nclass CircleROI {\n    static trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${CIRCLEROI}`;\n    static toolType = CIRCLEROI;\n    static utilityToolType = CIRCLEROI;\n    static TID300Representation = TID300Circle;\n    static isValidCornerstoneTrackingIdentifier =\n        isValidCornerstoneTrackingIdentifier;\n\n    /** Gets the measurement data for cornerstone, given DICOM SR measurement data. */\n    static getMeasurementData(\n        MeasurementGroup,\n        sopInstanceUIDToImageIdMap,\n        imageToWorldCoords,\n        metadata\n    ) {\n        const { defaultState, NUMGroup, SCOORDGroup, ReferencedFrameNumber } =\n            MeasurementReport.getSetupMeasurementData(\n                MeasurementGroup,\n                sopInstanceUIDToImageIdMap,\n                metadata,\n                CircleROI.toolType\n            );\n\n        const referencedImageId =\n            defaultState.annotation.metadata.referencedImageId;\n\n        const { GraphicData } = SCOORDGroup;\n\n        // GraphicData is ordered as [centerX, centerY, endX, endY]\n        const pointsWorld = [];\n        for (let i = 0; i < GraphicData.length; i += 2) {\n            const worldPos = imageToWorldCoords(referencedImageId, [\n                GraphicData[i],\n                GraphicData[i + 1]\n            ]);\n\n            pointsWorld.push(worldPos);\n        }\n\n        const state = defaultState;\n\n        state.annotation.data = {\n            handles: {\n                points: [...pointsWorld],\n                activeHandleIndex: 0,\n                textBox: {\n                    hasMoved: false\n                }\n            },\n            cachedStats: {\n                [`imageId:${referencedImageId}`]: {\n                    area: NUMGroup\n                        ? NUMGroup.MeasuredValueSequence.NumericValue\n                        : 0,\n                    // Dummy values to be updated by cornerstone\n                    radius: 0,\n                    perimeter: 0\n                }\n            },\n            frameNumber: ReferencedFrameNumber\n        };\n\n        return state;\n    }\n\n    /**\n     * Gets the TID 300 representation of a circle, given the cornerstone representation.\n     *\n     * @param {Object} tool\n     * @returns\n     */\n    static getTID300RepresentationArguments(tool, worldToImageCoords) {\n        const { data, finding, findingSites, metadata } = tool;\n        const { cachedStats = {}, handles } = data;\n\n        const { referencedImageId } = metadata;\n\n        if (!referencedImageId) {\n            throw new Error(\n                \"CircleROI.getTID300RepresentationArguments: referencedImageId is not defined\"\n            );\n        }\n\n        const center = worldToImageCoords(referencedImageId, handles.points[0]);\n        const end = worldToImageCoords(referencedImageId, handles.points[1]);\n\n        const points = [];\n        points.push({ x: center[0], y: center[1] });\n        points.push({ x: end[0], y: end[1] });\n\n        const { area, radius } =\n            cachedStats[`imageId:${referencedImageId}`] || {};\n        const perimeter = 2 * Math.PI * radius;\n\n        return {\n            area,\n            perimeter,\n            radius,\n            points,\n            trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nMeasurementReport.registerTool(CircleROI);\n\nexport default CircleROI;\n","import { vec3 } from \"gl-matrix\";\nimport { utilities } from \"dcmjs\";\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\nimport MeasurementReport from \"./MeasurementReport\";\nimport isValidCornerstoneTrackingIdentifier from \"./isValidCornerstoneTrackingIdentifier\";\n\ntype Point3 = [number, number, number];\n\nconst { Ellipse: TID300Ellipse } = utilities.TID300;\n\nconst ELLIPTICALROI = \"EllipticalROI\";\nconst EPSILON = 1e-4;\n\nclass EllipticalROI {\n    static trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${ELLIPTICALROI}`;\n    static toolType = ELLIPTICALROI;\n    static utilityToolType = ELLIPTICALROI;\n    static TID300Representation = TID300Ellipse;\n    static isValidCornerstoneTrackingIdentifier =\n        isValidCornerstoneTrackingIdentifier;\n\n    static getMeasurementData(\n        MeasurementGroup,\n        sopInstanceUIDToImageIdMap,\n        imageToWorldCoords,\n        metadata\n    ) {\n        const { defaultState, NUMGroup, SCOORDGroup, ReferencedFrameNumber } =\n            MeasurementReport.getSetupMeasurementData(\n                MeasurementGroup,\n                sopInstanceUIDToImageIdMap,\n                metadata,\n                EllipticalROI.toolType\n            );\n\n        const referencedImageId =\n            defaultState.annotation.metadata.referencedImageId;\n\n        const { GraphicData } = SCOORDGroup;\n\n        // GraphicData is ordered as [majorAxisStartX, majorAxisStartY, majorAxisEndX, majorAxisEndY, minorAxisStartX, minorAxisStartY, minorAxisEndX, minorAxisEndY]\n        // But Cornerstone3D points are ordered as top, bottom, left, right for the\n        // ellipse so we need to identify if the majorAxis is horizontal or vertical\n        // in the image plane and then choose the correct points to use for the ellipse.\n        const pointsWorld: Point3[] = [];\n        for (let i = 0; i < GraphicData.length; i += 2) {\n            const worldPos = imageToWorldCoords(referencedImageId, [\n                GraphicData[i],\n                GraphicData[i + 1]\n            ]);\n\n            pointsWorld.push(worldPos);\n        }\n\n        const majorAxisStart = vec3.fromValues(...pointsWorld[0]);\n        const majorAxisEnd = vec3.fromValues(...pointsWorld[1]);\n        const minorAxisStart = vec3.fromValues(...pointsWorld[2]);\n        const minorAxisEnd = vec3.fromValues(...pointsWorld[3]);\n\n        const majorAxisVec = vec3.create();\n        vec3.sub(majorAxisVec, majorAxisEnd, majorAxisStart);\n\n        // normalize majorAxisVec to avoid scaling issues\n        vec3.normalize(majorAxisVec, majorAxisVec);\n\n        const minorAxisVec = vec3.create();\n        vec3.sub(minorAxisVec, minorAxisEnd, minorAxisStart);\n        vec3.normalize(minorAxisVec, minorAxisVec);\n\n        const imagePlaneModule = metadata.get(\n            \"imagePlaneModule\",\n            referencedImageId\n        );\n\n        if (!imagePlaneModule) {\n            throw new Error(\"imageId does not have imagePlaneModule metadata\");\n        }\n\n        const { columnCosines } = imagePlaneModule;\n\n        // find which axis is parallel to the columnCosines\n        const columnCosinesVec = vec3.fromValues(\n            columnCosines[0],\n            columnCosines[1],\n            columnCosines[2]\n        );\n        const projectedMajorAxisOnColVec = vec3.dot(\n            columnCosinesVec,\n            majorAxisVec\n        );\n\n        const projectedMinorAxisOnColVec = vec3.dot(\n            columnCosinesVec,\n            minorAxisVec\n        );\n\n        const absoluteOfMajorDotProduct = Math.abs(projectedMajorAxisOnColVec);\n        const absoluteOfMinorDotProduct = Math.abs(projectedMinorAxisOnColVec);\n\n        let ellipsePoints = [];\n        if (Math.abs(absoluteOfMajorDotProduct - 1) < EPSILON) {\n            ellipsePoints = [\n                pointsWorld[0],\n                pointsWorld[1],\n                pointsWorld[2],\n                pointsWorld[3]\n            ];\n        } else if (Math.abs(absoluteOfMinorDotProduct - 1) < EPSILON) {\n            ellipsePoints = [\n                pointsWorld[2],\n                pointsWorld[3],\n                pointsWorld[0],\n                pointsWorld[1]\n            ];\n        } else {\n            console.warn(\"OBLIQUE ELLIPSE NOT YET SUPPORTED\");\n        }\n\n        const state = defaultState;\n\n        state.annotation.data = {\n            handles: {\n                points: [...ellipsePoints],\n                activeHandleIndex: 0,\n                textBox: {\n                    hasMoved: false\n                }\n            },\n            cachedStats: {\n                [`imageId:${referencedImageId}`]: {\n                    area: NUMGroup\n                        ? NUMGroup.MeasuredValueSequence.NumericValue\n                        : 0\n                }\n            },\n            frameNumber: ReferencedFrameNumber\n        };\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool, worldToImageCoords) {\n        const { data, finding, findingSites, metadata } = tool;\n        const { cachedStats = {}, handles } = data;\n        const rotation = data.initialRotation || 0;\n        const { referencedImageId } = metadata;\n\n        if (!referencedImageId) {\n            throw new Error(\n                \"EllipticalROI.getTID300RepresentationArguments: referencedImageId is not defined\"\n            );\n        }\n        let top, bottom, left, right;\n        // this way when it's restored we can assume the initial rotation is 0.\n        if (rotation == 90 || rotation == 270) {\n            bottom = worldToImageCoords(referencedImageId, handles.points[2]);\n            top = worldToImageCoords(referencedImageId, handles.points[3]);\n            left = worldToImageCoords(referencedImageId, handles.points[0]);\n            right = worldToImageCoords(referencedImageId, handles.points[1]);\n        } else {\n            top = worldToImageCoords(referencedImageId, handles.points[0]);\n            bottom = worldToImageCoords(referencedImageId, handles.points[1]);\n            left = worldToImageCoords(referencedImageId, handles.points[2]);\n            right = worldToImageCoords(referencedImageId, handles.points[3]);\n        }\n\n        // find the major axis and minor axis\n        const topBottomLength = Math.abs(top[1] - bottom[1]);\n        const leftRightLength = Math.abs(left[0] - right[0]);\n\n        const points = [];\n        if (topBottomLength > leftRightLength) {\n            // major axis is bottom to top\n            points.push({ x: top[0], y: top[1] });\n            points.push({ x: bottom[0], y: bottom[1] });\n\n            // minor axis is left to right\n            points.push({ x: left[0], y: left[1] });\n            points.push({ x: right[0], y: right[1] });\n        } else {\n            // major axis is left to right\n            points.push({ x: left[0], y: left[1] });\n            points.push({ x: right[0], y: right[1] });\n\n            // minor axis is bottom to top\n            points.push({ x: top[0], y: top[1] });\n            points.push({ x: bottom[0], y: bottom[1] });\n        }\n\n        const { area } = cachedStats[`imageId:${referencedImageId}`] || {};\n\n        return {\n            area,\n            points,\n            trackingIdentifierTextValue: this.trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nMeasurementReport.registerTool(EllipticalROI);\n\nexport default EllipticalROI;\n","import { utilities } from \"dcmjs\";\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\nimport MeasurementReport from \"./MeasurementReport\";\n\nconst { Polyline: TID300Polyline } = utilities.TID300;\n\nconst TOOLTYPE = \"RectangleROI\";\nconst trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${TOOLTYPE}`;\n\nclass RectangleROI {\n    public static toolType = TOOLTYPE;\n    public static utilityToolType = TOOLTYPE;\n    public static TID300Representation = TID300Polyline;\n\n    public static isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n        if (!TrackingIdentifier.includes(\":\")) {\n            return false;\n        }\n\n        const [cornerstone3DTag, toolType] = TrackingIdentifier.split(\":\");\n\n        if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\n            return false;\n        }\n\n        return toolType === TOOLTYPE;\n    };\n\n    public static getMeasurementData(\n        MeasurementGroup,\n        sopInstanceUIDToImageIdMap,\n        imageToWorldCoords,\n        metadata\n    ) {\n        const { defaultState, NUMGroup, SCOORDGroup, ReferencedFrameNumber } =\n            MeasurementReport.getSetupMeasurementData(\n                MeasurementGroup,\n                sopInstanceUIDToImageIdMap,\n                metadata,\n                RectangleROI.toolType\n            );\n\n        const referencedImageId =\n            defaultState.annotation.metadata.referencedImageId;\n\n        const { GraphicData } = SCOORDGroup;\n        const worldCoords = [];\n        for (let i = 0; i < GraphicData.length; i += 2) {\n            const point = imageToWorldCoords(referencedImageId, [\n                GraphicData[i],\n                GraphicData[i + 1]\n            ]);\n            worldCoords.push(point);\n        }\n\n        const state = defaultState;\n\n        state.annotation.data = {\n            handles: {\n                points: [\n                    worldCoords[0],\n                    worldCoords[1],\n                    worldCoords[3],\n                    worldCoords[2]\n                ],\n                activeHandleIndex: 0,\n                textBox: {\n                    hasMoved: false\n                }\n            },\n            cachedStats: {\n                [`imageId:${referencedImageId}`]: {\n                    area: NUMGroup\n                        ? NUMGroup.MeasuredValueSequence.NumericValue\n                        : null\n                }\n            },\n            frameNumber: ReferencedFrameNumber\n        };\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool, worldToImageCoords) {\n        const { data, finding, findingSites, metadata } = tool;\n        const { cachedStats = {}, handles } = data;\n\n        const { referencedImageId } = metadata;\n\n        if (!referencedImageId) {\n            throw new Error(\n                \"CobbAngle.getTID300RepresentationArguments: referencedImageId is not defined\"\n            );\n        }\n\n        const corners = handles.points.map(point =>\n            worldToImageCoords(referencedImageId, point)\n        );\n\n        const { area, perimeter } = cachedStats;\n\n        return {\n            points: [\n                corners[0],\n                corners[1],\n                corners[3],\n                corners[2],\n                corners[0]\n            ],\n            area,\n            perimeter,\n            trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nMeasurementReport.registerTool(RectangleROI);\n\nexport default RectangleROI;\n","import { utilities } from \"dcmjs\";\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\nimport MeasurementReport from \"./MeasurementReport\";\n\nconst { Length: TID300Length } = utilities.TID300;\n\nconst LENGTH = \"Length\";\nconst trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${LENGTH}`;\n\nclass Length {\n    // TODO: this function is required for all Cornerstone Tool Adapters, since it is called by MeasurementReport.\n    static getMeasurementData(\n        MeasurementGroup,\n        sopInstanceUIDToImageIdMap,\n        imageToWorldCoords,\n        metadata\n    ) {\n        const { defaultState, NUMGroup, SCOORDGroup, ReferencedFrameNumber } =\n            MeasurementReport.getSetupMeasurementData(\n                MeasurementGroup,\n                sopInstanceUIDToImageIdMap,\n                metadata,\n                Length.toolType\n            );\n\n        const referencedImageId =\n            defaultState.annotation.metadata.referencedImageId;\n\n        const { GraphicData } = SCOORDGroup;\n        const worldCoords = [];\n        for (let i = 0; i < GraphicData.length; i += 2) {\n            const point = imageToWorldCoords(referencedImageId, [\n                GraphicData[i],\n                GraphicData[i + 1]\n            ]);\n            worldCoords.push(point);\n        }\n\n        const state = defaultState;\n\n        state.annotation.data = {\n            handles: {\n                points: [worldCoords[0], worldCoords[1]],\n                activeHandleIndex: 0,\n                textBox: {\n                    hasMoved: false\n                }\n            },\n            cachedStats: {\n                [`imageId:${referencedImageId}`]: {\n                    length: NUMGroup\n                        ? NUMGroup.MeasuredValueSequence.NumericValue\n                        : 0\n                }\n            },\n            frameNumber: ReferencedFrameNumber\n        };\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool, worldToImageCoords) {\n        const { data, finding, findingSites, metadata } = tool;\n        const { cachedStats = {}, handles } = data;\n\n        const { referencedImageId } = metadata;\n\n        if (!referencedImageId) {\n            throw new Error(\n                \"Length.getTID300RepresentationArguments: referencedImageId is not defined\"\n            );\n        }\n\n        const start = worldToImageCoords(referencedImageId, handles.points[0]);\n        const end = worldToImageCoords(referencedImageId, handles.points[1]);\n\n        const point1 = { x: start[0], y: start[1] };\n        const point2 = { x: end[0], y: end[1] };\n\n        const { length: distance } =\n            cachedStats[`imageId:${referencedImageId}`] || {};\n\n        return {\n            point1,\n            point2,\n            distance,\n            trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nLength.toolType = LENGTH;\nLength.utilityToolType = LENGTH;\nLength.TID300Representation = TID300Length;\nLength.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n    if (!TrackingIdentifier.includes(\":\")) {\n        return false;\n    }\n\n    const [cornerstone3DTag, toolType] = TrackingIdentifier.split(\":\");\n\n    if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\n        return false;\n    }\n\n    return toolType === LENGTH;\n};\n\nMeasurementReport.registerTool(Length);\n\nexport default Length;\n","import MeasurementReport from \"./MeasurementReport\";\nimport { utilities } from \"dcmjs\";\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\nimport { vec3 } from \"gl-matrix\";\n\nconst { Polyline: TID300Polyline } = utilities.TID300;\n\nconst PLANARFREEHANDROI = \"PlanarFreehandROI\";\nconst trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${PLANARFREEHANDROI}`;\nconst closedContourThreshold = 1e-5;\n\nclass PlanarFreehandROI {\n    public static toolType = PLANARFREEHANDROI;\n    public static utilityToolType = PLANARFREEHANDROI;\n    public static TID300Representation = TID300Polyline;\n    public static isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n        if (!TrackingIdentifier.includes(\":\")) {\n            return false;\n        }\n\n        const [cornerstone3DTag, toolType] = TrackingIdentifier.split(\":\");\n\n        if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\n            return false;\n        }\n\n        return toolType === PLANARFREEHANDROI;\n    };\n\n    static getMeasurementData(\n        MeasurementGroup,\n        sopInstanceUIDToImageIdMap,\n        imageToWorldCoords,\n        metadata\n    ) {\n        const { defaultState, SCOORDGroup, ReferencedFrameNumber } =\n            MeasurementReport.getSetupMeasurementData(\n                MeasurementGroup,\n                sopInstanceUIDToImageIdMap,\n                metadata,\n                PlanarFreehandROI.toolType\n            );\n\n        const referencedImageId =\n            defaultState.annotation.metadata.referencedImageId;\n        const { GraphicData } = SCOORDGroup;\n\n        const worldCoords = [];\n\n        for (let i = 0; i < GraphicData.length; i += 2) {\n            const point = imageToWorldCoords(referencedImageId, [\n                GraphicData[i],\n                GraphicData[i + 1]\n            ]);\n\n            worldCoords.push(point);\n        }\n\n        const distanceBetweenFirstAndLastPoint = vec3.distance(\n            worldCoords[worldCoords.length - 1],\n            worldCoords[0]\n        );\n\n        let isOpenContour = true;\n\n        // If the contour is closed, this should have been encoded as exactly the same point, so check for a very small difference.\n        if (distanceBetweenFirstAndLastPoint < closedContourThreshold) {\n            worldCoords.pop(); // Remove the last element which is duplicated.\n\n            isOpenContour = false;\n        }\n\n        const points = [];\n\n        if (isOpenContour) {\n            points.push(worldCoords[0], worldCoords[worldCoords.length - 1]);\n        }\n\n        const state = defaultState;\n\n        state.annotation.data = {\n            polyline: worldCoords,\n            isOpenContour,\n            handles: {\n                points,\n                activeHandleIndex: null,\n                textBox: {\n                    hasMoved: false\n                }\n            },\n            frameNumber: ReferencedFrameNumber\n        };\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool, worldToImageCoords) {\n        const { data, finding, findingSites, metadata } = tool;\n        const { isOpenContour, polyline } = data;\n\n        const { referencedImageId } = metadata;\n\n        if (!referencedImageId) {\n            throw new Error(\n                \"PlanarFreehandROI.getTID300RepresentationArguments: referencedImageId is not defined\"\n            );\n        }\n\n        const points = polyline.map(worldPos =>\n            worldToImageCoords(referencedImageId, worldPos)\n        );\n\n        if (!isOpenContour) {\n            // Need to repeat the first point at the end of to have an explicitly closed contour.\n            const firstPoint = points[0];\n\n            // Explicitly expand to avoid ciruclar references.\n            points.push([firstPoint[0], firstPoint[1]]);\n        }\n\n        const area = 0; // TODO -> The tool doesn't have these stats yet.\n        const perimeter = 0;\n\n        return {\n            points,\n            area,\n            perimeter,\n            trackingIdentifierTextValue,\n            finding,\n            findingSites: findingSites || []\n        };\n    }\n}\n\nMeasurementReport.registerTool(PlanarFreehandROI);\n\nexport default PlanarFreehandROI;\n","import { utilities } from \"dcmjs\";\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\nimport MeasurementReport from \"./MeasurementReport\";\n\nconst { Point: TID300Point } = utilities.TID300;\n\nconst PROBE = \"Probe\";\nconst trackingIdentifierTextValue = `${CORNERSTONE_3D_TAG}:${PROBE}`;\n\nclass Probe {\n    static getMeasurementData(\n        MeasurementGroup,\n        sopInstanceUIDToImageIdMap,\n        imageToWorldCoords,\n        metadata\n    ) {\n        const { defaultState, SCOORDGroup, ReferencedFrameNumber } =\n            MeasurementReport.getSetupMeasurementData(\n                MeasurementGroup,\n                sopInstanceUIDToImageIdMap,\n                metadata,\n                Probe.toolType\n            );\n\n        const referencedImageId =\n            defaultState.annotation.metadata.referencedImageId;\n\n        const { GraphicData } = SCOORDGroup;\n\n        const worldCoords = [];\n        for (let i = 0; i < GraphicData.length; i += 2) {\n            const point = imageToWorldCoords(referencedImageId, [\n                GraphicData[i],\n                GraphicData[i + 1]\n            ]);\n            worldCoords.push(point);\n        }\n\n        const state = defaultState;\n\n        state.annotation.data = {\n            handles: {\n                points: worldCoords,\n                activeHandleIndex: null,\n                textBox: {\n                    hasMoved: false\n                }\n            },\n            frameNumber: ReferencedFrameNumber\n        };\n\n        return state;\n    }\n\n    static getTID300RepresentationArguments(tool, worldToImageCoords) {\n        const { data, metadata } = tool;\n        let { finding, findingSites } = tool;\n        const { referencedImageId } = metadata;\n\n        if (!referencedImageId) {\n            throw new Error(\n                \"Probe.getTID300RepresentationArguments: referencedImageId is not defined\"\n            );\n        }\n\n        const { points } = data.handles;\n\n        const pointsImage = points.map(point => {\n            const pointImage = worldToImageCoords(referencedImageId, point);\n            return {\n                x: pointImage[0],\n                y: pointImage[1]\n            };\n        });\n\n        const TID300RepresentationArguments = {\n            points: pointsImage,\n            trackingIdentifierTextValue,\n            findingSites: findingSites || [],\n            finding\n        };\n\n        return TID300RepresentationArguments;\n    }\n}\n\nProbe.toolType = PROBE;\nProbe.utilityToolType = PROBE;\nProbe.TID300Representation = TID300Point;\nProbe.isValidCornerstoneTrackingIdentifier = TrackingIdentifier => {\n    if (!TrackingIdentifier.includes(\":\")) {\n        return false;\n    }\n\n    const [cornerstone3DTag, toolType] = TrackingIdentifier.split(\":\");\n\n    if (cornerstone3DTag !== CORNERSTONE_3D_TAG) {\n        return false;\n    }\n\n    return toolType === PROBE;\n};\n\nMeasurementReport.registerTool(Probe);\n\nexport default Probe;\n","import { normalizers, derivations } from \"dcmjs\";\nimport { fillSegmentation } from \"../../Cornerstone/Segmentation_4X\";\n\nconst { Normalizer } = normalizers;\nconst { Segmentation: SegmentationDerivation } = derivations;\n\n/**\n * generateSegmentation - Generates a DICOM Segmentation object given cornerstoneTools data.\n *\n * @param images - An array of the cornerstone image objects, which includes imageId and metadata\n * @param labelmaps - An array of the 3D Volumes that contain the segmentation data.\n */\nfunction generateSegmentation(images, labelmaps, metadata, options) {\n    const segmentation = _createMultiframeSegmentationFromReferencedImages(\n        images,\n        metadata,\n        options\n    );\n    return fillSegmentation(segmentation, labelmaps, options);\n}\n\n/**\n * _createMultiframeSegmentationFromReferencedImages - description\n *\n * @param images - An array of the cornerstone image objects related to the reference\n * series that the segmentation is derived from. You can use methods such as\n * volume.getCornerstoneImages() to get this array.\n *\n * @param options - the options object for the SegmentationDerivation.\n * @returns The Seg derived dataSet.\n */\nfunction _createMultiframeSegmentationFromReferencedImages(\n    images,\n    metadata,\n    options\n) {\n    const datasets = images.map(image => {\n        // add the sopClassUID to the dataset\n        const instance = metadata.get(\"instance\", image.imageId);\n        return {\n            ...image,\n            ...instance,\n            // Todo: move to dcmjs tag style\n            SOPClassUID: instance.SopClassUID,\n            SOPInstanceUID: instance.SopInstanceUID,\n            PixelData: image.getPixelData(),\n            _vrMap: {\n                PixelData: \"OW\"\n            },\n            _meta: {}\n        };\n    });\n\n    const multiframe = Normalizer.normalizeToDataset(datasets);\n\n    return new SegmentationDerivation([multiframe], options);\n}\n\nexport { generateSegmentation };\n","import { CornerstoneSEG } from \"../../Cornerstone\";\n\nconst { Segmentation } = CornerstoneSEG;\nconst { generateToolState: generateToolStateCornerstoneLegacy } = Segmentation;\n\n/**\n * generateToolState - Given a set of cornerstoneTools imageIds and a Segmentation buffer,\n * derive cornerstoneTools toolState and brush metadata.\n *\n * @param   imageIds - An array of the imageIds.\n * @param   arrayBuffer - The SEG arrayBuffer.\n * @param   skipOverlapping - skip checks for overlapping segs, default value false.\n * @param   tolerance - default value 1.e-3.\n *\n * @returns a list of array buffer for each labelMap\n *  an object from which the segment metadata can be derived\n *  list containing the track of segments per frame\n *  list containing the track of segments per frame for each labelMap                   (available only for the overlapping case).\n */\nfunction generateToolState(\n    imageIds,\n    arrayBuffer,\n    metadataProvider,\n    skipOverlapping = false,\n    tolerance = 1e-3\n) {\n    return generateToolStateCornerstoneLegacy(\n        imageIds,\n        arrayBuffer,\n        metadataProvider,\n        skipOverlapping,\n        tolerance\n    );\n}\n\nexport { generateToolState };\n","import MeasurementReport from \"./MeasurementReport\";\nimport CodeScheme from \"./CodingScheme\";\nimport CORNERSTONE_3D_TAG from \"./cornerstone3DTag\";\n\nimport ArrowAnnotate from \"./ArrowAnnotate\";\nimport Bidirectional from \"./Bidirectional\";\nimport Angle from \"./Angle\";\nimport CobbAngle from \"./CobbAngle\";\nimport CircleROI from \"./CircleROI\";\nimport EllipticalROI from \"./EllipticalROI\";\nimport RectangleROI from \"./RectangleROI\";\nimport Length from \"./Length\";\nimport PlanarFreehandROI from \"./PlanarFreehandROI\";\nimport Probe from \"./Probe\";\nimport * as Segmentation from \"./Segmentation\";\n\nconst Cornerstone3DSR = {\n    Bidirectional,\n    CobbAngle,\n    Angle,\n    Length,\n    CircleROI,\n    EllipticalROI,\n    RectangleROI,\n    ArrowAnnotate,\n    Probe,\n    PlanarFreehandROI,\n    MeasurementReport,\n    CodeScheme,\n    CORNERSTONE_3D_TAG\n};\n\nconst Cornerstone3DSEG = {\n    Segmentation\n};\n\nexport { Cornerstone3DSR, Cornerstone3DSEG };\n","import { data } from \"dcmjs\";\n\nconst { Colors, BitArray } = data;\n\n// TODO: Is there a better name for this? RGBAInt?\n// Should we move it to Colors.js\nfunction dicomlab2RGBA(cielab) {\n    const rgba = Colors.dicomlab2RGB(cielab).map(x => Math.round(x * 255));\n    rgba.push(255);\n\n    return rgba;\n}\n\n// TODO: Copied these functions in from VTK Math so we don't need a dependency.\n// I guess we should put them somewhere\n// https://github.com/Kitware/vtk-js/blob/master/Sources/Common/Core/Math/index.js\nfunction cross(x, y, out) {\n    const Zx = x[1] * y[2] - x[2] * y[1];\n    const Zy = x[2] * y[0] - x[0] * y[2];\n    const Zz = x[0] * y[1] - x[1] * y[0];\n    out[0] = Zx;\n    out[1] = Zy;\n    out[2] = Zz;\n}\n\nfunction norm(x, n = 3) {\n    switch (n) {\n        case 1:\n            return Math.abs(x);\n        case 2:\n            return Math.sqrt(x[0] * x[0] + x[1] * x[1]);\n        case 3:\n            return Math.sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);\n        default: {\n            let sum = 0;\n            for (let i = 0; i < n; i++) {\n                sum += x[i] * x[i];\n            }\n            return Math.sqrt(sum);\n        }\n    }\n}\n\nfunction normalize(x) {\n    const den = norm(x);\n    if (den !== 0.0) {\n        x[0] /= den;\n        x[1] /= den;\n        x[2] /= den;\n    }\n    return den;\n}\n\nfunction subtract(a, b, out) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    out[2] = a[2] - b[2];\n}\n\n// TODO: This is a useful utility on its own. We should move it somewhere?\n// dcmjs.adapters.vtk.Multiframe? dcmjs.utils?\nfunction geometryFromFunctionalGroups(dataset, PerFrameFunctionalGroups) {\n    const geometry = {};\n    const pixelMeasures =\n        dataset.SharedFunctionalGroupsSequence.PixelMeasuresSequence;\n    const planeOrientation =\n        dataset.SharedFunctionalGroupsSequence.PlaneOrientationSequence;\n\n    // Find the origin of the volume from the PerFrameFunctionalGroups' ImagePositionPatient values\n    //\n    // TODO: assumes sorted frames. This should read the ImagePositionPatient from each frame and\n    // sort them to obtain the first and last position along the acquisition axis.\n    const firstFunctionalGroup = PerFrameFunctionalGroups[0];\n    const lastFunctionalGroup =\n        PerFrameFunctionalGroups[PerFrameFunctionalGroups.length - 1];\n    const firstPosition =\n        firstFunctionalGroup.PlanePositionSequence.ImagePositionPatient.map(\n            Number\n        );\n    const lastPosition =\n        lastFunctionalGroup.PlanePositionSequence.ImagePositionPatient.map(\n            Number\n        );\n\n    geometry.origin = firstPosition;\n\n    // NB: DICOM PixelSpacing is defined as Row then Column,\n    // unlike ImageOrientationPatient\n    geometry.spacing = [\n        pixelMeasures.PixelSpacing[1],\n        pixelMeasures.PixelSpacing[0],\n        pixelMeasures.SpacingBetweenSlices\n    ].map(Number);\n\n    geometry.dimensions = [\n        dataset.Columns,\n        dataset.Rows,\n        PerFrameFunctionalGroups.length\n    ].map(Number);\n\n    const orientation = planeOrientation.ImageOrientationPatient.map(Number);\n    const columnStepToPatient = orientation.slice(0, 3);\n    const rowStepToPatient = orientation.slice(3, 6);\n\n    geometry.planeNormal = [];\n\n    cross(columnStepToPatient, rowStepToPatient, geometry.planeNormal);\n\n    geometry.sliceStep = [];\n    subtract(lastPosition, firstPosition, geometry.sliceStep);\n    normalize(geometry.sliceStep);\n    geometry.direction = columnStepToPatient\n        .concat(rowStepToPatient)\n        .concat(geometry.sliceStep);\n\n    return geometry;\n}\n\nexport default class Segmentation {\n    constructor() {}\n\n    /**\n     * Produces an array of Segments from an input DICOM Segmentation dataset\n     *\n     * Segments are returned with Geometry values that can be used to create\n     * VTK Image Data objects.\n     *\n     * @example Example usage to create VTK Volume actors from each segment:\n     *\n     * const actors = [];\n     * const segments = generateToolState(dataset);\n     * segments.forEach(segment => {\n     *   // now make actors using the segment information\n     *   const scalarArray = vtk.Common.Core.vtkDataArray.newInstance({\n     *        name: \"Scalars\",\n     *        numberOfComponents: 1,\n     *        values: segment.pixelData,\n     *    });\n     *\n     *    const imageData = vtk.Common.DataModel.vtkImageData.newInstance();\n     *    imageData.getPointData().setScalars(scalarArray);\n     *    imageData.setDimensions(geometry.dimensions);\n     *    imageData.setSpacing(geometry.spacing);\n     *    imageData.setOrigin(geometry.origin);\n     *    imageData.setDirection(geometry.direction);\n     *\n     *    const mapper = vtk.Rendering.Core.vtkVolumeMapper.newInstance();\n     *    mapper.setInputData(imageData);\n     *    mapper.setSampleDistance(2.);\n     *\n     *    const actor = vtk.Rendering.Core.vtkVolume.newInstance();\n     *    actor.setMapper(mapper);\n     *\n     *    actors.push(actor);\n     * });\n     *\n     * @param dataset\n     * @return {{}}\n     */\n    static generateSegments(dataset) {\n        if (dataset.SegmentSequence.constructor.name !== \"Array\") {\n            dataset.SegmentSequence = [dataset.SegmentSequence];\n        }\n\n        dataset.SegmentSequence.forEach(segment => {\n            // TODO: other interesting fields could be extracted from the segment\n            // TODO: Read SegmentsOverlay field\n            // http://dicom.nema.org/medical/dicom/current/output/chtml/part03/sect_C.8.20.2.html\n\n            // TODO: Looks like vtkColor only wants RGB in 0-1 values.\n            // Why was this example converting to RGBA with 0-255 values?\n            const color = dicomlab2RGBA(segment.RecommendedDisplayCIELabValue);\n\n            segments[segment.SegmentNumber] = {\n                color,\n                functionalGroups: [],\n                offset: null,\n                size: null,\n                pixelData: null\n            };\n        });\n\n        // make a list of functional groups per segment\n        dataset.PerFrameFunctionalGroupsSequence.forEach(functionalGroup => {\n            const segmentNumber =\n                functionalGroup.SegmentIdentificationSequence\n                    .ReferencedSegmentNumber;\n\n            segments[segmentNumber].functionalGroups.push(functionalGroup);\n        });\n\n        // determine per-segment index into the pixel data\n        // TODO: only handles one-bit-per pixel\n        const frameSize = Math.ceil((dataset.Rows * dataset.Columns) / 8);\n        let nextOffset = 0;\n\n        Object.keys(segments).forEach(segmentNumber => {\n            const segment = segments[segmentNumber];\n\n            segment.numberOfFrames = segment.functionalGroups.length;\n            segment.size = segment.numberOfFrames * frameSize;\n            segment.offset = nextOffset;\n\n            nextOffset = segment.offset + segment.size;\n\n            const packedSegment = dataset.PixelData.slice(\n                segment.offset,\n                nextOffset\n            );\n\n            segment.pixelData = BitArray.unpack(packedSegment);\n\n            const geometry = geometryFromFunctionalGroups(\n                dataset,\n                segment.functionalGroups\n            );\n\n            segment.geometry = geometry;\n        });\n\n        return segments;\n    }\n}\n","import { CornerstoneSR } from \"./Cornerstone\";\nimport { Cornerstone3DSR, Cornerstone3DSEG } from \"./Cornerstone3D\";\nimport { VTKjsSEG } from \"./VTKjs\";\nimport * as Enums from \"./enums\";\nimport * as helpers from \"./helpers\";\n\nconst adaptersSR = {\n    Cornerstone: CornerstoneSR,\n    Cornerstone3D: Cornerstone3DSR\n};\n\nconst adaptersSEG = {\n    Cornerstone: CornerstoneSR,\n    Cornerstone3D: Cornerstone3DSEG,\n    VTKjs: VTKjsSEG\n};\n\nexport { adaptersSR, adaptersSEG, Enums, helpers };\n"],"names":["id","packageJson","SOPClassHandlerName","SOPClassHandlerId","POINT","MULTIPOINT","POLYLINE","CIRCLE","ELLIPSE","DICOMSRDisplayTool","AnnotationTool","constructor","super","arguments","length","undefined","configuration","isPointNearTool","getHandleNearImagePoint","renderAnnotation","enabledElement","svgDrawingHelper","viewport","element","annotations","annotation","this","getToolName","filterInteractableAnnotationsForElement","trackingUniqueIdentifiersForElement","getTrackingUniqueIdentifiersForElement","activeIndex","trackingUniqueIdentifiers","activeTrackingUniqueIdentifier","filteredAnnotations","filter","includes","data","cachedStats","TrackingUniqueIdentifier","_actors","size","styleSpecifier","toolGroupId","toolName","viewportId","i","annotationUID","renderableData","referencedImageId","metadata","lineWidth","getStyle","lineDash","options","color","Object","keys","forEach","GraphicType","renderableDataForGraphicType","renderMethod","canvasCoordinatesAdapter","SCOORD_TYPES","renderPoint","renderMultipoint","renderPolyLine","renderEllipse","utilities","Error","canvasCoordinates","renderTextBox","_getTextBoxLinesFromLabels","labels","labelLength","Math","min","lines","labelEntry","push","_labelToShorthand","label","value","drawingOptions","width","allCanvasCoordinates","map","index","p","worldToCanvas","lineUID","drawing","concat","point","imagePixelModule","metaData","xOffset","yOffset","columns","rows","imagePoint","csUtils","arrowEnd","arrowUID","ellipsePointsWorld","rotation","getRotation","canvasCorners","adaptedCanvasCoordinates","textLines","canvasTextBoxCoords","handles","textBox","worldPosition","canvasToWorld","textBoxPosition","textBoxOptions","getLinkedTextBoxStyle","boundingBox","x","left","y","top","height","worldBoundingBox","topLeft","topRight","bottomLeft","bottomRight","SHORT_HAND_MAP","AREA","Length","CORNERSTONEFREETEXT","shortHand","DICOMSRDisplay","SRLength","SRBidirectional","SREllipticalROI","SRCircleROI","SRArrowAnnotate","SRAngle","SRCobbAngle","SRRectangleROI","SRPlanarFreehandROI","EPSILON","addMeasurement","measurement","imageId","displaySetInstanceUID","toolNames","measurementData","coords","coord","GraphicData","TrackingIdentifier","cornerstoneTag","split","worldPos","pointsWorld","center","onPerimeter","radius","vec3","imagePlaneModule","columnCosines","rowCosines","firstAxisStart","firstAxisEnd","secondAxisStart","secondAxisEnd","majorAxisStart","majorAxisEnd","minorAxisStart","minorAxisEnd","majorAxisVec","minorAxisVec","columnCosinesVec","projectedMajorAxisOnColVec","abs","projectedMinorAxisOnColVec","absoluteOfMajorDotProduct","absoluteOfMinorDotProduct","console","warn","_getRenderableData","annotationManager","frameNumber","ReferencedSOPSequence","ReferencedFrameNumber","SRAnnotation","FrameOfReferenceUID","frameOfReferenceUID","addAnnotation","loaded","ReferencedSOPInstanceUID","cornerstoneAdapters","adaptersSR","Cornerstone3D","MeasurementReport","CORNERSTONE_TOOL_CLASSES_BY_UTILITY_TYPE","supportedLegacyCornerstoneTags","CORNERSTONE_3D_TAG","CodeScheme","Cornerstone3DCodeScheme","ImageSet","MetadataProvider","metadataProvider","classes","sopClassUids","CORNERSTONE_3D_TOOLS_SOURCE_NAME","CORNERSTONE_3D_TOOLS_SOURCE_VERSION","validateSameStudyUID","uid","instances","it","StudyInstanceUID","SOPInstanceUID","CodeNameCodeSequenceValues","ImagingMeasurementReport","ImageLibrary","ImagingMeasurements","MeasurementGroup","ImageLibraryGroup","Finding","FindingSite","CornerstoneFreeText","codeValues","CodingSchemeDesignators","SRT","CornerstoneCodeSchemes","CodingSchemeDesignator","RELATIONSHIP_TYPE","INFERRED_FROM","CONTAINS","CORNERSTONE_FREETEXT_CODE_VALUE","addInstances","displaySetService","utils","sortStudyInstances","instance","isLoaded","_getDisplaySetsFromSeries","servicesManager","extensionManager","SeriesInstanceUID","SeriesDescription","SeriesNumber","SeriesDate","ConceptNameCodeSequence","SOPClassUID","CodeValue","services","uiNotificationService","show","title","message","type","duration","displaySet","Modality","guid","referencedImages","measurements","isDerivedDisplaySet","load","measurementService","dataSources","getDataSources","dataSource","ContentSequence","ImagingMeasurementReportContentSequence","_getSequenceAsArray","find","item","ref","ReferencedSOPClassUID","_getReferencedImagesList","mergedContentSequencesByTrackingUniqueIdentifiers","MeasurementGroups","TrackingUniqueIdentifierItem","trackingUniqueIdentifier","UID","_getMergedContentSequencesByTrackingUniqueIdentifiers","mergedContentSequence","some","group","ValueType","graphicItem","UIDREFContentItem","TrackingIdentifierContentItem","NUMContentItems","_getCoordsFromSCOORDOrSCOORD3D","TextValue","MeasuredValueSequence","_getLabelFromMeasuredValueSequence","_processTID1410Measurement","finding","findingSites","ConceptCodeSequence","CodeMeaning","cornerstoneFreeTextFindingSite","_processNonGeometricallyDefinedMeasurement","_processMeasurement","_getMeasurements","mappings","getSourceMappings","isHydrated","isRehydratable","mappingDefinitions","m","annotationType","adapterKeys","adapterKey","isValidCornerstoneTrackingIdentifier","adapters","key","adapter","mappedTrackingIdentifier","log","activeDisplaySets","activeDisplaySet","_checkIfCanAddMeasurementsToDisplaySet","subscribe","EVENTS","DISPLAY_SETS_ADDED","displaySetsAdded","newDisplaySet","_load","srDisplaySet","unloadedMeasurements","images","SOPInstanceUIDs","imageIdsForDisplaySet","getImageIdsForDisplaySet","getUIDsFromImageID","j","_measurementReferencesSOPInstanceUID","splice","Number","RelationshipType","ReferencedFrameOfReferenceSequence","NumericValue","MeasurementUnitsCodeSequence","toFixed","sequence","Array","isArray","_ref","name","getDisplaySetsFromSeries","srProtocol","hasUpdatedPriorsInformation","protocolMatchingRules","toolGroupIds","numberOfPriorsReferenced","defaultViewport","viewportOptions","viewportType","allowUnmatchedView","displaySets","matchedDisplaySetsIndex","displaySetSelectors","srDisplaySetId","seriesMatchingRules","attribute","constraint","equals","stages","viewportStructure","layoutType","properties","viewports","OHIF","additionalFindingTypes","filteredToolState","addToFilteredToolState","toolType","imageIdSpecificToolState","measurementDataI","md","toolData","assign","uids","slice","framesOfReference","getFramesOfReference","frameOfReference","frameOfReferenceAnnotations","getAnnotations","toolTypes","k","uidIndex","findIndex","actions","downloadReport","_ref2","srDataset","generateReport","reportBlob","dcmjs","datasetToBlob","objectUrl","URL","createObjectURL","window","location","storeMeasurements","async","_ref3","info","store","dicom","error","Promise","reject","naturalizedReport","getFilteredCornerstoneToolState","report","dataset","SpecificCharacterSet","_generateReport","deleteStudyMetadataPromise","DicomMetadataStore","definitions","commandFn","storeContexts","defaultContext","addToolInstance","toolClass","InstanceClass","addTool","findInstance","sopUid","referencedDisplaySet","getDisplaySetByUID","findReferencedInstances","instanceById","createReferencedImageDisplaySet","imageSet","setAttributes","SeriesTime","isMultiFrame","numImageFrames","isReconstructable","isCompositeStack","madeInClient","excludeFromThumbnailBrowser","updateInstances","addDisplaySets","Component","React","OHIFCornerstoneSRViewport","props","fallback","onModeEnter","getDisplaySetCache","values","ds","preRegistration","LengthTool","BidirectionalTool","EllipticalROITool","CircleROITool","ArrowAnnotateTool","AngleTool","CobbAngleTool","PlanarFreehandROITool","dashedLine","setToolGroupToolStyles","global","getViewportModule","component","_extends","getCommandsModule","getSopClassHandlerModule","getUtilityModule","exports","state","trackingIdentifiersByViewportId","setTrackingUniqueIdentifiersForElement","getEnabledElement","convertCode","codingValues","code","text","convertSites","sites","ret","site","hydrateStructuredReport","getActiveDataSource","customizationService","getCustomization","getInstance","sopInstanceUIDToImageId","imageIdsForToolState","datasetToUse","REPORT","GROUP","TRACKING_IDENTIFIER","imagingMeasurementContent","toArray","codeMeaningEquals","measurementGroups","cornerstoneToolClasses","registeredToolClasses","measurementGroup","TrackingIdentifierGroup","contentItem","_mapLegacyDataSet","storedMeasurementByAnnotationType","generateToolState","hydratableMeasurementsInSR","imageIds","targetStudyInstanceUID","sopInstanceUid","SeriesInstanceUIDs","source","getSource","freeTextLabel","fs","getLabelFromDCMJSImportedToolData","matchingMapping","addRawMeasurement","toMeasurementSchema","codeMeaningName","TID1500$1","TID1500","addAccessors$1","addAccessors","StructuredReport$1","derivations","StructuredReport","Normalizer$4","normalizers","Normalizer","TID1500MeasurementReport$1","TID1500MeasurementReport","TID1501MeasurementGroup$1","TID1501MeasurementGroup","DicomMetaDictionary$3","DicomMetaDictionary","FINDING$2","FINDING_SITE$2","FINDING_SITE_OLD$1","codeValueMatch$1","oldCode","MeasurementReport$1","_classCallCheck","_createClass","contentSequenceArr","findingGroup","findingSiteGroups","NUMGroup","SCOORDGroup","defaultState","frameIndex","complete","fsg","description","findingSite","toolState","allMeasurementGroups","firstImageId","generalSeriesModule","get","studyInstanceUID","seriesInstanceUID","sopCommonModule","sopClassUID","sopInstanceUID","isMultiframeSOPClassUID","toolTypeData","CORNERSTONE_TOOL_CLASSES_BY_TOOL_TYPE","Measurements","tool","args","getTID300RepresentationArguments","TID300Representation","getTID300ContentItem$1","getMeasurementGroup$1","_MeasurementReport","TID1501MeasurementGroups","fileMetaInformationVersionArray","Uint8Array","derivationSourceDataset","_meta","FileMetaInformationVersion","Value","buffer","vr","TransferSyntaxUID","ImplementationClassUID","ImplementationVersionName","_vrMap","PixelData","hooks","ContentTemplateSequence","TemplateIdentifier","TrackingIdentifierValue","getToolClass","tc","getMeasurementData","utilityToolType","MEASUREMENT_BY_TOOLTYPE","CORNERSTONE_4_TAG","TID300Length$1","TID300","LENGTH$1","Length$1","_MeasurementReport$ge","getSetupMeasurementData","_objectSpread2","start","end","hasMoved","movesIndependently","drawnIndependently","allowedOutsideImage","hasBoundingBox","_SCOORDGroup$GraphicD","_slicedToArray","point1","point2","distance","trackingIdentifierTextValue","_TrackingIdentifier$s2","cornerstone4Tag","registerTool","TID300Polyline$3","Polyline","FreehandRoi","points","active","area","invalidated","_tool$cachedStats","_cachedStats$area","_cachedStats$perimete","perimeter","TID300Bidirectional$1","Bidirectional","BIDIRECTIONAL$1","Bidirectional$1","longAxisNUMGroup","longAxisSCOORDGroup","shortAxisNUMGroup","shortAxisSCOORDGroup","longestDiameter","String","shortestDiameter","max","highlight","perpendicularStart","perpendicularEnd","isCreating","visible","_tool$handles","longAxis","shortAxis","longAxisLength","shortAxisLength","TID300Ellipse$1","Ellipse","ELLIPTICALROI$1","EllipticalRoi","majorAxis","minorAxis","minorAxisLength","sqrt","pow","minorAxisDirection","halfMinorAxisLength","corner1","corner2","initialRotation","halfXLength","halfYLength","TID300Circle$1","Circle","CIRCLEROI$1","CircleRoi","PI","TID300Point$2","Point","ARROW_ANNOTATE$1","CORNERSTONEFREETEXT$1","ArrowAnnotate$1","ArrowAnnotate","TID300RepresentationArguments","TID300CobbAngle$2","CobbAngle","COBB_ANGLE","CobbAngle$1","rAngle","start2","end2","point3","point4","TID300Angle","Angle","ANGLE","Angle$1","middle","TID300Polyline$2","RectangleRoi","_utilities$orientatio$1","orientation","rotateDirectionCosinesInPlane$1","rotateDirectionCosinesInPlane","flipIOP$1","flipImageOrientationPatient","flipMatrix2D$1","flipMatrix2D","rotateMatrix902D$1","rotateMatrix902D","BitArray$2","BitArray","DicomMessage$1","DicomMessage","DicomMetaDictionary$2","Normalizer$3","SegmentationDerivation$2","Segmentation","Segmentation$5","generateSegmentation","brushData","includeSliceSpacing","segments","image0","dims","z","xy","_getSegCount","seg","isMultiframe","datasets","arrayBuffer","byteArray","dicomData","readFile","naturalizeDataset","dict","namifyDataset","meta","_arrayBuffer","_dicomData","_dataset","multiframe","normalizeToDataset","_createSegFromImages$1","_getNumberOfFramesPer","segmentIndicies","referencedFramesPerSegment","_i2","segIdx","brush","pixelData","_getNumberOfFramesPerSegment","NumberOfFrames","setNumberOfFrames","_i","segmentIndex","referencedFrameIndicies","referencedFrameNumbers","segment","addSegment","_extractCornerstoneToolsPixelData","bitPackPixelData","validOrientations","iop","orientations","h","v","iop90","getValidOrientations$1","_toConsumableArray","SharedFunctionalGroupsSequence","sharedImageOrientationPatient","PlaneOrientationSequence","ImageOrientationPatient","sliceLength","Columns","Rows","segMetadata","segmentSequence","SegmentSequence","seriesInstanceUid","ReferencedSeriesSequence","getSegmentMetadata$1","segType","SegmentationType","unpack","MaximumFractionalValue","onlyMaxAndZero","unpackPixelData$1","PerFrameFunctionalGroupsSequence","inPlane","PerFrameFunctionalGroups","ImageOrientationPatientI","alignedPixelDataI","alignPixelDataWithSourceData$1","ndarray","SegmentIdentificationSequence","ReferencedSegmentNumber","addImageIdSpecificBrushToolState","getImageIdOfSourceImage","DerivationImageSequence","SourceImageSequence","referencedFrames","pixelDataIndex","brushPixelData","numSegments","pixelData2D","brushDataI","cToolsPixelData","imageIdFrameNumber","getImageIdOfReferencedFrame$1","getImageIdOfReferencedSingleFramedSOPInstance","compareIOP","Events","dx","iop1","iop2","Events$1","_utilities$orientatio","flipIOP","nearlyEqual","datasetToDict","BitArray$1","DicomMetaDictionary$1","Normalizer$2","SegmentationDerivation$1","_utilities$compressio","compression","encode","decode","generateSegmentationDefaultOptions","rleEncode","fillSegmentation$1","segmentation","inputLabelmaps3D","userOptions","labelmaps3D","numberOfFrames","referencedFramesPerLabelmap","_loop","labelmap3D","labelmapIndex","labelmaps2D","_loop2","labelmap2D","segmentsOnLabelmap","_labelmapIndex","segmentMetadata","labelmaps","_getLabelmapsFromReferencedFrameIndicies","addSegmentFromLabelmap","rleEncodedFrames","assignToDataset","BitsAllocated","BitsStored","HighBit","SegmentationFractionalType","Buffer","from","write","Blob","frame","_generateToolState","_regeneratorRuntime","mark","_callee","_options$skipOverlapp","skipOverlapping","_options$tolerance","tolerance","_options$TypedArrayCo","TypedArrayConstructor","_options$maxBytesPerC","maxBytesPerChunk","eventTarget","triggerEvent","pixelDataChunks","sopUIDImageIdIndexMap","overlapping","insertFunction","segmentsOnFrameArray","segmentsOnFrame","arrayBufferLength","labelmapBufferArray","imageIdMaps","segmentsPixelIndices","centroidXYZ","wrap","_context","prev","next","getValidOrientations","getSegmentMetadata","abrupt","unpackPixelData","checkOrientation","reduce","acc","checkSEGsOverlapping","t0","insertOverlappingPixelDataPlanar","insertPixelDataPlanar","BYTES_PER_ELEMENT","ArrayBuffer","curr","indices","Map","imageIdIndexBufferIndex","_calculateCentroid","calculateCentroid","xAcc","yAcc","zAcc","count","set","floor","centroids","stop","apply","findReferenceSourceImageId","frameSegment","PerFrameFunctionalGroup","frameSourceImageSequence","getImageIdOfReferencedFrame","getImageIdOfSourceImageBySourceImageSequence","ReferencedSeriesInstanceUID","PlanePositionSequence","ImagePositionPatient","imageIdsIndexc","sourceImageMetadata","compareArrays","getImageIdOfSourceImagebyGeometry","groupsLen","frameSegmentsMapping","_loop3","getSegmentIndex","imageIdIndex","has","segmentArray","_step","_iterator","_createForOfIteratorHelper","entries","s","n","done","role","temp2DArray","fill","_frameSegment","view","readFromUnpackedChunks","alignPixelDataWithSourceData","len","err","e","f","M","tempBuffer","tempSegmentsOnFrame","cloneDeep","numberOfSegs","segmentIndexToProcess","_loop4","byteOffset","labelmap2DView","segmentOnFrame","chunkSize","ceil","shouldTriggerEvent","resolve","processInChunks","indexCache","segmentIndexObject","percentComplete","round","SEGMENTATION_LOAD_PROGRESS","setTimeout","sourceDataDimensions","operation","absDotColumnCosines","absDotRowCosines","checkIfPerpendicular","bitArray","chunks","maxBitsPerChunk","numberOfChunks","startBit","endBit","startByte","endByte","chunk","unpackedChunk","getUnpackedChunks","array1","array2","offset","mapping","totalBytes","total","startChunkIndex","startOffsetInChunk","endChunkIndex","endOffsetInChunk","chunkIndex","getUnpackedOffsetAndLength","result","resultOffset","_i3","_Object$entries","_Object$entries$_i","bufferIndices","_step2","_iterator2","bufferIndex","Segmentation$4","_createSegFromImages","_x","_x2","_x3","_x4","fillSegmentation","CornerstoneSR","CornerstoneSEG","labelmaps3DorBrushData","cornerstoneToolsVersion","__assign","t","prototype","hasOwnProperty","call","__spreadArray","to","pack","ar","l","CodingScheme","Normalizer$1","FINDING","FINDING_SITE","FINDING_SITE_OLD","codeValueMatch","getMeasurementGroup","worldToImageCoords","getTID300ContentItem","getCornerstoneLabelFromDefaultState","_a","cornersoneFreeTextCodingValue","generateDatasetMeta","sopInstanceUIDToImageIdMap","sopInstanceUIDsToSeriesInstanceUIDMap","derivationSourceDatasets","dsd","generateDerivationSourceDataset","tid1500MeasurementReport","imageToWorldCoords","TrackingIdentifierValue_1","TID300Point$1","ARROW_ANNOTATE","trackingIdentifierTextValue$7","worldCoords","secondPoint","arrowFirst","activeHandleIndex","_data$handles","pointImage","cornerstone3DTag","TID300Bidirectional","BIDIRECTIONAL","trackingIdentifierTextValue$6","_b","shortAxisPoints","longAxisPoints","firstPointPairs","secondPointPairs","longAxisStartImage","longAxisEndImage","shortAxisStartImage","shortAxisEndImage","TID300CobbAngle$1","MEASUREMENT_TYPE$1","trackingIdentifierTextValue$5","angle","start1","TID300CobbAngle","MEASUREMENT_TYPE","trackingIdentifierTextValue$4","end1","trackingIdentifier","toLowerCase","TID300Circle","CIRCLEROI","CircleROI","TID300Ellipse","ELLIPTICALROI","EllipticalROI","ellipsePoints","bottom","right","TID300Polyline$1","TOOLTYPE","trackingIdentifierTextValue$3","RectangleROI","corners","TID300Length","LENGTH","trackingIdentifierTextValue$2","_defineProperty","_data$cachedStats","TID300Polyline","PLANARFREEHANDROI","trackingIdentifierTextValue$1","PlanarFreehandROI","isOpenContour","pop","polyline","firstPoint","TID300Point","PROBE","Probe","Cornerstone3DSR","Colors","Cornerstone"],"sourceRoot":""}